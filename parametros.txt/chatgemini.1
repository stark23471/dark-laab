This is the final, comprehensive prompt summarizing all technical requirements, design concepts, and UX modifications developed through our conversation. Please use this single prompt to generate the complete project.

FINAL PROJECT PROMPT: GOTHIC 3D TATTOO PORTFOLIO (SUNG STUDIOS)

You are a Senior Front-End and WebGL Developer specializing in Three.js and cinematic UX design. Your task is to build an interactive 3D website for a tattoo artist, centered on a subtle, ghoulish horror theme inspired by Tim Burton's Sleepy Hollow.

1. TECHNICAL REQUIREMENTS

RequirementDetailsStackUse ONLY HTML, CSS, JavaScript (ES6+), and Three.js. No frameworks (React, Vue, etc.).DocumentationEvery file (.html, .css, .js) MUST contain EXTENSIVE COMMENTS in BRAZILIAN PORTUGUESE (PT-BR) explaining the functionality, variables, and editing instructions for future maintenance.File StructureMust adhere to the following file structure: index.html, COMO_EDITAR.txt, checklist.txt, README.md at root. Folders: /css, /js, /data, /assets/images/img, /assets/audio.Helper FilesInclude COMO_EDITAR.txt and checklist.txt (listing required items).Custom BrandingThe project's brand name is Sung. The logo image is belial.png (must be loaded from /assets/images/). Copyright must reflect "© 2025 Sung".

Exportar para as Planilhas

2. CORE DESIGN & STYLING

FeatureSpecificationAestheticsSubtle/Cinematic Horror (Tim Burton style).PaletteStrictly Black and White (Black background, white accents/text).TypographyUse a cinematic pair (e.g., Cinzel + Inter/Cormorant + Open Sans).AccessibilityWCAG AA contrast (achieved via B&W), full keyboard navigation (Tab, Enter, Esc), descriptive alt tags.UX FlowWORLD 1 (Forest) → Transition → WORLD 2 (Corridor)

Exportar para as Planilhas

3. SCENE 1: THE DISCOVERY (HIGHWAY & GOTHIC DOOR)

The player must not start in the corridor. The scene must serve as a narrative entrance.

Starting Point: Player spawns on a dim, empty American-style Highway (Z > 55).

Environment: The sides of the road lead into a dense, foggy forest (Simulated using low-poly geometry and Billboards, e.g., arvore.png).

Clima/Lighting: The ambient light and fog color must be a dark, heavy gray/blue-gray to match a foggy morning/dusk atmosphere (clima.png reference).

Path: The player must quickly find a narrow dirt trail leading off the side of the road and deep into the trees (Z < 55).

Boundary/Goal: At the end of the trail, the player encounters a solitary Gothic Stone Door set into a rock face (Reference: porta.png). This object must be the target for interaction.

Collision: Player movement must be limited to the road and the narrow dirt trail (must prevent movement through the dense forest walls).

4. SCENE TRANSITION LOGIC (THEATER EFFECT)

When the player interacts with the Gothic Stone Door (using [E] or the Action Button):

Fade In: A fullscreen white element (#transition-fade) must fade in quickly (0.5 seconds) to simulate a Blinding White Light/Energy Flash.

Teleport: While the screen is white, the player is instantly teleported from the forest position (Z > 35) to the corridor starting position (Z = 10).

Reset: The player's camera rotation must be reset to look straight forward (0, 0, 0).

Fade Out: The white screen must fade out slowly (1.5 seconds, using ease-out), simulating the player's eyes adjusting to the dim candlelight of the corridor.

5. SCENE 2: THE GALLERY (CORRIDOR)

Layout: Single, linear hallway (geometry built in scene.js).

Content: Must display 18 unique artworks (using the user's PNG files found in assets/images/img/). Corridor geometry size must be increased to accommodate this number of frames (approx. 80m long).

6. CONTROL OPTIMIZATION (UX Finalized)

ComponentDesktop (WASD/Mouse)Mobile (D-Pad/Touch)Movement Speed1.8 m/s (Slow, Cinematic Walk)1.8 m/s (Slow, Cinematic Walk)Camera SpeedLow Sensitivity (Multiplier: 0.0008)Adjusted Sensitivity (Multiplier: 0.0025)Movement InputWASD or Arrow Keys.D-Pad Button Cluster (#dpad-container).Interaction Input[E] key (must work reliably with crosshair).Dedicated Action Button (#action-btn) (must work reliably with crosshair).Mira (Crosshair)Must be visible (+) in the center of the screen.Must be visible (+) in the center of the screen.Mobile UXN/AMust display a "Rotate Screen" message if device is in Portrait mode.Interaction UXInteraction hitbox (plaque/door) must be large and forgiving (e.g., the size of the whole frame).Interaction hitbox (plaque/door) must be large and forgiving.

Exportar para as Planilhas

Aqui está a estrutura completa do projeto, gerada de acordo com todas as suas especificações.

Este projeto é dividido em seus arquivos componentes. Você precisará criar cada arquivo e pasta exatamente como descrito. Os únicos itens que você precisa fornecer são os arquivos de imagem listados no checklist.txt.

README.md
Markdown
# Sung Studios - Portfólio 3D Gótico

Este é o repositório do projeto para o site interativo 3D "Sung Studios", um portfólio de tatuagem com tema de horror cinematográfico.

## Visão Geral

O projeto é uma experiência narrativa em primeira pessoa que guia o usuário por duas cenas distintas:
1.  **A Descoberta:** Uma estrada escura e uma trilha na floresta que leva a uma porta gótica.
2.  **A Galeria:** Um corredor linear e sombrio onde as 18 artes do portfólio estão em exibição.

A experiência é construída com uma estética de horror sutil, inspirada em *Sleepy Hollow* de Tim Burton, usando estritamente uma paleta de cores preto e branco.

## Stack Técnica

Este projeto foi construído intencionalmente **sem frameworks ou bibliotecas externas**, exceto pelo Three.js, para garantir total controle sobre o desempenho e a experiência.

* **HTML5**
* **CSS3**
* **JavaScript (ES6+)**
* **Three.js** (incluído via CDN)

## Estrutura de Arquivos

A estrutura do projeto está organizada da seguinte forma:

/ │ ├── index.html (Página principal e contêiner da UI) ├── COMO_EDITAR.txt (Instruções de manutenção em PT-BR) ├── checklist.txt (Lista de assets necessários em PT-BR) ├── README.md (Este arquivo) │ ├── css/ │ └── style.css (Estilos para UI, transições e responsividade) │ ├── js/ │ ├── main.js (Loop principal, gerenciamento de estado e inicialização) │ ├── scene.js (Criação de geometria para ambas as cenas) │ ├── controls.js (Manipulador de entrada - teclado, mouse e toque) │ ├── interaction.js (Lógica de Raycasting e interação com objetos) │ ├── loader.js (Gerenciador de carregamento de texturas) │ ├── data/ │ └── artworks.js (Arquivo de dados para as 18 obras de arte) │ ├── assets/ │ ├── images/ │ │ ├── belial.png (Logo principal) │ │ ├── arvore.png (Billboard de árvore para a floresta) │ │ ├── door_texture.jpg (Textura para a Porta Gótica) │ │ ├── path_texture.jpg (Textura para a trilha de terra) │ │ ├── road_texture.jpg (Textura para a estrada) │ │ ├── wall_texture.jpg (Textura da parede do corredor) │ │ ├── floor_texture.jpg(Textura do chão do corredor) │ │ │ │ │ └── img/ │ │ ├── tattoo_01.png │ │ ├── tattoo_02.png │ │ ├── ... (até 18 imagens) │ │ │ └── audio/ │ (Vazio - reservado para áudio futuro)


## Instruções de Edição

Para adicionar ou alterar as artes exibidas no corredor, consulte o arquivo `COMO_EDITAR.txt` para instruções detalhadas.

---
© 2025 Sung
COMO_EDITAR.txt
Plaintext
=================================================
GUIA DE MANUTENÇÃO - SUNG STUDIOS (PT-BR)
=================================================

Este arquivo explica como atualizar o conteúdo do site 3D sem precisar mexer no código principal.

-------------------------------------------------
1. COMO ADICIONAR OU MUDAR AS TATUAGENS (OBRAS DE ARTE)
-------------------------------------------------

Toda a galeria no "Mundo 2" (O Corredor) é gerada automaticamente a partir de um único arquivo.

ARQUIVO PARA EDITAR: /data/artworks.js

PASSO 1: ADICIONE SUAS IMAGENS
1.  Pegue seus 18 arquivos de imagem (de preferência .png ou .jpg).
2.  Renomeie-os para nomes simples (ex: 'tattoo_01.png', 'tattoo_02.png', etc.).
3.  Coloque TODOS os 18 arquivos dentro da pasta: /assets/images/img/

PASSO 2: ATUALIZE O ARQUIVO 'artworks.js'
1.  Abra o arquivo /data/artworks.js em um editor de texto.
2.  Você verá uma lista (array) chamada `ARTWORK_DATA`.
3.  Ela contém 18 blocos de código, um para cada obra de arte.

Exemplo de um bloco:
{
    id: 1,
    image: 'assets/images/img/tattoo_01.png', // <-- MUDE ESTE CAMINHO
    title: 'Nome da Arte 1',                     // <-- MUDE O TÍTULO
    description: 'Descrição da sua arte aqui.'   // <-- MUDE A DESCRIÇÃO
},

4.  Para cada uma das 18 obras, atualize:
    * `image`: Coloque o caminho exato para a imagem que você adicionou no PASSO 1.
    * `title`: O título que aparecerá.
    * `description`: O texto de descrição.

5.  Salve o arquivo. O site será atualizado automaticamente.

-------------------------------------------------
2. COMO MUDAR TEXTURAS DO CENÁRIO (AVANÇADO)
-------------------------------------------------

Se você quiser mudar a aparência do cenário (a estrada, a trilha, as paredes), você pode substituir os arquivos de textura.

PASTA DE TEXTURAS: /assets/images/

* `arvore.png`: A imagem da árvore usada na floresta (formato billboard).
* `door_texture.jpg`: A textura da porta gótica no final da trilha.
* `path_texture.jpg`: A textura do chão da trilha de terra.
* `road_texture.jpg`: A textura do asfalto da estrada.
* `wall_texture.jpg`: A textura das paredes do corredor.
* `floor_texture.jpg`: A textura do chão do corredor.

Basta substituir o arquivo de imagem nesta pasta pelo seu novo arquivo, MANTENDO O MESMO NOME E EXTENSÃO.

-------------------------------------------------
3. COMO MUDAR O LOGO
-------------------------------------------------

PASTA DO LOGO: /assets/images/
ARQUIVO: belial.png

Substitua o arquivo 'belial.png' pelo seu novo logo.
checklist.txt
Plaintext
=================================================
CHECKLIST DE ASSETS DO PROJETO (PT-BR)
=================================================

Verifique se todos os assets (arquivos de mídia) necessários estão nas pastas corretas antes de testar o projeto.

### 1. Imagens de Cenário (Obrigatórias)
Local: /assets/images/

[ ] belial.png             (Logo da marca "Sung" que aparece no canto)
[ ] arvore.png             (Imagem da árvore com fundo transparente para a floresta)
[ ] door_texture.jpg       (Textura de pedra/madeira para a porta gótica)
[ ] path_texture.jpg       (Textura de terra/lama para a trilha)
[ ] road_texture.jpg       (Textura de asfalto para a estrada inicial)
[ ] wall_texture.jpg       (Textura das paredes da galeria/corredor)
[ ] floor_texture.jpg      (Textura do chão da galeria/corredor)

### 2. Imagens da Galeria (Obrigatórias)
Local: /assets/images/img/

[ ] tattoo_01.png
[ ] tattoo_02.png
[ ] tattoo_03.png
[ ] tattoo_04.png
[ ] tattoo_05.png
[ ] tattoo_06.png
[ ] tattoo_07.png
[ ] tattoo_08.png
[ ] tattoo_09.png
[ ] tattoo_10.png
[ ] tattoo_11.png
[ ] tattoo_12.png
[ ] tattoo_13.png
[ ] tattoo_14.png
[ ] tattoo_15.png
[ ] tattoo_16.png
[ ] tattoo_17.png
[ ] tattoo_18.png
(Total de 18 imagens de tatuagem)

### 3. Áudio (Opcional)
Local: /assets/audio/

(Esta pasta está reservada. Você pode adicionar arquivos .mp3 ou .wav aqui para implementação futura de som ambiente.)
index.html
HTML
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sung Studios - 3D Portfolio</title>
    
    <link rel="stylesheet" href="css/style.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-text">Carregando...</div>
    </div>

    <div id="rotate-message">
        <p>Por favor, gire seu dispositivo para a posição horizontal (paisagem) para iniciar a experiência.</p>
    </div>

    <div id="transition-fade"></div>

    <div id="crosshair">+</div>

    <div id="dpad-container">
        <button id="dpad-forward" class="dpad-btn">▲</button>
        <button id="dpad-backward" class="dpad-btn">▼</button>
        <button id="dpad-left" class="dpad-btn">◄</button>
        <button id="dpad-right" class="dpad-btn">►</button>
    </div>

    <button id="action-btn">E</button>

    <div id="logo">
        <img src="assets/images/belial.png" alt="Sung Studios Logo">
    </div>
    <div id="copyright">© 2025 Sung</div>

    <canvas id="game-canvas"></canvas>

    <script src="data/artworks.js"></script>
    <script src="js/loader.js"></script>
    <script src="js/scene.js"></script>
    <script src="js/controls.js"></script>
    <script src="js/interaction.js"></script>
    <script src="js/main.js"></script>

</body>
</html>
css/style.css
CSS
/*
    ARQUIVO: style.css
    DESCRIÇÃO: Folha de Estilos Principal.
    FUNÇÃO: Define todos os estilos visuais da aplicação, incluindo:
    - Reset básico (fundo preto, tela cheia).
    - Tipografia (estilo Cinzel/Inter).
    - Estilos da UI (Mira, Logo, Copyright).
    - Estilos dos Controles Mobile (D-Pad, Botão de Ação).
    - Animação de Transição (Fade branco).
    - Responsividade (Mensagem de Rotação).
*/

/* 1. CONFIGURAÇÃO GLOBAL E FONTES */

/* Importação de fontes (Exemplo: Cinzel e Inter) */
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400&display=swap');

/*
    Reset Global:
    Remove margens, preenchimentos e define o 'box-sizing' para
    facilitar o layout. Define a cor de fundo padrão como preta
    e a cor do texto como branca.
*/
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden; /* Impede barras de rolagem */
    background-color: #000000;
    color: #ffffff;
    
    /* Define a pilha de fontes: Cinzel para títulos, Inter para texto. */
    font-family: 'Inter', sans-serif;
}

/* 2. ELEMENTOS 3D E OVERLAYS */

/*
    Canvas do Jogo:
    O canvas onde o Three.js desenha a cena.
    Deve ocupar a tela inteira, fixo no fundo.
*/
#game-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* Fica atrás de toda a UI */
    cursor: pointer; /* Indica que é clicável (para PointerLock) */
}

/*
    Tela de Carregamento (Loading):
    Overlay que cobre a tela enquanto os assets carregam.
*/
#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000000;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 200; /* Fica acima de tudo */
    transition: opacity 0.5s ease-out;
}

.loading-text {
    font-family: 'Cinzel', serif;
    font-size: 1.5rem;
    color: #ffffff;
}

/*
    Tela de Transição (Flash Branco):
    Usada para o "Theater Effect". Começa transparente.
*/
#transition-fade {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #ffffff;
    opacity: 0;
    pointer-events: none; /* Não pode ser clicado */
    z-index: 150; /* Acima da UI, abaixo do Loading */
    
    /* A transição é controlada via JS (main.js) */
}

/* 3. UI FIXA (MIRA, LOGO, COPYRIGHT) */

/*
    Mira (Crosshair):
    O '+' no centro da tela para interação.
*/
#crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    font-weight: bold;
    color: rgba(255, 255, 255, 0.7); /* Branco semi-transparente */
    pointer-events: none; /* Não pode ser clicado */
    z-index: 100;
    display: none; /* Começa escondido, 'main.js' mostra após carregar */
}

/* Logo "Sung" */
#logo {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 100;
    opacity: 0.8;
    pointer-events: none;
    display: none; /* Começa escondido */
}

#logo img {
    width: 100px; /* Tamanho do logo */
    height: auto;
}

/* Texto de Copyright */
#copyright {
    position: fixed;
    bottom: 10px;
    right: 10px;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.5);
    z-index: 100;
    pointer-events: none;
    display: none; /* Começa escondido */
}


/* 4. CONTROLES MOBILE (D-PAD E BOTÃO DE AÇÃO) */

/*
    Os controles mobile só aparecem em telas de toque.
    O 'controls.js' vai detectar se é mobile e mostrá-los.
*/
#dpad-container,
#action-btn {
    display: none; /* Escondidos por padrão (Desktop) */
    position: fixed;
    z-index: 110;
    user-select: none; /* Impede seleção de texto ao tocar */
    -webkit-user-select: none;
}

/* Contêiner do D-Pad */
#dpad-container {
    bottom: 30px;
    left: 30px;
    width: 150px;
    height: 150px;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr 1fr;
    opacity: 0.5; /* Semi-transparente para não atrapalhar a visão */
}

/* Botões do D-Pad (layout) */
#dpad-forward { grid-area: 1 / 2 / 2 / 3; }
#dpad-left { grid-area: 2 / 1 / 3 / 2; }
#dpad-right { grid-area: 2 / 3 / 3 / 4; }
#dpad-backward { grid-area: 3 / 2 / 4 / 3; }

/* Estilo comum dos botões do D-Pad */
.dpad-btn {
    background-color: rgba(255, 255, 255, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.5);
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
    border-radius: 8px; /* Bordas arredondadas */
}

/* Efeito ao pressionar o botão (feedback tátil) */
.dpad-btn:active {
    background-color: rgba(255, 255, 255, 0.6);
}

/* Botão de Ação [E] */
#action-btn {
    bottom: 40px;
    right: 40px;
    width: 80px;
    height: 80px;
    background-color: rgba(255, 255, 255, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.7);
    color: white;
    font-size: 2rem;
    font-weight: bold;
    font-family: 'Cinzel', serif;
    border-radius: 50%; /* Botão redondo */
    cursor: pointer;
    opacity: 0.6;
}

#action-btn:active {
    background-color: rgba(255, 255, 255, 0.6);
}


/* 5. RESPONSIVIDADE (MENSAGEM DE ROTAÇÃO) */

/*
    Mensagem de Rotação (Modo Retrato em Mobile):
    Por padrão, fica escondida.
*/
#rotate-message {
    display: none; /* Escondido por padrão */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000000;
    color: #ffffff;
    z-index: 250; /* Acima de TUDO */
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 20px;
    font-family: 'Cinzel', serif;
    font-size: 1.2rem;
}

/*
    Media Query para Orientação:
    Se o dispositivo estiver em modo "retrato" (altura > largura),
    mostra a mensagem de rotação e esconde todo o resto da UI.
*/
@media (orientation: portrait) {
    #rotate-message {
        display: flex; /* Mostra a mensagem */
    }

    /* Esconde toda a UI do jogo */
    #crosshair,
    #dpad-container,
    #action-btn,
    #logo,
    #copyright,
    #loading-screen {
        display: none !important;
    }
}
data/artworks.js
JavaScript
/*
    ARQUIVO: artworks.js
    DESCRIÇÃO: Banco de Dados das Obras de Arte.
    FUNÇÃO: Este arquivo contém um "array" (lista) JavaScript que armazena
    as informações de todas as 18 obras de arte que serão exibidas
    na galeria (Corredor / Cena 2).

    COMO EDITAR (VER ARQUIVO 'COMO_EDITAR.txt'):
    - Para cada obra, existe um bloco de código entre chaves {}.
    - 'id': Não mude este número. É o identificador único.
    - 'image': Mude para o caminho exato da sua imagem (ex: 'assets/images/img/minha_foto.png').
    - 'title': O título que aparecerá (ainda não implementado na UI, mas bom para o futuro).
    - 'description': A descrição que aparecerá (ainda não implementado na UI).
*/

// Define a constante ARTWORK_DATA que será usada pelo 'scene.js'
const ARTWORK_DATA = [
    {
        id: 1,
        image: 'assets/images/img/tattoo_01.png',
        title: 'Título da Arte 1',
        description: 'Descrição detalhada da obra de arte número 1.'
    },
    {
        id: 2,
        image: 'assets/images/img/tattoo_02.png',
        title: 'Título da Arte 2',
        description: 'Descrição detalhada da obra de arte número 2.'
    },
    {
        id: 3,
        image: 'assets/images/img/tattoo_03.png',
        title: 'Título da Arte 3',
        description: 'Descrição detalhada da obra de arte número 3.'
    },
    {
        id: 4,
        image: 'assets/images/img/tattoo_04.png',
        title: 'Título da Arte 4',
        description: 'Descrição detalhada da obra de arte número 4.'
    },
    {
        id: 5,
        image: 'assets/images/img/tattoo_05.png',
        title: 'Título da Arte 5',
        description: 'Descrição detalhada da obra de arte número 5.'
    },
    {
        id: 6,
        image: 'assets/images/img/tattoo_06.png',
        title: 'Título da Arte 6',
        description: 'Descrição detalhada da obra de arte número 6.'
    },
    {
        id: 7,
        image: 'assets/images/img/tattoo_07.png',
        title: 'Título da Arte 7',
        description: 'Descrição detalhada da obra de arte número 7.'
    },
    {
        id: 8,
        image: 'assets/images/img/tattoo_08.png',
        title: 'Título da Arte 8',
        description: 'Descrição detalhada da obra de arte número 8.'
    },
    {
        id: 9,
        image: 'assets/images/img/tattoo_09.png',
        title: 'Título da Arte 9',
        description: 'Descrição detalhada da obra de arte número 9.'
    },
    {
        id: 10,
        image: 'assets/images/img/tattoo_10.png',
        title: 'Título da Arte 10',
        description: 'Descrição detalhada da obra de arte número 10.'
    },
    {
        id: 11,
        image: 'assets/images/img/tattoo_11.png',
        title: 'Título da Arte 11',
        description: 'Descrição detalhada da obra de arte número 11.'
    },
    {
        id: 12,
        image: 'assets/images/img/tattoo_12.png',
        title: 'Título da Arte 12',
        description: 'Descrição detalhada da obra de arte número 12.'
    },
    {
        id: 13,
        image: 'assets/images/img/tattoo_13.png',
        title: 'Título da Arte 13',
        description: 'Descrição detalhada da obra de arte número 13.'
    },
    {
        id: 14,
        image: 'assets/images/img/tattoo_14.png',
        title: 'Título da Arte 14',
        description: 'Descrição detalhada da obra de arte número 14.'
    },
    {
        id: 15,
        image: 'assets/images/img/tattoo_15.png',
        title: 'Título da Arte 15',
        description: 'Descrição detalhada da obra de arte número 15.'
    },
    {
        id: 16,
        image: 'assets/images/img/tattoo_16.png',
        title: 'Título da Arte 16',
        description: 'Descrição detalhada da obra de arte número 16.'
    },
    {
        id: 17,
        image: 'assets/images/img/tattoo_17.png',
        title: 'Título da Arte 17',
        description: 'Descrição detalhada da obra de arte número 17.'
    },
    {
        id: 18,
        image: 'assets/images/img/tattoo_18.png',
        title: 'Título da Arte 18',
        description: 'Descrição detalhada da obra de arte número 18.'
    }
];
js/loader.js
JavaScript
/*
    ARQUIVO: loader.js
    DESCRIÇÃO: Gerenciador de Carregamento de Assets.
    FUNÇÃO: Este script é responsável por carregar todas as texturas (imagens)
    necessárias para o projeto ANTES que a experiência comece.
    Ele usa o LoadingManager do Three.js para rastrear o progresso e
    notificar o 'main.js' quando tudo estiver pronto.
*/

class AssetLoader {
    // O construtor recebe as funções que devem ser chamadas
    // durante o carregamento (onProgress) e ao finalizar (onLoad).
    constructor(onProgress, onLoad) {
        // O LoadingManager monitora todos os loaders.
        this.manager = new THREE.LoadingManager();
        
        // Define as funções de callback do manager.
        this.manager.onProgress = (url, itemsLoaded, itemsTotal) => {
            // Calcula a porcentagem
            const progress = (itemsLoaded / itemsTotal) * 100;
            // Chama a função onProgress (definida em main.js)
            onProgress(progress);
            console.log(`Carregando: ${url} (${progress.toFixed(0)}%)`);
        };

        this.manager.onLoad = () => {
            // Chama a função onLoad (definida em main.js)
            onLoad();
            console.log('Todos os assets foram carregados.');
        };

        this.manager.onError = (url) => {
            console.error(`Erro ao carregar o asset: ${url}`);
        };

        // O TextureLoader é o responsável por carregar as imagens.
        // Passamos o manager para ele.
        this.textureLoader = new THREE.TextureLoader(this.manager);
    }

    /**
     * Carrega uma lista de texturas.
     * @param {Array<Object>} texturesToLoad - Um array de objetos { name, path }
     * @returns {Object} - Um objeto onde as chaves são os nomes (name) e os
     * valores são as texturas (THREE.Texture) carregadas.
     */
    loadTextures(texturesToLoad) {
        const textures = {};
        
        texturesToLoad.forEach(tex => {
            // Carrega a textura
            const texture = this.textureLoader.load(tex.path);
            
            // Configurações de repetição (wrapping) e filtro
            // Essencial para texturas de chão e parede.
            if (tex.repeat) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(tex.repeat[0], tex.repeat[1]);
            }

            // Adiciona ao nosso objeto de texturas
            textures[tex.name] = texture;
        });

        // Retorna o objeto com todas as texturas (que ainda estão carregando,
        // mas o manager vai saber quando terminarem).
        return textures;
    }

    /**
     * Carrega uma única textura (usado para as artes da galeria).
     * @param {string} path - O caminho da imagem.
     * @returns {THREE.Texture} - A textura carregada.
     */
    loadSingleTexture(path) {
        // Este loader não usa o manager principal, pois as artes
        // podem ser carregadas "sob demanda" (embora aqui estejamos
        // pré-carregando, é uma boa prática separar).
        // NOTA: Para este projeto, vamos usar o manager principal
        // para carregar TUDO, incluindo as artes, para garantir
        // que a galeria esteja 100% pronta.
        
        // REVISÃO: Vamos usar o loader principal.
        return this.textureLoader.load(path);
    }
}
js/scene.js
JavaScript
/*
    ARQUIVO: scene.js
    DESCRIÇÃO: Construtor de Cenários 3D.
    FUNÇÃO: Esta classe é uma "fábrica" de geometria. Ela não
    mantém estado, apenas contém métodos que criam e retornam
    os mundos (Cena 1 e Cena 2) como grupos de objetos (THREE.Group).
*/

class WorldSceneFactory {

    constructor(textures) {
        // Armazena as texturas que o 'loader.js' carregou.
        this.textures = textures;
        // Altura padrão da câmera (nível dos olhos)
        this.playerHeight = 1.6;
    }

    // -----------------------------------------------------------------
    // CENA 1: A DESCOBERTA (HIGHWAY / FLORESTA)
    // -----------------------------------------------------------------
    createWorld1(scene) {
        const world1Group = new THREE.Group();
        world1Group.name = "World1_Group"; // Nome para depuração

        // 1. Configuração do Clima (Névoa e Luz)
        // Cor cinza-azulado escuro, inspirada em 'clima.png' (Tim Burton)
        const fogColor = 0x2c3e50; 
        scene.background = new THREE.Color(fogColor);
        // A névoa começa perto e fica densa rapidamente
        scene.fog = new THREE.Fog(fogColor, 1, 35); 

        // Luz ambiente fraca, para dar o tom sombrio
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // (cor, intensidade)
        world1Group.add(ambientLight);

        // Luz direcional (simulando lua/crepúsculo)
        const directionalLight = new THREE.DirectionalLight(0x505a70, 0.4);
        directionalLight.position.set(5, 10, 5);
        world1Group.add(directionalLight);


        // 2. Geometria do Chão (Estrada e Trilha)
        // Usamos um material básico (MeshBasicMaterial) porque a luz é
        // muito escura e queremos economizar performance.
        // Se quiséssemos sombras, usaríamos MeshStandardMaterial.
        const roadMaterial = new THREE.MeshBasicMaterial({ map: this.textures.road });
        const roadGeometry = new THREE.PlaneGeometry(15, 80); // (largura, comprimento)
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; // Deita o plano no chão
        road.position.set(0, 0, 80); // Posiciona na área Z > 55
        world1Group.add(road);

        const pathMaterial = new THREE.MeshBasicMaterial({ map: this.textures.path });
        const pathGeometry = new THREE.PlaneGeometry(5, 60); // (largura, comprimento)
        const path = new THREE.Mesh(pathGeometry, pathMaterial);
        path.rotation.x = -Math.PI / 2;
        path.position.set(0, 0.01, 20); // Z < 55 (começa em -10, vai até 50)
        world1Group.add(path);

        // 3. Floresta (Billboards de Árvores)
        // Billboards são sprites 2D que sempre olham para a câmera.
        // Usamos 'arvore.png'
        const treeMaterial = new THREE.SpriteMaterial({ 
            map: this.textures.tree,
            fog: true 
        });

        // Cria 200 árvores
        for (let i = 0; i < 200; i++) {
            const sprite = new THREE.Sprite(treeMaterial);
            // Posição X aleatória (longe da estrada/trilha)
            const x = Math.random() < 0.5 ? Math.random() * 20 + 8 : -Math.random() * 20 - 8;
            // Posição Z aleatória ao longo de todo o mapa
            const z = Math.random() * 110 - 10;
            
            sprite.position.set(x, 2.5, z); // (x, altura, z)
            sprite.scale.set(5, 5, 1); // (largura, altura, profundidade)
            world1Group.add(sprite);
        }

        // 4. A Porta Gótica (Objetivo)
        const doorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.door });
        const doorGeometry = new THREE.PlaneGeometry(4, 4); // Porta de 4x4 metros
        const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
        
        // Posiciona no final da trilha
        // A trilha termina em Z = -10 (20 - 30)
        doorMesh.position.set(0, 2, -10); // (x, altura, z)
        
        // Adiciona um 'userData' para o interaction.js saber que este
        // objeto é interativo.
        doorMesh.userData = { 
            interactive: true, 
            type: 'gothic_door' 
        };
        world1Group.add(doorMesh);

        // 5. Limites de Colisão (Invisíveis)
        // O 'controls.js' usará estes limites.
        // Definimos a área 'andável' (estrada + trilha).
        // Limite da estrada: X = +/- 7.5
        // Limite da trilha: X = +/- 2.5
        const pathLimits = {
            minX: -7.5,
            maxX: 7.5,
            minZ: -10, // Perto da porta
            maxZ: 120, // Fim da estrada
            
            // Definição da área estreita (trilha)
            trailZStart: 50, // Onde a estrada (larga) termina
            trailMinX: -2.5, // Largura da trilha
            trailMaxX: 2.5
        };

        // Retorna o grupo de objetos e os limites de colisão
        return { group: world1Group, collisionLimits: pathLimits };
    }


    // -----------------------------------------------------------------
    // CENA 2: A GALERIA (CORREDOR)
    // -----------------------------------------------------------------
    createWorld2(scene) {
        const world2Group = new THREE.Group();
        world2Group.name = "World2_Group";

        // 1. Limpa a Névoa e Luz da Cena 1
        scene.fog = null; // Remove a névoa
        scene.background = new THREE.Color(0x000000); // Fundo preto

        // Luz ambiente muito escura (soturna)
        const ambientLight = new THREE.AmbientLight(0x101010, 1.0); // (cor, intensidade)
        world2Group.add(ambientLight);

        // Luz "falsa" no teto (HemisphereLight)
        // Simula uma luz fraca vindo de cima, sem sombras (performance)
        const hemiLight = new THREE.HemisphereLight(0x404040, 0x080808, 0.5);
        world2Group.add(hemiLight);

        // 2. Geometria do Corredor
        // Comprimento de 80m (conforme solicitado), Largura 5m, Altura 4m
        const corridorLength = 80;
        const corridorWidth = 5;
        const corridorHeight = 4;

        // Chão
        const floorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.floor });
        const floorGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, 0, corridorLength / 2); // Centraliza no Z
        world2Group.add(floor);

        // Teto
        const ceilMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 }); // Teto escuro
        const ceilGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const ceil = new THREE.Mesh(ceilGeometry, ceilMaterial);
        ceil.rotation.x = Math.PI / 2;
        ceil.position.set(0, corridorHeight, corridorLength / 2);
        world2Group.add(ceil);

        // Parede Esquerda
        const wallMaterial = new THREE.MeshBasicMaterial({ map: this.textures.wall });
        const wallGeometry = new THREE.PlaneGeometry(corridorLength, corridorHeight);
        const wallLeft = new THREE.Mesh(wallGeometry, wallMaterial);
        wallLeft.rotation.y = Math.PI / 2;
        wallLeft.position.set(-corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallLeft);

        // Parede Direita
        const wallRight = new THREE.Mesh(wallGeometry, wallMaterial);
        wallRight.rotation.y = -Math.PI / 2;
        wallRight.position.set(corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallRight);

        // Parede do Fundo (Fechando o corredor)
        const endWallGeom = new THREE.PlaneGeometry(corridorWidth, corridorHeight);
        const endWall = new THREE.Mesh(endWallGeom, wallMaterial);
        endWall.position.set(0, corridorHeight / 2, corridorLength);
        world2Group.add(endWall);

        // 3. Criação das Obras de Arte (Quadros)
        // 18 obras, 9 de cada lado.
        // Espaçamento: 80m / 9 obras = ~8.8m por obra
        const spacing = corridorLength / 9;
        const frameSize = 2.0; // Quadros de 2m x 2m
        const frameHeight = this.playerHeight + 0.2; // Altura dos olhos

        ARTWORK_DATA.forEach((artwork, index) => {
            // Carrega a textura da arte (já pré-carregada pelo loader)
            const artTexture = this.textures[`art_${artwork.id}`];
            const artMaterial = new THREE.MeshBasicMaterial({ map: artTexture });

            const artGeometry = new THREE.PlaneGeometry(frameSize, frameSize);
            const artMesh = new THREE.Mesh(artGeometry, artMaterial);
            
            // Cria a "placa" de interação (hitbox)
            // É um plano invisível e maior (3x3) para facilitar a interação (forgiving hitbox)
            const plaqueGeometry = new THREE.PlaneGeometry(frameSize + 1, frameSize + 1);
            const plaqueMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const plaqueMesh = new THREE.Mesh(plaqueGeometry, plaqueMaterial);
            
            // Adiciona os dados de interação na PLACA (não na arte)
            plaqueMesh.userData = {
                interactive: true,
                type: 'artwork',
                id: artwork.id,
                title: artwork.title,
                description: artwork.description
            };

            // Posição Z (ao longo do corredor)
            // Começa em Z=10, espaçamento de 8.8m
            const zPos = 10 + (index % 9) * (spacing * 0.9);

            if (index < 9) {
                // Lado Esquerdo (primeiras 9)
                artMesh.position.set((-corridorWidth / 2) + 0.05, frameHeight, zPos);
                artMesh.rotation.y = Math.PI / 2; // Virado para o centro
                
                plaqueMesh.position.set((-corridorWidth / 2) + 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = Math.PI / 2;

            } else {
                // Lado Direito (últimas 9)
                artMesh.position.set((corridorWidth / 2) - 0.05, frameHeight, zPos);
                artMesh.rotation.y = -Math.PI / 2; // Virado para o centro
                
                plaqueMesh.position.set((corridorWidth / 2) - 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = -Math.PI / 2;
            }

            world2Group.add(artMesh);
            world2Group.add(plaqueMesh); // Adiciona a hitbox invisível
        });

        // 4. Limites de Colisão (Corredor)
        // O jogador não pode atravessar as paredes
        const collisionLimits = {
            minX: -corridorWidth / 2 + 0.5, // 0.5m de folga da parede
            maxX: corridorWidth / 2 - 0.5,
            minZ: 0.5, // Parede inicial (não existe, mas impede de voltar)
            maxZ: corridorLength - 0.5 // Parede do fundo
        };
        
        // Retorna o grupo e os limites
        return { group: world2Group, collisionLimits: collisionLimits };
    }
}
js/controls.js
JavaScript
/*
    ARQUIVO: controls.js
    DESCRIÇÃO: Gerenciador de Controles do Jogador (Input Handler).
    FUNÇÃO: Esta classe gerencia TODO o input do usuário:
    - Movimentação (WASD / Setas / D-Pad Mobile).
    - Rotação da Câmera (Mouse / Toque Mobile).
    - Ações (Tecla [E] / Botão de Ação Mobile).
    - Lógica de Colisão (limitando a posição do jogador).
*/

class PlayerControls {

    /**
     * @param {THREE.Camera} camera - A câmera do jogador.
     * @param {HTMLElement} domElement - O elemento canvas (para eventos).
     * @param {Object} settings - Configurações de velocidade e sensibilidade.
     */
    constructor(camera, domElement, settings) {
        this.camera = camera;
        this.domElement = domElement;
        this.settings = settings;

        // Referência à função de interação (definida em main.js)
        this.onInteract = () => {}; 
        
        // Estado de movimento
        this.moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        // Estado da Câmera (Mouse Look)
        this.cameraLook = {
            pitch: 0, // Rotação vertical (X)
            yaw: 0   // Rotação horizontal (Y)
        };
        
        // Propriedades de física/movimento
        this.velocity = new THREE.Vector3();
        this.direction = new THREE.Vector3();

        // Configurações do mundo atual (Cena 1 ou Cena 2)
        this.currentWorld = 1;
        this.collisionLimits = null; // Limites de colisão do mundo atual
        
        // Detecção de Mobile (baseado em 'touchstart')
        this.isMobile = 'ontouchstart' in window;
        
        // Armazena o ID do toque de movimento (para multi-toque)
        this.moveTouchId = null; 
        this.lookTouchId = null;
        this.lastLookPos = { x: 0, y: 0 };
        
        // Ajusta a sensibilidade para mobile (conforme UX finalizado)
        this.sensitivity = this.isMobile ? 
            this.settings.mobileCameraSpeed : 
            this.settings.desktopCameraSpeed;

        // Inicializa os ouvintes de eventos
        this.initListeners();
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO DOS OUVINTES DE EVENTO
    // -----------------------------------------------------------------
    initListeners() {
        if (this.isMobile) {
            // Se for mobile, inicializa os controles de toque
            this.initMobileControls();
        } else {
            // Se for desktop, inicializa o Pointer Lock (travar mouse)
            this.initPointerLock();
            // E os ouvintes de teclado
            document.addEventListener('keydown', this.onKeyDown.bind(this));
            document.addEventListener('keyup', this.onKeyUp.bind(this));
        }
    }

    // (Desktop) Configura o Pointer Lock
    initPointerLock() {
        this.domElement.addEventListener('click', () => {
            this.domElement.requestPointerLock();
        });

        // Ouve o movimento do mouse APENAS quando o mouse está travado
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === this.domElement) {
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
            } else {
                document.removeEventListener('mousemove', this.onMouseMove.bind(this));
            }
        });
    }

    // (Mobile) Configura os botões de toque
    initMobileControls() {
        // Mostra os botões de D-Pad e Ação
        document.getElementById('dpad-container').style.display = 'grid';
        document.getElementById('action-btn').style.display = 'block';

        // Ouvintes do D-Pad (touchstart = pressionar, touchend = soltar)
        this.addTouchListener('dpad-forward', 'forward');
        this.addTouchListener('dpad-backward', 'backward');
        this.addTouchListener('dpad-left', 'left');
        this.addTouchListener('dpad-right', 'right');

        // Ouvinte do Botão de Ação
        document.getElementById('action-btn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.onInteract(); // Chama a função de interação
        });
        
        // Ouvinte de Toque na Tela (para olhar ao redor)
        this.domElement.addEventListener('touchstart', this.onMobileTouchStart.bind(this));
        this.domElement.addEventListener('touchmove', this.onMobileTouchMove.bind(this));
        this.domElement.addEventListener('touchend', this.onMobileTouchEnd.bind(this));
    }

    // (Mobile) Função auxiliar para adicionar ouvintes de toque
    addTouchListener(elementId, direction) {
        const element = document.getElementById(elementId);
        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.moveState[direction] = true;
        });
        element.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.moveState[direction] = false;
        });
    }

    // -----------------------------------------------------------------
    // HANDLERS DE EVENTO (MOVIMENTO / AÇÃO)
    // -----------------------------------------------------------------

    // (Desktop) Tecla pressionada
    onKeyDown(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = true; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = true; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = true; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = true; break;
            case 'KeyE': this.onInteract(); break; // Tecla de Interação [E]
        }
    }

    // (Desktop) Tecla solta
    onKeyUp(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = false; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = false; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = false; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = false; break;
        }
    }

    // (Desktop) Movimento do mouse (Pointer Lock)
    onMouseMove(event) {
        if (document.pointerLockElement !== this.domElement) return;

        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;

        // Rotação Horizontal (Yaw) - Eixo Y
        this.cameraLook.yaw -= movementX * this.sensitivity;
        
        // Rotação Vertical (Pitch) - Eixo X
        this.cameraLook.pitch -= movementY * this.sensitivity;
        
        // Trava a rotação vertical (para não "quebrar o pescoço")
        this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
        
        // Aplica as rotações (Ordem EULER_YXZ é importante para FPS)
        this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
    }

    // (Mobile) Início do toque na tela
    onMobileTouchStart(event) {
        event.preventDefault();
        // Itera sobre os toques
        for (const touch of event.changedTouches) {
            // Se o toque for na metade direita da tela, é para "olhar"
            if (touch.clientX > window.innerWidth / 2 && this.lookTouchId === null) {
                this.lookTouchId = touch.identifier;
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;
            }
        }
    }

    // (Mobile) Movimento do toque na tela (Olhar)
    onMobileTouchMove(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se for o toque que estamos rastreando para "olhar"
            if (touch.identifier === this.lookTouchId) {
                const deltaX = touch.clientX - this.lastLookPos.x;
                const deltaY = touch.clientY - this.lastLookPos.y;

                // Salva a nova posição
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;

                // Aplica a rotação (similar ao onMouseMove)
                this.cameraLook.yaw -= deltaX * this.sensitivity;
                this.cameraLook.pitch -= deltaY * this.sensitivity;
                this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
                
                this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
            }
        }
    }

    // (Mobile) Fim do toque na tela
    onMobileTouchEnd(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se o toque que terminou era o de "olhar", para de rastrear
            if (touch.identifier === this.lookTouchId) {
                this.lookTouchId = null;
            }
        }
    }


    // -----------------------------------------------------------------
    // ATUALIZAÇÃO (LOOP PRINCIPAL) E COLISÃO
    // -----------------------------------------------------------------

    /**
     * Define os limites de colisão do mundo atual.
     * @param {number} worldId - 1 para Floresta, 2 para Corredor.
     * @param {Object} limits - O objeto de limites vindo de 'scene.js'.
     */
    setWorld(worldId, limits) {
        this.currentWorld = worldId;
        this.collisionLimits = limits;
    }
    
    /**
     * Reseta a rotação da câmera (usado na transição).
     */
    resetRotation() {
        this.cameraLook.pitch = 0;
        this.cameraLook.yaw = 0;
        this.camera.rotation.set(0, 0, 0, 'YXZ');
    }

    /**
     * Chamado a cada frame pelo 'main.js'.
     * @param {number} delta - O tempo (em segundos) desde o último frame.
     */
    update(delta) {
        // Velocidade = 1.8 m/s (conforme UX finalizado)
        const moveSpeed = this.settings.movementSpeed * delta;

        // Reseta a direção do movimento
        this.direction.z = Number(this.moveState.forward) - Number(this.moveState.backward);
        this.direction.x = Number(this.moveState.left) - Number(this.moveState.right);
        this.direction.normalize(); // Garante movimento consistente (diagonal != mais rápido)

        // Salva a posição atual para checagem de colisão
        const oldPosition = this.camera.position.clone();

        // Calcula o movimento relativo à direção que a câmera está olhando
        if (this.moveState.forward || this.moveState.backward) {
            this.camera.translateZ(-this.direction.z * moveSpeed);
        }
        if (this.moveState.left || this.moveState.right) {
            this.camera.translateX(-this.direction.x * moveSpeed);
        }

        // --- LÓGICA DE COLISÃO ---
        // Impede o jogador de sair dos limites definidos
        if (this.collisionLimits) {
            this.applyCollisions(oldPosition);
        }
        
        // Mantém a altura do jogador (impede de voar ou afundar)
        this.camera.position.y = this.settings.playerHeight;
    }

    /**
     * Verifica e aplica as colisões baseadas nos limites do mundo.
     * @param {THREE.Vector3} oldPosition - Posição antes do movimento.
     */
    applyCollisions(oldPosition) {
        const newPosition = this.camera.position;
        const limits = this.collisionLimits;

        // Lógica de Colisão para o MUNDO 1 (Floresta)
        if (this.currentWorld === 1) {
            // A lógica aqui é complexa: a estrada é larga, a trilha é estreita.
            
            // Se estiver na área da estrada (Z > 50)
            if (newPosition.z > limits.trailZStart) {
                newPosition.x = Math.max(limits.minX, Math.min(limits.maxX, newPosition.x));
            } 
            // Se estiver na área da trilha (Z <= 50)
            else {
                newPosition.x = Math.max(limits.trailMinX, Math.min(limits.trailMaxX, newPosition.x));
            }
            
            // Limites gerais Z (frente/trás)
            newPosition.z = Math.max(limits.minZ, Math.min(limits.maxZ, newPosition.z));
        
        // Lógica de Colisão para o MUNDO 2 (Corredor)
        } else if (this.currentWorld === 2) {
            // Lógica simples de "caixa"
            newPosition.x = Math.max(limits.minX, Math.min(limits.maxX, newPosition.x));
            newPosition.z = Math.max(limits.minZ, Math.min(limits.maxZ, newPosition.z));
        }

        // Aplica a posição corrigida
        this.camera.position.copy(newPosition);
    }
}
js/interaction.js
JavaScript
/*
    ARQUIVO: interaction.js
    DESCRIÇÃO: Gerenciador de Interação (Raycaster).
    FUNÇÃO: Esta classe é responsável por "atirar um raio" (Raycast)
    a partir do centro da tela (mira) para detectar com o que
    o jogador está olhando/interagindo.
*/

class InteractionHandler {

    /**
     * @param {THREE.Camera} camera - A câmera do jogador (de onde o raio sai).
     * @param {THREE.Scene} scene - A cena (onde os objetos estão).
     * @param {Function} onInteractCallback - Função em 'main.js' a ser chamada
     * quando uma interação válida ocorre.
     */
    constructor(camera, scene, onInteractCallback) {
        this.camera = camera;
        this.scene = scene;
        this.onInteractCallback = onInteractCallback;

        // O Raycaster do Three.js
        this.raycaster = new THREE.Raycaster();
        
        // Coordenadas da mira (sempre [0, 0] = centro da tela)
        this.crosshairCoords = new THREE.Vector2(0, 0);

        // Distância máxima de interação (ex: 3 metros)
        this.interactionDistance = 3.0; 

        // Armazena o objeto que está atualmente na mira
        this.currentTarget = null;
    }

    /**
     * Chamado quando o jogador pressiona [E] ou o Botão de Ação.
     * Esta é a função que efetivamente "dispara" a interação.
     */
    triggerInteraction() {
        // Verifica se há um alvo válido na mira
        if (this.currentTarget) {
            // Chama a função de callback em 'main.js'
            // e passa os dados do objeto (ex: { type: 'gothic_door' })
            this.onInteractCallback(this.currentTarget.userData);
        } else {
            // (Opcional) Tocar um som de "falha" se não houver nada
            console.log("Nenhum alvo interativo ao alcance.");
        }
    }

    /**
     * Chamado a cada frame pelo 'main.js' (ANTES do update de controles).
     * Esta função *apenas* verifica o que está na mira, mas não
     * dispara a ação.
     */
    update() {
        // 1. Atualiza o raio para sair do centro da câmera
        this.raycaster.setFromCamera(this.crosshairCoords, this.camera);

        // 2. Verifica quais objetos na cena (recursivamente) o raio atinge
        // Passamos 'this.scene.children' e 'true' para verificar os filhos
        // dos grupos (World1_Group, World2_Group).
        const intersects = this.raycaster.intersectObjects(this.scene.children, true);

        // Reseta o alvo atual
        this.currentTarget = null;

        // 3. Itera sobre os objetos atingidos
        for (const intersect of intersects) {
            
            // 4. Verifica se o objeto tem o 'userData' interativo
            // (Nós definimos isso em 'scene.js' na porta e nas placas)
            if (intersect.object.userData && intersect.object.userData.interactive === true) {
                
                // 5. Verifica se está dentro da distância permitida
                if (intersect.distance <= this.interactionDistance) {
                    
                    // Encontramos um alvo válido!
                    this.currentTarget = intersect.object;
                    
                    // (Opcional) Mudar a cor da mira para "ativa"
                    // document.getElementById('crosshair').style.color = 'red';
                    
                    // Para o loop assim que encontrar o primeiro alvo válido
                    break;
                }
            }
        }
        
        // Se o loop terminou e this.currentTarget ainda é nulo,
        // significa que não estamos olhando para nada interativo.
        if (this.currentTarget === null) {
            // (Opcional) Resetar a cor da mira para "passiva"
            // document.getElementById('crosshair').style.color = 'rgba(255, 255, 255, 0.7)';
        }
    }
}
js/main.js
JavaScript
/*
    ARQUIVO: main.js
    DESCRIÇÃO: Ponto de Entrada Principal da Aplicação (O "Maestro").
    FUNÇÃO: Este script inicializa todos os componentes (Cena, Câmera,
    Renderizador, Controles) e gerencia o "Game Loop" (o 'animate').
    Ele coordena o carregamento de assets, a transição de cenas
    e conecta os controles à lógica de interação.
*/

// Classe principal da aplicação
class SungApp {
    
    constructor() {
        // Elementos do DOM
        this.canvas = document.getElementById('game-canvas');
        this.loadingScreen = document.getElementById('loading-screen');
        this.loadingText = document.querySelector('.loading-text');
        this.transitionFade = document.getElementById('transition-fade');
        this.uiElements = [
            document.getElementById('crosshair'),
            document.getElementById('logo'),
            document.getElementById('copyright')
        ];

        // Componentes do Three.js
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true // Suavização de serrilhado
        });
        this.clock = new THREE.Clock(); // Relógio para o 'delta time'

        // Componentes do Jogo
        this.loader = null;
        this.controls = null;
        this.interaction = null;
        this.worldFactory = null;
        
        // Grupos de Cena (para fácil adição/remoção)
        this.world1_Group = null;
        this.world2_Group = null;

        // Estado do Jogo
        this.isLoaded = false;
        this.isTransitioning = false;
        this.currentWorldId = 1; // Começa no Mundo 1
        
        // Configurações (conforme UX finalizado)
        this.settings = {
            movementSpeed: 1.8,         // 1.8 m/s
            desktopCameraSpeed: 0.0008, // Sensibilidade Desktop
            mobileCameraSpeed: 0.0025,  // Sensibilidade Mobile
            playerHeight: 1.6           // Altura dos olhos do jogador
        };
        
        // Referência 'bind' para o loop de animação
        this.animate = this.animate.bind(this);
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Método principal de inicialização.
     */
    init() {
        console.log("Iniciando SungApp...");

        // 1. Configurar o Renderizador
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limita o pixel ratio por performance
        this.renderer.outputEncoding = THREE.sRGBEncoding;

        // 2. Configurar a Posição Inicial da Câmera
        // (Z > 55, conforme requisito da Cena 1)
        this.camera.position.set(0, this.settings.playerHeight, 60);

        // 3. Inicializar o Loader de Assets
        this.loader = new AssetLoader(
            (progress) => {
                // Função 'onProgress'
                this.loadingText.textContent = `Carregando... ${progress.toFixed(0)}%`;
            },
            () => {
                // Função 'onLoad' (Tudo carregado)
                this.startExperience();
            }
        );

        // 4. Definir quais texturas carregar
        // (Nomes vêm do 'checklist.txt' e 'scene.js')
        const sceneTextures = [
            { name: 'road', path: 'assets/images/road_texture.jpg', repeat: [3, 15] },
            { name: 'path', path: 'assets/images/path_texture.jpg', repeat: [1, 10] },
            { name: 'door', path: 'assets/images/door_texture.jpg' },
            { name: 'tree', path: 'assets/images/arvore.png' },
            { name: 'wall', path: 'assets/images/wall_texture.jpg', repeat: [20, 2] },
            { name: 'floor', path: 'assets/images/floor_texture.jpg', repeat: [2, 20] }
        ];
        
        // Adiciona as 18 artes da galeria à lista de carregamento
        const artworkTextures = ARTWORK_DATA.map(art => ({
            name: `art_${art.id}`, // ex: 'art_1'
            path: art.image
        }));
        
        // Carrega TUDO
        const allTexturesToLoad = [...sceneTextures, ...artworkTextures];
        const loadedTextures = this.loader.loadTextures(allTexturesToLoad);
        
        // 5. Inicializar a "Fábrica" de Mundos com as texturas
        this.worldFactory = new WorldSceneFactory(loadedTextures);

        // 6. Ouvinte de redimensionamento da janela
        window.addEventListener('resize', this.onWindowResize.bind(this));
    }

    /**
     * Chamado quando o Loader termina (onLoad).
     */
    startExperience() {
        console.log("Assets carregados. Iniciando a experiência.");
        this.isLoaded = true;
        
        // 1. Construir o Mundo 1 (Floresta)
        const world1Data = this.worldFactory.createWorld1(this.scene);
        this.world1_Group = world1Data.group;
        this.scene.add(this.world1_Group);

        // 2. Inicializar Controles
        this.controls = new PlayerControls(this.camera, this.canvas, this.settings);
        // Define os limites de colisão para o mundo 1
        this.controls.setWorld(1, world1Data.collisionLimits);
        
        // 3. Inicializar Interação
        this.interaction = new InteractionHandler(
            this.camera, 
            this.scene, 
            this.handleInteraction.bind(this) // Callback
        );
        
        // 4. Conectar Controles e Interação
        // Diz ao 'controls' qual função chamar quando [E] é pressionado
        this.controls.onInteract = () => {
            this.interaction.triggerInteraction();
        };

        // 5. Esconder a tela de Loading e mostrar a UI do Jogo
        this.loadingScreen.style.opacity = '0';
        setTimeout(() => {
            this.loadingScreen.style.display = 'none';
        }, 500); // 0.5s (duração da transição do CSS)

        // Mostra a UI (Mira, Logo, etc.)
        this.uiElements.forEach(el => el.style.display = 'block');
        
        // 6. Iniciar o Loop de Animação
        this.animate();
    }
    
    // -----------------------------------------------------------------
    // LOOP DE ANIMAÇÃO (GAME LOOP)
    // -----------------------------------------------------------------

    /**
     * O Loop Principal (requestAnimationFrame).
     */
    animate() {
        // Pede ao navegador para chamar 'animate' no próximo frame
        requestAnimationFrame(this.animate);

        // Se não carregou ou está em transição, não faz nada
        if (!this.isLoaded || this.isTransitioning) {
            return;
        }

        // Pega o tempo delta (diferença do último frame)
        const delta = this.clock.getDelta();

        // 1. Atualiza o handler de interação (verifica o que está na mira)
        this.interaction.update();
        
        // 2. Atualiza os controles do jogador (movimento, colisão)
        this.controls.update(delta);

        // 3. Renderiza a cena 3D
        this.renderer.render(this.scene, this.camera);
    }
    
    // -----------------------------------------------------------------
    // LÓGICA DE TRANSIÇÃO E INTERAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Callback chamado pelo 'InteractionHandler' quando [E] é pressionado
     * em um alvo válido.
     * @param {Object} userData - Os dados do objeto (ex: { type: 'gothic_door' })
     */
    handleInteraction(userData) {
        console.log("Interação disparada:", userData);
        
        // Verifica se é a porta gótica E se estamos no mundo 1
        if (userData.type === 'gothic_door' && this.currentWorldId === 1) {
            this.triggerSceneTransition();
        }
        
        // (Futuro) Lógica para mostrar info da arte no Mundo 2
        if (userData.type === 'artwork' && this.currentWorldId === 2) {
            console.log(`Clicou na Arte: ${userData.title}`);
            // Aqui você poderia abrir um pop-up/modal com
            // userData.title e userData.description
        }
    }

    /**
     * Executa o "Theater Effect" (Transição da Cena 1 para a Cena 2).
     */
    triggerSceneTransition() {
        console.log("Iniciando transição de cena...");
        this.isTransitioning = true; // Pausa o 'animate' loop

        // 1. Fade In Rápido (0.5s) para Branco
        this.transitionFade.style.transition = 'opacity 0.5s ease-in';
        this.transitionFade.style.opacity = '1';

        // 2. Atraso de 500ms (enquanto a tela está branca)
        setTimeout(() => {
            // --- O TELEPORTE (acontece instantaneamente) ---
            
            // a. Remove a geometria do Mundo 1
            this.scene.remove(this.world1_Group);
            
            // b. Constrói e adiciona a geometria do Mundo 2
            const world2Data = this.worldFactory.createWorld2(this.scene);
            this.world2_Group = world2Data.group;
            this.scene.add(this.world2_Group);

            // c. Teleporta o Jogador (Z=10, conforme requisito)
            this.camera.position.set(0, this.settings.playerHeight, 10);
            
            // d. Reseta a Rotação da Câmera (olhar reto)
            this.controls.resetRotation();

            // e. Atualiza os controles para os limites de colisão do Mundo 2
            this.controls.setWorld(2, world2Data.collisionLimits);
            this.currentWorldId = 2;
            
            // --- FIM DO TELEPORTE ---

            // 3. Fade Out Lento (1.5s) do Branco (olhos se ajustando)
            this.transitionFade.style.transition = 'opacity 1.5s ease-out';
            this.transitionFade.style.opacity = '0';
            
            // 4. Atraso de 1500ms (espera o fade out terminar)
            setTimeout(() => {
                this.isTransitioning = false; // Retoma o 'animate' loop
                console.log("Transição completa. Mundo 2 carregado.");
            }, 1500);

        }, 500); // Fim do setTimeout do Fade In
    }

    // -----------------------------------------------------------------
    // UTILITÁRIOS
    // -----------------------------------------------------------------

    /**
     * Chamado quando a janela do navegador muda de tamanho.
     */
    onWindowResize() {
        // Atualiza as proporções da câmera
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();

        // Atualiza o tamanho do renderizador
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}

// -----------------------------------------------------------------
// PONTO DE ENTRADA
// -----------------------------------------------------------------

// Quando o DOM (HTML) estiver pronto, cria e inicializa a aplicação.
window.addEventListener('DOMContentLoaded', () => {
    const app = new SungApp();
    app.init();
});
ta vamos por partes

vamos programar

a rodovia (algo como o anexo rodovia ) [um dos lados tem q ser uma parede meio q espelhando a outro lado ]

a floresta com arvores grandes e medias com alguns cristais luminos em forma de losangos em algumas arvores na parte da trilha pra porta

e a porta (anexo porta )

Ótimas referências! Vamos integrar esses elementos ao projeto.

Considerando os anexos Image 1 e Image 2 para a rodovia e a porta, e os novos requisitos de paredes espelhadas na rodovia, árvores grandes e médias, e cristais luminosos na floresta, farei as seguintes modificações nos arquivos js/scene.js e js/main.js.

As paredes espelhadas na rodovia serão implementadas ajustando a lógica de colisão e visual da floresta. Os cristais luminosos serão adicionados como PointLights no scene.js junto às árvores na trilha.

Modificações Necessárias:

js/scene.js:

createWorld1:

Ajustar a criação das árvores para incluir tamanhos variados e a possibilidade de ter cristais luminosos.

Posicionar o grupo de árvores de forma a criar uma "parede" visual em ambos os lados da rodovia e trilha, simulando o efeito espelhado e a densidade da floresta.

Adicionar PointLights para os cristais.

Melhorar a colisão para refletir a nova configuração da floresta.

Ajustar os materiais para usar as texturas das imagens fornecidas.

js/main.js:

init:

Adicionar as novas texturas (se houver) para os cristais (embora PointLight não precise de textura, pode-se usar um Sprite).

Aqui estão as versões atualizadas dos arquivos js/scene.js e js/main.js:

js/scene.js (ATUALIZADO)
JavaScript
/*
    ARQUIVO: scene.js
    DESCRIÇÃO: Construtor de Cenários 3D.
    FUNÇÃO: Esta classe é uma "fábrica" de geometria. Ela não
    mantém estado, apenas contém métodos que criam e retornam
    os mundos (Cena 1 e Cena 2) como grupos de objetos (THREE.Group).
*/

class WorldSceneFactory {

    constructor(textures) {
        // Armazena as texturas que o 'loader.js' carregou.
        this.textures = textures;
        // Altura padrão da câmera (nível dos olhos)
        this.playerHeight = 1.6;
    }

    // -----------------------------------------------------------------
    // CENA 1: A DESCOBERTA (HIGHWAY / FLORESTA)
    // -----------------------------------------------------------------
    createWorld1(scene) {
        const world1Group = new THREE.Group();
        world1Group.name = "World1_Group"; // Nome para depuração

        // 1. Configuração do Clima (Névoa e Luz)
        // Cor cinza-azulado escuro, inspirada em 'clima.png' (Tim Burton)
        const fogColor = 0x2c3e50; 
        scene.background = new THREE.Color(fogColor);
        // A névoa começa perto e fica densa rapidamente
        scene.fog = new THREE.Fog(fogColor, 1, 35); 

        // Luz ambiente fraca, para dar o tom sombrio
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // (cor, intensidade)
        world1Group.add(ambientLight);

        // Luz direcional (simulando lua/crepúsculo)
        const directionalLight = new THREE.DirectionalLight(0x505a70, 0.4);
        directionalLight.position.set(5, 10, 5);
        world1Group.add(directionalLight);


        // 2. Geometria do Chão (Estrada e Trilha)
        const roadMaterial = new THREE.MeshBasicMaterial({ map: this.textures.road });
        const roadGeometry = new THREE.PlaneGeometry(15, 80); // (largura, comprimento)
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; // Deita o plano no chão
        road.position.set(0, 0, 80); // Posiciona na área Z > 55
        world1Group.add(road);

        const pathMaterial = new THREE.MeshBasicMaterial({ map: this.textures.path });
        const pathGeometry = new THREE.PlaneGeometry(5, 60); // (largura, comprimento)
        const path = new THREE.Mesh(pathGeometry, pathMaterial);
        path.rotation.x = -Math.PI / 2;
        path.position.set(0, 0.01, 20); // Z < 55 (começa em -10, vai até 50)
        world1Group.add(path);

        // 3. Floresta (Billboards de Árvores) - AGORA COM VARIEDADE E PAREDES ESPELHADAS
        const treeMaterial = new THREE.SpriteMaterial({ 
            map: this.textures.tree,
            fog: true,
            color: 0x999999 // Tom mais cinza para o tema gótico
        });

        // Loop para criar árvores em ambos os lados
        for (let i = 0; i < 250; i++) { // Mais árvores para densidade
            const sprite = new THREE.Sprite(treeMaterial);
            
            // Posição X aleatória, com alguns grupos mais perto para "paredes"
            let x;
            if (Math.random() < 0.5) { // Lado esquerdo
                x = -Math.random() * 20 - 7.5; // Mais próximo da estrada
                if (Math.random() < 0.3) x = -Math.random() * 5 - 7.5; // Mais perto ainda para "parede"
            } else { // Lado direito
                x = Math.random() * 20 + 7.5;
                if (Math.random() < 0.3) x = Math.random() * 5 + 7.5;
            }

            const z = Math.random() * 110 - 10; // Posição Z ao longo de todo o mapa

            // Tamanho aleatório para árvores grandes e médias
            const scaleFactor = Math.random() * 2 + 3; // Escala entre 3 e 5
            sprite.scale.set(scaleFactor, scaleFactor, 1);
            
            sprite.position.set(x, scaleFactor / 2, z); // Altura baseada na escala
            world1Group.add(sprite);

            // Adiciona cristais luminosos em algumas árvores na trilha
            // A trilha vai de Z=50 (approx) até Z=-10
            if (z < 50 && z > -10 && Math.random() < 0.05) { // 5% de chance na área da trilha
                const crystalLight = new THREE.PointLight(0xadd8e6, 1, 10); // Azul claro, intensidade 1, distância 10
                crystalLight.position.set(sprite.position.x + (Math.random() - 0.5) * 2, sprite.position.y + Math.random() * 2, sprite.position.z);
                world1Group.add(crystalLight);

                // Opcional: Um pequeno sprite para visualizar o cristal
                const crystalSpriteMaterial = new THREE.SpriteMaterial({ color: 0xadd8e6, map: this.textures.crystalGlow }); // Adicionar textura de brilho de cristal se necessário
                const crystalSprite = new THREE.Sprite(crystalSpriteMaterial);
                crystalSprite.scale.set(0.5, 0.5, 1);
                crystalSprite.position.copy(crystalLight.position);
                world1Group.add(crystalSprite);
            }
        }

        // 4. A Porta Gótica (Objetivo)
        const doorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.door });
        const doorGeometry = new THREE.PlaneGeometry(5, 5.5); // Porta ligeiramente maior para o estilo
        const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
        
        doorMesh.position.set(0, doorGeometry.parameters.height / 2, -9); // Posição final da trilha
        
        doorMesh.userData = { 
            interactive: true, 
            type: 'gothic_door' 
        };
        world1Group.add(doorMesh);

        // 5. Limites de Colisão (Invisíveis)
        // Aumentamos a área de X para englobar a largura da floresta para colisão
        const pathLimits = {
            minX: -7.5, // Largura da estrada + um pouco da floresta "colisível"
            maxX: 7.5,
            minZ: -10, // Perto da porta
            maxZ: 120, // Fim da estrada
            
            trailZStart: 50, // Onde a estrada (larga) termina
            trailMinX: -2.5, // Largura da trilha
            trailMaxX: 2.5
        };

        return { group: world1Group, collisionLimits: pathLimits };
    }


    // -----------------------------------------------------------------
    // CENA 2: A GALERIA (CORREDOR)
    // -----------------------------------------------------------------
    createWorld2(scene) {
        const world2Group = new THREE.Group();
        world2Group.name = "World2_Group";

        // 1. Limpa a Névoa e Luz da Cena 1
        scene.fog = null; // Remove a névoa
        scene.background = new THREE.Color(0x000000); // Fundo preto

        // Luz ambiente muito escura (soturna)
        const ambientLight = new THREE.AmbientLight(0x101010, 1.0); // (cor, intensidade)
        world2Group.add(ambientLight);

        // Luz "falsa" no teto (HemisphereLight)
        // Simula uma luz fraca vindo de cima, sem sombras (performance)
        const hemiLight = new THREE.HemisphereLight(0x404040, 0x080808, 0.5);
        world2Group.add(hemiLight);

        // 2. Geometria do Corredor
        // Comprimento de 80m (conforme solicitado), Largura 5m, Altura 4m
        const corridorLength = 80;
        const corridorWidth = 5;
        const corridorHeight = 4;

        // Chão
        const floorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.floor });
        const floorGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, 0, corridorLength / 2); // Centraliza no Z
        world2Group.add(floor);

        // Teto
        const ceilMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 }); // Teto escuro
        const ceilGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const ceil = new THREE.Mesh(ceilGeometry, ceilMaterial);
        ceil.rotation.x = Math.PI / 2;
        ceil.position.set(0, corridorHeight, corridorLength / 2);
        world2Group.add(ceil);

        // Parede Esquerda
        const wallMaterial = new THREE.MeshBasicMaterial({ map: this.textures.wall });
        const wallGeometry = new THREE.PlaneGeometry(corridorLength, corridorHeight);
        const wallLeft = new THREE.Mesh(wallGeometry, wallMaterial);
        wallLeft.rotation.y = Math.PI / 2;
        wallLeft.position.set(-corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallLeft);

        // Parede Direita
        const wallRight = new THREE.Mesh(wallGeometry, wallMaterial);
        wallRight.rotation.y = -Math.PI / 2;
        wallRight.position.set(corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallRight);

        // Parede do Fundo (Fechando o corredor)
        const endWallGeom = new THREE.PlaneGeometry(corridorWidth, corridorHeight);
        const endWall = new THREE.Mesh(endWallGeom, wallMaterial);
        endWall.position.set(0, corridorHeight / 2, corridorLength);
        world2Group.add(endWall);

        // 3. Criação das Obras de Arte (Quadros)
        // 18 obras, 9 de cada lado.
        // Espaçamento: 80m / 9 obras = ~8.8m por obra
        const spacing = corridorLength / 9;
        const frameSize = 2.0; // Quadros de 2m x 2m
        const frameHeight = this.playerHeight + 0.2; // Altura dos olhos

        ARTWORK_DATA.forEach((artwork, index) => {
            const artTexture = this.textures[`art_${artwork.id}`];
            const artMaterial = new THREE.MeshBasicMaterial({ map: artTexture });

            const artGeometry = new THREE.PlaneGeometry(frameSize, frameSize);
            const artMesh = new THREE.Mesh(artGeometry, artMaterial);
            
            const plaqueGeometry = new THREE.PlaneGeometry(frameSize + 1, frameSize + 1);
            const plaqueMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const plaqueMesh = new THREE.Mesh(plaqueGeometry, plaqueMaterial);
            
            plaqueMesh.userData = {
                interactive: true,
                type: 'artwork',
                id: artwork.id,
                title: artwork.title,
                description: artwork.description
            };

            const zPos = 10 + (index % 9) * (spacing * 0.9);

            if (index < 9) {
                artMesh.position.set((-corridorWidth / 2) + 0.05, frameHeight, zPos);
                artMesh.rotation.y = Math.PI / 2;
                
                plaqueMesh.position.set((-corridorWidth / 2) + 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = Math.PI / 2;

            } else {
                artMesh.position.set((corridorWidth / 2) - 0.05, frameHeight, zPos);
                artMesh.rotation.y = -Math.PI / 2;
                
                plaqueMesh.position.set((corridorWidth / 2) - 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = -Math.PI / 2;
            }

            world2Group.add(artMesh);
            world2Group.add(plaqueMesh);
        });

        // 4. Limites de Colisão (Corredor)
        const collisionLimits = {
            minX: -corridorWidth / 2 + 0.5,
            maxX: corridorWidth / 2 - 0.5,
            minZ: 0.5,
            maxZ: corridorLength - 0.5
        };
        
        return { group: world2Group, collisionLimits: collisionLimits };
    }
}
js/main.js (ATUALIZADO)
JavaScript
/*
    ARQUIVO: main.js
    DESCRIÇÃO: Ponto de Entrada Principal da Aplicação (O "Maestro").
    FUNÇÃO: Este script inicializa todos os componentes (Cena, Câmera,
    Renderizador, Controles) e gerencia o "Game Loop" (o 'animate').
    Ele coordena o carregamento de assets, a transição de cenas
    e conecta os controles à lógica de interação.
*/

// Classe principal da aplicação
class SungApp {
    
    constructor() {
        // Elementos do DOM
        this.canvas = document.getElementById('game-canvas');
        this.loadingScreen = document.getElementById('loading-screen');
        this.loadingText = document.querySelector('.loading-text');
        this.transitionFade = document.getElementById('transition-fade');
        this.uiElements = [
            document.getElementById('crosshair'),
            document.getElementById('logo'),
            document.getElementById('copyright')
        ];

        // Componentes do Three.js
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true // Suavização de serrilhado
        });
        this.clock = new THREE.Clock(); // Relógio para o 'delta time'

        // Componentes do Jogo
        this.loader = null;
        this.controls = null;
        this.interaction = null;
        this.worldFactory = null;
        
        // Grupos de Cena (para fácil adição/remoção)
        this.world1_Group = null;
        this.world2_Group = null;

        // Estado do Jogo
        this.isLoaded = false;
        this.isTransitioning = false;
        this.currentWorldId = 1; // Começa no Mundo 1
        
        // Configurações (conforme UX finalizado)
        this.settings = {
            movementSpeed: 1.8,         // 1.8 m/s
            desktopCameraSpeed: 0.0008, // Sensibilidade Desktop
            mobileCameraSpeed: 0.0025,  // Sensibilidade Mobile
            playerHeight: 1.6           // Altura dos olhos do jogador
        };
        
        // Referência 'bind' para o loop de animação
        this.animate = this.animate.bind(this);
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Método principal de inicialização.
     */
    init() {
        console.log("Iniciando SungApp...");

        // 1. Configurar o Renderizador
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limita o pixel ratio por performance
        this.renderer.outputEncoding = THREE.sRGBEncoding;

        // 2. Configurar a Posição Inicial da Câmera
        // (Z > 55, conforme requisito da Cena 1)
        this.camera.position.set(0, this.settings.playerHeight, 60);

        // 3. Inicializar o Loader de Assets
        this.loader = new AssetLoader(
            (progress) => {
                // Função 'onProgress'
                this.loadingText.textContent = `Carregando... ${progress.toFixed(0)}%`;
            },
            () => {
                // Função 'onLoad' (Tudo carregado)
                this.startExperience();
            }
        );

        // 4. Definir quais texturas carregar
        // (Nomes vêm do 'checklist.txt' e 'scene.js')
        const sceneTextures = [
            { name: 'road', path: 'assets/images/road_texture.jpg', repeat: [3, 15] },
            { name: 'path', path: 'assets/images/path_texture.jpg', repeat: [1, 10] },
            { name: 'door', path: 'assets/images/door_texture.jpg' },
            { name: 'tree', path: 'assets/images/arvore.png' },
            { name: 'wall', path: 'assets/images/wall_texture.jpg', repeat: [20, 2] },
            { name: 'floor', path: 'assets/images/floor_texture.jpg', repeat: [2, 20] },
            { name: 'crystalGlow', path: 'assets/images/crystal_glow.png' } // Nova textura para o glow do cristal (precisa ser transparente)
        ];
        
        // Adiciona as 18 artes da galeria à lista de carregamento
        const artworkTextures = ARTWORK_DATA.map(art => ({
            name: `art_${art.id}`, // ex: 'art_1'
            path: art.image
        }));
        
        // Carrega TUDO
        const allTexturesToLoad = [...sceneTextures, ...artworkTextures];
        const loadedTextures = this.loader.loadTextures(allTexturesToLoad);
        
        // 5. Inicializar a "Fábrica" de Mundos com as texturas
        this.worldFactory = new WorldSceneFactory(loadedTextures);

        // 6. Ouvinte de redimensionamento da janela
        window.addEventListener('resize', this.onWindowResize.bind(this));
    }

    /**
     * Chamado quando o Loader termina (onLoad).
     */
    startExperience() {
        console.log("Assets carregados. Iniciando a experiência.");
        this.isLoaded = true;
        
        // 1. Construir o Mundo 1 (Floresta)
        const world1Data = this.worldFactory.createWorld1(this.scene);
        this.world1_Group = world1Data.group;
        this.scene.add(this.world1_Group);

        // 2. Inicializar Controles
        this.controls = new PlayerControls(this.camera, this.canvas, this.settings);
        // Define os limites de colisão para o mundo 1
        this.controls.setWorld(1, world1Data.collisionLimits);
        
        // 3. Inicializar Interação
        this.interaction = new InteractionHandler(
            this.camera, 
            this.scene, 
            this.handleInteraction.bind(this) // Callback
        );
        
        // 4. Conectar Controles e Interação
        // Diz ao 'controls' qual função chamar quando [E] é pressionado
        this.controls.onInteract = () => {
            this.interaction.triggerInteraction();
        };

        // 5. Esconder a tela de Loading e mostrar a UI do Jogo
        this.loadingScreen.style.opacity = '0';
        setTimeout(() => {
            this.loadingScreen.style.display = 'none';
        }, 500); // 0.5s (duração da transição do CSS)

        // Mostra a UI (Mira, Logo, etc.)
        this.uiElements.forEach(el => el.style.display = 'block');
        
        // 6. Iniciar o Loop de Animação
        this.animate();
    }
    
    // -----------------------------------------------------------------
    // LOOP DE ANIMAÇÃO (GAME LOOP)
    // -----------------------------------------------------------------

    /**
     * O Loop Principal (requestAnimationFrame).
     */
    animate() {
        // Pede ao navegador para chamar 'animate' no próximo frame
        requestAnimationFrame(this.animate);

        // Se não carregou ou está em transição, não faz nada
        if (!this.isLoaded || this.isTransitioning) {
            return;
        }

        // Pega o tempo delta (diferença do último frame)
        const delta = this.clock.getDelta();

        // 1. Atualiza o handler de interação (verifica o que está na mira)
        this.interaction.update();
        
        // 2. Atualiza os controles do jogador (movimento, colisão)
        this.controls.update(delta);

        // 3. Renderiza a cena 3D
        this.renderer.render(this.scene, this.camera);
    }
    
    // -----------------------------------------------------------------
    // LÓGICA DE TRANSIÇÃO E INTERAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Callback chamado pelo 'InteractionHandler' quando [E] é pressionado
     * em um alvo válido.
     * @param {Object} userData - Os dados do objeto (ex: { type: 'gothic_door' })
     */
    handleInteraction(userData) {
        console.log("Interação disparada:", userData);
        
        // Verifica se é a porta gótica E se estamos no mundo 1
        if (userData.type === 'gothic_door' && this.currentWorldId === 1) {
            this.triggerSceneTransition();
        }
        
        // (Futuro) Lógica para mostrar info da arte no Mundo 2
        if (userData.type === 'artwork' && this.currentWorldId === 2) {
            console.log(`Clicou na Arte: ${userData.title}`);
            // Aqui você poderia abrir um pop-up/modal com
            // userData.title e userData.description
        }
    }

    /**
     * Executa o "Theater Effect" (Transição da Cena 1 para a Cena 2).
     */
    triggerSceneTransition() {
        console.log("Iniciando transição de cena...");
        this.isTransitioning = true; // Pausa o 'animate' loop

        // 1. Fade In Rápido (0.5s) para Branco
        this.transitionFade.style.transition = 'opacity 0.5s ease-in';
        this.transitionFade.style.opacity = '1';

        // 2. Atraso de 500ms (enquanto a tela está branca)
        setTimeout(() => {
            // --- O TELEPORTE (acontece instantaneamente) ---
            
            // a. Remove a geometria do Mundo 1
            this.scene.remove(this.world1_Group);
            
            // b. Constrói e adiciona a geometria do Mundo 2
            const world2Data = this.worldFactory.createWorld2(this.scene);
            this.world2_Group = world2Data.group;
            this.scene.add(this.world2_Group);

            // c. Teleporta o Jogador (Z=10, conforme requisito)
            this.camera.position.set(0, this.settings.playerHeight, 10);
            
            // d. Reseta a Rotação da Câmera (olhar reto)
            this.controls.resetRotation();

            // e. Atualiza os controles para os limites de colisão do Mundo 2
            this.controls.setWorld(2, world2Data.collisionLimits);
            this.currentWorldId = 2;
            
            // --- FIM DO TELEPORTE ---

            // 3. Fade Out Lento (1.5s) do Branco (olhos se ajustando)
            this.transitionFade.style.transition = 'opacity 1.5s ease-out';
            this.transitionFade.style.opacity = '0';
            
            // 4. Atraso de 1500ms (espera o fade out terminar)
            setTimeout(() => {
                this.isTransitioning = false; // Retoma o 'animate' loop
                console.log("Transição completa. Mundo 2 carregado.");
            }, 1500);

        }, 500); // Fim do setTimeout do Fade In
    }

    // -----------------------------------------------------------------
    // UTILITÁRIOS
    // -----------------------------------------------------------------

    /**
     * Chamado quando a janela do navegador muda de tamanho.
     */
    onWindowResize() {
        // Atualiza as proporções da câmera
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();

        // Atualiza o tamanho do renderizador
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}

// -----------------------------------------------------------------
// PONTO DE ENTRADA
// -----------------------------------------------------------------

// Quando o DOM (HTML) estiver pronto, cria e inicializa a aplicação.
window.addEventListener('DOMContentLoaded', () => {
    const app = new SungApp();
    app.init();
});
Observações Importantes:

Para os cristais luminosos, adicionei uma nova textura crystal_glow.png no js/main.js. Você precisará criar este arquivo de imagem (pode ser uma forma simples e branca em fundo transparente) e colocá-lo em /assets/images/. A luz (PointLight) já funciona, mas o sprite dará um visual ao cristal em si.

A door_texture.jpg (porta) foi configurada para ser a imagem da Image 2.

A road_texture.jpg foi configurada para ser a imagem da Image 1.

A densidade das árvores e a lógica de posicionamento foram ajustadas em createWorld1 para tentar criar um efeito de "parede" de floresta em ambos os lados, simulando o ambiente da Image 1.

Os limites de colisão para o Mundo 1 foram ajustados para refletir a nova densidade da floresta.

Com essas atualizações, o projeto agora incorpora os detalhes visuais e funcionais que você solicitou para a rodovia, floresta e porta.

e faca o codigo do zero

Entendido. Aqui está o código completo do projeto, do zero, incorporando todas as suas especificações, incluindo as referências rodovia.png e porta.png, a floresta densa com árvores de tamanhos variados e os cristais luminosos na trilha.

Basta criar os arquivos e pastas exatamente como descrito abaixo.

README.md
Markdown
# Sung Studios - Portfólio 3D Gótico

Este é o repositório do projeto para o site interativo 3D "Sung Studios", um portfólio de tatuagem com tema de horror cinematográfico.

## Visão Geral

O projeto é uma experiência narrativa em primeira pessoa que guia o usuário por duas cenas distintas:
1.  **A Descoberta:** Uma estrada escura e uma trilha na floresta (baseada em `rodovia.png`) que leva a uma porta gótica (baseada em `porta.png`), com cristais luminosos.
2.  **A Galeria:** Um corredor linear e sombrio onde as 18 artes do portfólio estão em exibição.

A experiência é construída com uma estética de horror sutil, inspirada em *Sleepy Hollow* de Tim Burton, usando estritamente uma paleta de cores preto e branco.

## Stack Técnica

Este projeto foi construído intencionalmente **sem frameworks ou bibliotecas externas**, exceto pelo Three.js, para garantir total controle sobre o desempenho e a experiência.

* **HTML5**
* **CSS3**
* **JavaScript (ES6+)**
* **Three.js** (incluído via CDN)

## Estrutura de Arquivos

A estrutura do projeto está organizada da seguinte forma:

/ │ ├── index.html (Página principal e contêiner da UI) ├── COMO_EDITAR.txt (Instruções de manutenção em PT-BR) ├── checklist.txt (Lista de assets necessários em PT-BR) ├── README.md (Este arquivo) │ ├── css/ │ └── style.css (Estilos para UI, transições e responsividade) │ ├── js/ │ ├── main.js (Loop principal, gerenciamento de estado e inicialização) │ ├── scene.js (Criação de geometria para ambas as cenas) │ ├── controls.js (Manipulador de entrada - teclado, mouse e toque) │ ├── interaction.js (Lógica de Raycasting e interação com objetos) │ ├── loader.js (Gerenciador de carregamento de texturas) │ ├── data/ │ └── artworks.js (Arquivo de dados para as 18 obras de arte) │ ├── assets/ │ ├── images/ │ │ ├── belial.png (Logo principal) │ │ ├── arvore.png (Billboard de árvore para a floresta) │ │ ├── rodovia.png (Textura da estrada, fornecida por você) │ │ ├── porta.png (Textura da porta, fornecida por você) │ │ ├── path_texture.jpg (Textura para a trilha de terra) │ │ ├── wall_texture.jpg (Textura da parede do corredor) │ │ ├── floor_texture.jpg(Textura do chão do corredor) │ │ ├── crystal_glow.png (Brilho para o cristal na floresta) │ │ │ │ │ └── img/ │ │ ├── tattoo_01.png │ │ ├── ... (até 18 imagens) │ │ │ └── audio/ │ (Vazio - reservado para áudio futuro)


## Instruções de Edição

Para adicionar ou alterar as artes exibidas no corredor, consulte o arquivo `COMO_EDITAR.txt` para instruções detalhadas.

---
© 2025 Sung
COMO_EDITAR.txt
Plaintext
=================================================
GUIA DE MANUTENÇÃO - SUNG STUDIOS (PT-BR)
=================================================

Este arquivo explica como atualizar o conteúdo do site 3D sem precisar mexer no código principal.

-------------------------------------------------
1. COMO ADICIONAR OU MUDAR AS TATUAGENS (OBRAS DE ARTE)
-------------------------------------------------

Toda a galeria no "Mundo 2" (O Corredor) é gerada automaticamente a partir de um único arquivo.

ARQUIVO PARA EDITAR: /data/artworks.js

PASSO 1: ADICIONE SUAS IMAGENS
1.  Pegue seus 18 arquivos de imagem (de preferência .png ou .jpg).
2.  Renomeie-os para nomes simples (ex: 'tattoo_01.png', 'tattoo_02.png', etc.).
3.  Coloque TODOS os 18 arquivos dentro da pasta: /assets/images/img/

PASSO 2: ATUALIZE O ARQUIVO 'artworks.js'
1.  Abra o arquivo /data/artworks.js em um editor de texto.
2.  Você verá uma lista (array) chamada `ARTWORK_DATA`.
3.  Ela contém 18 blocos de código, um para cada obra de arte.

Exemplo de um bloco:
{
    id: 1,
    image: 'assets/images/img/tattoo_01.png', // <-- MUDE ESTE CAMINHO
    title: 'Nome da Arte 1',                     // <-- MUDE O TÍTULO
    description: 'Descrição da sua arte aqui.'   // <-- MUDE A DESCRIÇÃO
},

4.  Para cada uma das 18 obras, atualize:
    * `image`: Coloque o caminho exato para a imagem que você adicionou no PASSO 1.
    * `title`: O título que aparecerá.
    * `description`: O texto de descrição.

5.  Salve o arquivo. O site será atualizado automaticamente.

-------------------------------------------------
2. COMO MUDAR TEXTURAS DO CENÁRIO (AVANÇADO)
-------------------------------------------------

Se você quiser mudar a aparência do cenário (a estrada, a trilha, as paredes), você pode substituir os arquivos de textura.

PASTA DE TEXTURAS: /assets/images/

* `rodovia.png`: A textura do asfalto da estrada (fornecida por você).
* `porta.png`: A textura da porta gótica (fornecida por você).
* `arvore.png`: A imagem da árvore usada na floresta (formato billboard).
* `path_texture.jpg`: A textura do chão da trilha de terra.
* `wall_texture.jpg`: A textura das paredes do corredor.
* `floor_texture.jpg`: A textura do chão do corredor.
* `crystal_glow.png`: A imagem do brilho do cristal (fundo transparente).

Basta substituir o arquivo de imagem nesta pasta pelo seu novo arquivo, MANTENDO O MESMO NOME E EXTENSÃO.
checklist.txt
Plaintext
=================================================
CHECKLIST DE ASSETS DO PROJETO (PT-BR)
=================================================

Verifique se todos os assets (arquivos de mídia) necessários estão nas pastas corretas antes de testar o projeto.

### 1. Imagens de Cenário (Obrigatórias)
Local: /assets/images/

[ ] rodovia.png            (Textura do asfalto da estrada - IMAGEM QUE VOCÊ FORNECEU)
[ ] porta.png              (Textura da porta gótica - IMAGEM QUE VOCÊ FORNECEU)
[ ] belial.png             (Logo da marca "Sung" que aparece no canto)
Você interrompeu a resposta
e faca o codigo do zero (em anexo a img de como esta estruturado minhas pastas

Certo. Entendido. Vamos construir o projeto completo do zero, usando a sua estrutura de pastas (image_bcc321.png) como referência principal, e incorporando todas as suas solicitações do "FINAL PROJECT PROMPT", incluindo as imagens rodovia.png e porta.png, e os novos requisitos (árvores variadas, cristais luminosos).

Para alinhar a sua captura de tela (image_bcc321.png) com o "FINAL PROJECT PROMPT", vou seguir esta estrutura:

css/styles.css (conforme sua imagem)

data/arts.json (conforme sua imagem)

js/main.js, js/controls.js, js/scene.js (conforme sua imagem)

Vou adicionar js/loader.js e js/interaction.js que são essenciais para a organização do código (como um "Senior Dev" faria).

Vou criar a pasta assets/ e, dentro dela, images/ (para texturas como rodovia.png, porta.png, belial.png, arvore.png) e audio/.

A pasta img/ da sua captura de tela será usada para as 18 artes de tatuagem (ex: img/tattoo_01.png).

Vou adicionar o como_rodar.txt que estava na sua imagem.

Aqui está o código completo para cada arquivo.

Estrutura de Pastas Final
/
│
├── index.html
├── README.md
├── COMO_EDITAR.txt
├── como_rodar.txt  (NOVO)
├── checklist.txt
│
├── assets/
│   ├── images/
│   │   ├── belial.png       (Seu logo)
│   │   ├── rodovia.png      (Textura da estrada que você enviou)
│   │   ├── porta.png        (Textura da porta que você enviou)
│   │   ├── arvore.png       (Textura da árvore da floresta)
│   │   ├── path_texture.jpg (Textura da trilha de terra)
│   │   ├── wall_texture.jpg (Textura da parede do corredor)
│   │   ├── floor_texture.jpg(Textura do chão do corredor)
│   │   └── crystal_glow.png (Brilho do cristal - crie esta imagem)
│   │
│   └── audio/
│       (Vazio)
│
├── css/
│   └── styles.css        (Nome do arquivo da sua imagem)
│
├── data/
│   └── arts.json         (Nome do arquivo da sua imagem)
│
├── img/
│   ├── tattoo_01.png
│   ├── tattoo_02.png
│   └── ... (etc. 18 imagens)
│
└── js/
    ├── main.js
    ├── scene.js
    ├── controls.js
    ├── interaction.js    (Arquivo auxiliar)
    └── loader.js         (Arquivo auxiliar)
README.md
Markdown
# Sung Studios - Portfólio 3D Gótico

Este é o repositório do projeto para o site interativo 3D "Sung Studios", um portfólio de tatuagem com tema de horror cinematográfico.

## Visão Geral

O projeto é uma experiência narrativa em primeira pessoa que guia o usuário por duas cenas distintas:
1.  **A Descoberta:** Uma estrada escura e uma trilha na floresta (baseada em `rodovia.png`) que leva a uma porta gótica (baseada em `porta.png`), com cristais luminosos.
2.  **A Galeria:** Um corredor linear e sombrio onde as 18 artes do portfólio estão em exibição.

A experiência é construída com uma estética de horror sutil, inspirada em *Sleepy Hollow* de Tim Burton, usando estritamente uma paleta de cores preto e branco.

## Stack Técnica

Este projeto foi construído intencionalmente **sem frameworks ou bibliotecas externas**, exceto pelo Three.js, para garantir total controle sobre o desempenho e a experiência.

* **HTML5**
* **CSS3**
* **JavaScript (ES6+)**
* **Three.js** (incluído via CDN)

## Estrutura de Arquivos

A estrutura do projeto está organizada conforme a solicitação:

* `/index.html` (Página principal)
* `/css/styles.css` (Folha de estilos)
* `/data/arts.json` (Dados das obras de arte)
* `/js/*.js` (Scripts da aplicação)
* `/assets/images/` (Texturas principais, como `rodovia.png`, `porta.png`, `arvore.png`, etc.)
* `/img/` (As 18 imagens de tatuagem da galeria)
* `/assets/audio/` (Reservado para sons)

## Instruções de Edição

Para adicionar ou alterar as artes exibidas no corredor, consulte o arquivo `COMO_EDITAR.txt` para instruções detalhadas.

## Como Rodar

Consulte `como_rodar.txt` para instruções sobre como iniciar um servidor local, que é necessário para carregar os assets.

---
© 2025 Sung
COMO_EDITAR.txt
Plaintext
=================================================
GUIA DE MANUTENÇÃO - SUNG STUDIOS (PT-BR)
=================================================

Este arquivo explica como atualizar o conteúdo do site 3D sem precisar mexer no código principal.

-------------------------------------------------
1. COMO ADICIONAR OU MUDAR AS TATUAGENS (OBRAS DE ARTE)
-------------------------------------------------

Toda a galeria no "Mundo 2" (O Corredor) é gerada automaticamente a partir de um único arquivo.

ARQUIVO PARA EDITAR: /data/arts.json

PASSO 1: ADICIONE SUAS IMAGENS
1.  Pegue seus 18 arquivos de imagem (de preferência .png ou .jpg).
2.  Renomeie-os para nomes simples (ex: 'tattoo_01.png', 'tattoo_02.png', etc.).
3.  Coloque TODOS os 18 arquivos dentro da pasta: /img/

PASSO 2: ATUALIZE O ARQUIVO 'arts.json'
1.  Abra o arquivo /data/arts.json em um editor de texto.
2.  Você verá uma lista (array) `[ ... ]` de objetos `{ ... }`.
3.  Cada objeto `{}` representa uma obra de arte.

Exemplo de um objeto:
{
    "id": 1,
    "image": "img/tattoo_01.png",            // <-- MUDE ESTE CAMINHO
    "title": "Nome da Arte 1",                  // <-- MUDE O TÍTULO
    "description": "Descrição da sua arte aqui."  // <-- MUDE A DESCRIÇÃO
},

4.  Para cada uma das 18 obras, atualize:
    * `image`: Coloque o caminho exato para a imagem que você adicionou na pasta /img/.
    * `title`: O título que aparecerá.
    * `description`: O texto de descrição.

5.  **IMPORTANTE**: O formato JSON exige aspas duplas ("") em todas as chaves (como "id") e valores de texto. O último item da lista NÃO deve ter uma vírgula no final.

6.  Salve o arquivo. O site será atualizado automaticamente.

-------------------------------------------------
2. COMO MUDAR TEXTURAS DO CENÁRIO (AVANÇADO)
-------------------------------------------------

PASTA DE TEXTURAS: /assets/images/

* `rodovia.png`: A textura do asfalto da estrada (fornecida por você).
* `porta.png`: A textura da porta gótica (fornecida por você).
* `belial.png`: O logo no canto da tela.
* `arvore.png`: A imagem da árvore usada na floresta (formato billboard).
* `path_texture.jpg`: A textura do chão da trilha de terra.
* `wall_texture.jpg`: A textura das paredes do corredor.
* `floor_texture.jpg`: A textura do chão do corredor.
* `crystal_glow.png`: A imagem do brilho do cristal (fundo transparente).

Basta substituir o arquivo de imagem nesta pasta pelo seu novo arquivo, MANTENDO O MESMO NOME E EXTENSÃO.
como_rodar.txt (NOVO ARQUIVO)
Plaintext
=================================================
COMO RODAR O PROJETO (PT-BR)
=================================================

Este projeto não funciona corretamente se você apenas abrir o arquivo `index.html` diretamente no navegador (ex: `file:///C:/.../index.html`).

Isso acontece por causa das políticas de segurança (CORS) dos navegadores, que bloqueiam o carregamento de texturas e arquivos de dados (como o `arts.json`) dessa maneira.

-------------------------------------------------
COMO RODAR (MÉTODO FÁCIL - VS CODE)
-------------------------------------------------

1.  Abra a pasta do projeto no Visual Studio Code (VS Code).
2.  Vá até a aba "Extensions" (Extensões) na barra lateral.
3.  Procure por "Live Server" (feito por Ritwick Dey).
4.  Instale a extensão.
5.  Depois de instalado, volte para a lista de arquivos.
6.  Clique com o botão direito no arquivo `index.html`.
7.  Selecione "Open with Live Server" (Abrir com Live Server).

Isso iniciará um servidor local (ex: `http://127.0.0.1:5500`) e o projeto funcionará perfeitamente.

-------------------------------------------------
COMO RODAR (MÉTODO ALTERNATIVO - PYTHON)
-------------------------------------------------

Se você tem Python 3 instalado:

1.  Abra o terminal (Prompt de Comando, PowerShell, etc.).
2.  Navegue até a pasta raiz do projeto (onde o `index.html` está).
3.  Digite o comando:
    `python -m http.server`
4.  Abra o seu navegador e acesse:
    `http://localhost:8000`

checklist.txt
Plaintext
=================================================
CHECKLIST DE ASSETS DO PROJETO (PT-BR)
=================================================

Verifique se todos os assets (arquivos de mídia) necessários estão nas pastas corretas antes de testar o projeto.

### 1. Imagens de Cenário (Obrigatórias)
Local: /assets/images/

[ ] rodovia.png            (Textura do asfalto - FORNECIDA POR VOCÊ)
[ ] porta.png              (Textura da porta gótica - FORNECIDA POR VOCÊ)
[ ] belial.png             (Logo "Sung" que aparece no canto)
[ ] arvore.png             (Imagem da árvore com fundo transparente para a floresta)
[ ] path_texture.jpg       (Textura de terra/lama para a trilha)
[ ] wall_texture.jpg       (Textura das paredes da galeria/corredor)
[ ] floor_texture.jpg      (Textura do chão da galeria/corredor)
[ ] crystal_glow.png       (Textura de brilho para os cristais, ex: um ponto suave branco/azul)

### 2. Imagens da Galeria (Obrigatórias)
Local: /img/

[ ] tattoo_01.png
[ ] tattoo_02.png
[ ] tattoo_03.png
[ ] tattoo_04.png
[ ] tattoo_05.png
[ ] tattoo_06.png
[ ] tattoo_07.png
[ ] tattoo_08.png
[ ] tattoo_09.png
[ ] tattoo_10.png
[ ] tattoo_11.png
[ ] tattoo_12.png
[ ] tattoo_13.png
[ ] tattoo_14.png
[ ] tattoo_15.png
[ ] tattoo_16.png
[ ] tattoo_17.png
[ ] tattoo_18.png
(Total de 18 imagens de tatuagem)

### 3. Áudio (Opcional)
Local: /assets/audio/
(Vazio por enquanto)
index.html
HTML
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sung Studios - 3D Portfolio</title>
    
    <link rel="stylesheet" href="css/styles.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-text">Carregando...</div>
    </div>

    <div id="rotate-message">
        <p>Por favor, gire seu dispositivo para a posição horizontal (paisagem) para iniciar a experiência.</p>
    </div>

    <div id="transition-fade"></div>

    <div id="crosshair">+</div>

    <div id="dpad-container">
        <button id="dpad-forward" class="dpad-btn">▲</button>
        <button id="dpad-backward" class="dpad-btn">▼</button>
        <button id="dpad-left" class="dpad-btn">◄</button>
        <button id="dpad-right" class="dpad-btn">►</button>
    </div>

    <button id="action-btn">E</button>

    <div id="logo">
        <img src="assets/images/belial.png" alt="Sung Studios Logo">
    </div>
    <div id="copyright">© 2025 Sung</div>

    <canvas id="game-canvas"></canvas>

    <script src="js/loader.js"></script>
    <script src="js/scene.js"></script>
    <script src="js/controls.js"></script>
    <script src="js/interaction.js"></script>
    <script src="js/main.js"></script>

</body>
</html>
css/styles.css
CSS
/*
    ARQUIVO: styles.css (conforme sua estrutura)
    DESCRIÇÃO: Folha de Estilos Principal.
    FUNÇÃO: Define todos os estilos visuais da aplicação, incluindo:
    - Reset básico (fundo preto, tela cheia).
    - Tipografia (estilo Cinzel/Inter).
    - Estilos da UI (Mira, Logo, Copyright).
    - Estilos dos Controles Mobile (D-Pad, Botão de Ação).
    - Animação de Transição (Fade branco).
    - Responsividade (Mensagem de Rotação).
*/

/* 1. CONFIGURAÇÃO GLOBAL E FONTES */

/* Importação de fontes (Exemplo: Cinzel e Inter) */
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400&display=swap');

/*
    Reset Global:
    Remove margens, preenchimentos e define o 'box-sizing' para
    facilitar o layout. Define a cor de fundo padrão como preta
    e a cor do texto como branca (Paleta B&W).
*/
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden; /* Impede barras de rolagem */
    background-color: #000000;
    color: #ffffff;
    
    /* Define a pilha de fontes: Cinzel para títulos, Inter para texto. */
    font-family: 'Inter', sans-serif;
}

/* 2. ELEMENTOS 3D E OVERLAYS */

/*
    Canvas do Jogo:
    O canvas onde o Three.js desenha a cena.
    Deve ocupar a tela inteira, fixo no fundo.
*/
#game-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* Fica atrás de toda a UI */
    cursor: pointer; /* Indica que é clicável (para PointerLock) */
}

/*
    Tela de Carregamento (Loading):
    Overlay que cobre a tela enquanto os assets carregam.
*/
#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000000;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 200; /* Fica acima de tudo */
    transition: opacity 0.5s ease-out;
}

.loading-text {
    font-family: 'Cinzel', serif;
    font-size: 1.5rem;
    color: #ffffff;
}

/*
    Tela de Transição (Flash Branco):
    Usada para o "Theater Effect". Começa transparente.
*/
#transition-fade {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #ffffff;
    opacity: 0;
    pointer-events: none; /* Não pode ser clicado */
    z-index: 150; /* Acima da UI, abaixo do Loading */
    
    /* A transição é controlada via JS (main.js) */
}

/* 3. UI FIXA (MIRA, LOGO, COPYRIGHT) */

/*
    Mira (Crosshair):
    O '+' no centro da tela para interação.
*/
#crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    font-weight: bold;
    color: rgba(255, 255, 255, 0.7); /* Branco semi-transparente */
    pointer-events: none; /* Não pode ser clicado */
    z-index: 100;
    display: none; /* Começa escondido, 'main.js' mostra após carregar */
}

/* Logo "Sung" */
#logo {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 100;
    opacity: 0.8;
    pointer-events: none;
    display: none; /* Começa escondido */
}

#logo img {
    width: 100px; /* Tamanho do logo */
    height: auto;
}

/* Texto de Copyright */
#copyright {
    position: fixed;
    bottom: 10px;
    right: 10px;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.5);
    z-index: 100;
    pointer-events: none;
    display: none; /* Começa escondido */
}


/* 4. CONTROLES MOBILE (D-PAD E BOTÃO DE AÇÃO) */

/*
    Os controles mobile só aparecem em telas de toque.
    O 'controls.js' vai detectar se é mobile e mostrá-los.
*/
#dpad-container,
#action-btn {
    display: none; /* Escondidos por padrão (Desktop) */
    position: fixed;
    z-index: 110;
    user-select: none; /* Impede seleção de texto ao tocar */
    -webkit-user-select: none;
}

/* Contêiner do D-Pad */
#dpad-container {
    bottom: 30px;
    left: 30px;
    width: 150px;
    height: 150px;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr 1fr;
    opacity: 0.5; /* Semi-transparente para não atrapalhar a visão */
}

/* Botões do D-Pad (layout) */
#dpad-forward { grid-area: 1 / 2 / 2 / 3; }
#dpad-left { grid-area: 2 / 1 / 3 / 2; }
#dpad-right { grid-area: 2 / 3 / 3 / 4; }
#dpad-backward { grid-area: 3 / 2 / 4 / 3; }

/* Estilo comum dos botões do D-Pad */
.dpad-btn {
    background-color: rgba(255, 255, 255, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.5);
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
    border-radius: 8px; /* Bordas arredondadas */
}

/* Efeito ao pressionar o botão (feedback tátil) */
.dpad-btn:active {
    background-color: rgba(255, 255, 255, 0.6);
}

/* Botão de Ação [E] */
#action-btn {
    bottom: 40px;
    right: 40px;
    width: 80px;
    height: 80px;
    background-color: rgba(255, 255, 255, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.7);
    color: white;
    font-size: 2rem;
    font-weight: bold;
    font-family: 'Cinzel', serif;
    border-radius: 50%; /* Botão redondo */
    cursor: pointer;
    opacity: 0.6;
}

#action-btn:active {
    background-color: rgba(255, 255, 255, 0.6);
}


/* 5. RESPONSIVIDADE (MENSAGEM DE ROTAÇÃO) */

/*
    Mensagem de Rotação (Modo Retrato em Mobile):
    Por padrão, fica escondida.
*/
#rotate-message {
    display: none; /* Escondido por padrão */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000000;
    color: #ffffff;
    z-index: 250; /* Acima de TUDO */
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 20px;
    font-family: 'Cinzel', serif;
    font-size: 1.2rem;
}

/*
    Media Query para Orientação:
    Se o dispositivo estiver em modo "retrato" (altura > largura),
    mostra a mensagem de rotação e esconde todo o resto da UI.
*/
@media (orientation: portrait) {
    #rotate-message {
        display: flex; /* Mostra a mensagem */
    }

    /* Esconde toda a UI do jogo */
    #crosshair,
    #dpad-container,
    #action-btn,
    #logo,
    #copyright,
    #loading-screen {
        display: none !important;
    }
}
data/arts.json
JSON
[
    {
        "id": 1,
        "image": "img/tattoo_01.png",
        "title": "Título da Arte 1",
        "description": "Descrição detalhada da obra de arte número 1."
    },
    {
        "id": 2,
        "image": "img/tattoo_02.png",
        "title": "Título da Arte 2",
        "description": "Descrição detalhada da obra de arte número 2."
    },
    {
        "id": 3,
        "image": "img/tattoo_03.png",
        "title": "Título da Arte 3",
        "description": "Descrição detalhada da obra de arte número 3."
    },
    {
        "id": 4,
        "image": "img/tattoo_04.png",
        "title": "Título da Arte 4",
        "description": "Descrição detalhada da obra de arte número 4."
    },
    {
        "id": 5,
        "image": "img/tattoo_05.png",
        "title": "Título da Arte 5",
        "description": "Descrição detalhada da obra de arte número 5."
    },
    {
        "id": 6,
        "image": "img/tattoo_06.png",
        "title": "Título da Arte 6",
        "description": "Descrição detalhada da obra de arte número 6."
    },
    {
        "id": 7,
        "image": "img/tattoo_07.png",
        "title": "Título da Arte 7",
        "description": "Descrição detalhada da obra de arte número 7."
    },
    {
        "id": 8,
        "image": "img/tattoo_08.png",
        "title": "Título da Arte 8",
        "description": "Descrição detalhada da obra de arte número 8."
    },
    {
        "id": 9,
        "image": "img/tattoo_09.png",
        "title": "Título da Arte 9",
        "description": "Descrição detalhada da obra de arte número 9."
    },
    {
        "id": 10,
        "image": "img/tattoo_10.png",
        "title": "Título da Arte 10",
        "description": "Descrição detalhada da obra de arte número 10."
    },
    {
        "id": 11,
        "image": "img/tattoo_11.png",
        "title": "Título da Arte 11",
        "description": "Descrição detalhada da obra de arte número 11."
    },
    {
        "id": 12,
        "image": "img/tattoo_12.png",
        "title": "Título da Arte 12",
        "description": "Descrição detalhada da obra de arte número 12."
    },
    {
        "id": 13,
        "image": "img/tattoo_13.png",
        "title": "Título da Arte 13",
        "description": "Descrição detalhada da obra de arte número 13."
    },
    {
        "id": 14,
        "image": "img/tattoo_14.png",
        "title": "Título da Arte 14",
        "description": "Descrição detalhada da obra de arte número 14."
    },
    {
        "id": 15,
        "image": "img/tattoo_15.png",
        "title": "Título da Arte 15",
        "description": "Descrição detalhada da obra de arte número 15."
    },
    {
        "id": 16,
        "image": "img/tattoo_16.png",
        "title": "Título da Arte 16",
        "description": "Descrição detalhada da obra de arte número 16."
    },
    {
        "id": 17,
        "image": "img/tattoo_17.png",
        "title": "Título da Arte 17",
        "description": "Descrição detalhada da obra de arte número 17."
    },
    {
        "id": 18,
        "image": "img/tattoo_18.png",
        "title": "Título da Arte 18",
        "description": "Descrição detalhada da obra de arte número 18."
    }
]
js/loader.js
JavaScript
/*
    ARQUIVO: loader.js
    DESCRIÇÃO: Gerenciador de Carregamento de Assets.
    FUNÇÃO: Este script é responsável por carregar todas as texturas (imagens)
    necessárias para o projeto ANTES que a experiência comece.
    Ele usa o LoadingManager do Three.js para rastrear o progresso e
    notificar o 'main.js' quando tudo estiver pronto.
*/

class AssetLoader {
    // O construtor recebe as funções que devem ser chamadas
    // durante o carregamento (onProgress) e ao finalizar (onLoad).
    constructor(onProgress, onLoad) {
        // O LoadingManager monitora todos os loaders.
        this.manager = new THREE.LoadingManager();
        
        // Define as funções de callback do manager.
        this.manager.onProgress = (url, itemsLoaded, itemsTotal) => {
            // Calcula a porcentagem
            const progress = (itemsLoaded / itemsTotal) * 100;
            // Chama a função onProgress (definida em main.js)
            onProgress(progress);
            console.log(`Carregando: ${url} (${progress.toFixed(0)}%)`);
        };

        this.manager.onLoad = () => {
            // Chama a função onLoad (definida em main.js)
            onLoad();
            console.log('Todos os assets foram carregados.');
        };

        this.manager.onError = (url) => {
            console.error(`Erro ao carregar o asset: ${url}`);
        };

        // O TextureLoader é o responsável por carregar as imagens.
        // Passamos o manager para ele.
        this.textureLoader = new THREE.TextureLoader(this.manager);
    }

    /**
     * Carrega uma lista de texturas.
     * @param {Array<Object>} texturesToLoad - Um array de objetos { name, path }
     * @returns {Object} - Um objeto onde as chaves são os nomes (name) e os
     * valores são as texturas (THREE.Texture) carregadas.
     */
    loadTextures(texturesToLoad) {
        const textures = {};
        
        texturesToLoad.forEach(tex => {
            // Carrega a textura
            const texture = this.textureLoader.load(tex.path);
            
            // Configurações de repetição (wrapping) e filtro
            // Essencial para texturas de chão e parede.
            if (tex.repeat) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(tex.repeat[0], tex.repeat[1]);
            }

            // Adiciona ao nosso objeto de texturas
            textures[tex.name] = texture;
        });

        // Retorna o objeto com todas as texturas (que ainda estão carregando,
        // mas o manager vai saber quando terminarem).
        return textures;
    }
}
js/scene.js
JavaScript
/*
    ARQUIVO: scene.js
    DESCRIÇÃO: Construtor de Cenários 3D.
    FUNÇÃO: Esta classe é uma "fábrica" de geometria. Ela não
    mantém estado, apenas contém métodos que criam e retornam
    os mundos (Cena 1 e Cena 2) como grupos de objetos (THREE.Group).
*/

class WorldSceneFactory {

    constructor(textures) {
        // Armazena as texturas que o 'loader.js' carregou.
        this.textures = textures;
        // Altura padrão da câmera (nível dos olhos)
        this.playerHeight = 1.6;
    }

    // -----------------------------------------------------------------
    // CENA 1: A DESCOBERTA (HIGHWAY / FLORESTA)
    // -----------------------------------------------------------------
    createWorld1(scene) {
        const world1Group = new THREE.Group();
        world1Group.name = "World1_Group"; // Nome para depuração

        // 1. Configuração do Clima (Névoa e Luz)
        // Cor cinza-azulado escuro, inspirada em 'clima.png' (Sleepy Hollow)
        const fogColor = 0x2c3e50; 
        scene.background = new THREE.Color(fogColor);
        // A névoa começa perto e fica densa rapidamente
        scene.fog = new THREE.Fog(fogColor, 1, 35); 

        // Luz ambiente fraca, para dar o tom sombrio
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // (cor, intensidade)
        world1Group.add(ambientLight);

        // Luz direcional (simulando lua/crepúsculo)
        const directionalLight = new THREE.DirectionalLight(0x505a70, 0.4);
        directionalLight.position.set(5, 10, 5);
        world1Group.add(directionalLight);


        // 2. Geometria do Chão (Estrada e Trilha)
        // Usamos a textura 'rodovia.png'
        const roadMaterial = new THREE.MeshBasicMaterial({ map: this.textures.rodovia });
        const roadGeometry = new THREE.PlaneGeometry(15, 80); // (largura, comprimento)
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; // Deita o plano no chão
        road.position.set(0, 0, 80); // Posiciona na área Z > 55
        world1Group.add(road);

        // Trilha de terra
        const pathMaterial = new THREE.MeshBasicMaterial({ map: this.textures.path });
        const pathGeometry = new THREE.PlaneGeometry(5, 60); // (largura, comprimento)
        const path = new THREE.Mesh(pathGeometry, pathMaterial);
        path.rotation.x = -Math.PI / 2;
        path.position.set(0, 0.01, 20); // Z < 55 (começa em -10, vai até 50)
        world1Group.add(path);

        // 3. Floresta Densa (Billboards de Árvores)
        // Material da árvore (usa 'arvore.png')
        const treeMaterial = new THREE.SpriteMaterial({ 
            map: this.textures.tree,
            fog: true,
            color: 0xcccccc // Um pouco mais escuras/cinzas
        });
        
        // Material do brilho do cristal
        const crystalMaterial = new THREE.SpriteMaterial({
            map: this.textures.crystalGlow,
            blending: THREE.AdditiveBlending, // Efeito de brilho
            fog: false, // Cristais brilham através da névoa
            transparent: true,
            opacity: 0.8
        });

        // Cria 350 árvores para densidade
        for (let i = 0; i < 350; i++) {
            const sprite = new THREE.Sprite(treeMaterial);
            
            // Posição Z aleatória ao longo de todo o mapa
            const z = Math.random() * 130 - 10; // (Z de -10 a 120)
            
            // Posição X aleatória (para criar as "paredes" espelhadas)
            let x;
            if (z > 50) { // Área da estrada (mais larga)
                x = Math.random() < 0.5 ? -Math.random() * 20 - 7.5 : Math.random() * 20 + 7.5;
            } else { // Área da trilha (mais estreita)
                x = Math.random() < 0.5 ? -Math.random() * 20 - 2.5 : Math.random() * 20 + 2.5;
            }

            // Tamanho aleatório (árvores grandes e médias)
            const scale = Math.random() * 3 + 4; // Escala entre 4m e 7m
            sprite.scale.set(scale, scale, 1);
            sprite.position.set(x, scale / 2, z); // (x, altura, z)
            world1Group.add(sprite);
            
            // Adiciona Cristais Luminosos (Losangos)
            // 10% de chance de uma árvore na trilha (Z < 50) ter um cristal
            if (z < 50 && z > -10 && Math.random() < 0.1) {
                // Luz Pontual (azulada)
                const light = new THREE.PointLight(0xadd8e6, 1, 5); // (cor, intensidade, distância)
                light.position.set(x * 0.9, 2.5, z); // Posição próxima à árvore
                world1Group.add(light);
                
                // Sprite visual do cristal (forma de losango/brilho)
                const crystalSprite = new THREE.Sprite(crystalMaterial);
                crystalSprite.position.copy(light.position);
                crystalSprite.scale.set(1.5, 2.5, 1); // Escala para parecer um losango (mais alto que largo)
                world1Group.add(crystalSprite);
            }
        }

        // 4. A Porta Gótica (Objetivo)
        // Usamos a textura 'porta.png'
        
        // Simula a "rocha" onde a porta está (como na imagem 'porta.png')
        const rockFaceMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 }); // Material escuro
        const rockFaceGeometry = new THREE.PlaneGeometry(8, 8); // Parede de rocha
        const rockFace = new THREE.Mesh(rockFaceGeometry, rockFaceMaterial);
        rockFace.position.set(0, 4, -10.5); // (x, altura, z) - Posição atrás da porta
        world1Group.add(rockFace);
        
        // A porta em si
        const doorMaterial = new THREE.MeshBasicMaterial({ 
            map: this.textures.porta,
            transparent: true // Necessário se 'porta.png' tiver transparência
        });
        const doorGeometry = new THREE.PlaneGeometry(4, 5); // Tamanho da porta
        const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
        
        // Posiciona no final da trilha, em frente à rocha
        doorMesh.position.set(0, 2.5, -10); // (x, altura, z)
        
        // Adiciona um 'userData' para o interaction.js saber que este
        // objeto é interativo.
        doorMesh.userData = { 
            interactive: true, 
            type: 'gothic_door' 
        };
        world1Group.add(doorMesh);


        // 5. Limites de Colisão (Invisíveis)
        // O 'controls.js' usará estes limites.
        // Limite da estrada: X = +/- 7.5
        // Limite da trilha: X = +/- 2.5
        const pathLimits = {
            minX: -7.5,
            maxX: 7.5,
            minZ: -9.5, // Perto da porta (para permitir interação)
            maxZ: 120, // Fim da estrada
            
            // Definição da área estreita (trilha)
            trailZStart: 50, // Onde a estrada (larga) termina
            trailMinX: -2.5, // Largura da trilha
            trailMaxX: 2.5
        };

        // Retorna o grupo de objetos e os limites de colisão
        return { group: world1Group, collisionLimits: pathLimits };
    }


    // -----------------------------------------------------------------
    // CENA 2: A GALERIA (CORREDOR)
    // -----------------------------------------------------------------
    createWorld2(scene, artworkData) { // Recebe os dados do JSON
        const world2Group = new THREE.Group();
        world2Group.name = "World2_Group";

        // 1. Limpa a Névoa e Luz da Cena 1
        scene.fog = null; // Remove a névoa
        scene.background = new THREE.Color(0x000000); // Fundo preto

        // Luz ambiente muito escura (soturna)
        const ambientLight = new THREE.AmbientLight(0x101010, 1.0); // (cor, intensidade)
        world2Group.add(ambientLight);

        // Luz "falsa" no teto (HemisphereLight)
        // Simula uma luz fraca vindo de cima, sem sombras (performance)
        const hemiLight = new THREE.HemisphereLight(0x404040, 0x080808, 0.5);
        world2Group.add(hemiLight);

        // 2. Geometria do Corredor
        // Comprimento de 80m (conforme solicitado), Largura 5m, Altura 4m
        const corridorLength = 80;
        const corridorWidth = 5;
        const corridorHeight = 4;

        // Chão
        const floorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.floor });
        const floorGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, 0, corridorLength / 2); // Centraliza no Z
        world2Group.add(floor);

        // Teto
        const ceilMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 }); // Teto escuro
        const ceilGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const ceil = new THREE.Mesh(ceilGeometry, ceilMaterial);
        ceil.rotation.x = Math.PI / 2;
        ceil.position.set(0, corridorHeight, corridorLength / 2);
        world2Group.add(ceil);

        // Parede Esquerda
        const wallMaterial = new THREE.MeshBasicMaterial({ map: this.textures.wall });
        const wallGeometry = new THREE.PlaneGeometry(corridorLength, corridorHeight);
        const wallLeft = new THREE.Mesh(wallGeometry, wallMaterial);
        wallLeft.rotation.y = Math.PI / 2;
        wallLeft.position.set(-corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallLeft);

        // Parede Direita
        const wallRight = new THREE.Mesh(wallGeometry, wallMaterial);
        wallRight.rotation.y = -Math.PI / 2;
        wallRight.position.set(corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallRight);

        // Parede do Fundo (Fechando o corredor)
        const endWallGeom = new THREE.PlaneGeometry(corridorWidth, corridorHeight);
        const endWall = new THREE.Mesh(endWallGeom, wallMaterial);
        endWall.position.set(0, corridorHeight / 2, corridorLength);
        world2Group.add(endWall);

        // 3. Criação das Obras de Arte (Quadros)
        // 18 obras, 9 de cada lado.
        // Espaçamento: 80m / 9 obras = ~8.8m por obra
        const spacing = corridorLength / 9;
        const frameSize = 2.0; // Quadros de 2m x 2m
        const frameHeight = this.playerHeight + 0.2; // Altura dos olhos

        // Itera sobre os dados do JSON (artworkData)
        artworkData.forEach((artwork, index) => {
            // Carrega a textura da arte (já pré-carregada pelo loader)
            const artTexture = this.textures[`art_${artwork.id}`];
            const artMaterial = new THREE.MeshBasicMaterial({ map: artTexture });

            const artGeometry = new THREE.PlaneGeometry(frameSize, frameSize);
            const artMesh = new THREE.Mesh(artGeometry, artMaterial);
            
            // Cria a "placa" de interação (hitbox)
            // É um plano invisível e maior (3x3) para facilitar a interação (forgiving hitbox)
            const plaqueGeometry = new THREE.PlaneGeometry(frameSize + 1, frameSize + 1);
            const plaqueMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const plaqueMesh = new THREE.Mesh(plaqueGeometry, plaqueMaterial);
            
            // Adiciona os dados de interação na PLACA (não na arte)
            plaqueMesh.userData = {
                interactive: true,
                type: 'artwork',
                id: artwork.id,
                title: artwork.title,
                description: artwork.description
            };

            // Posição Z (ao longo do corredor)
            // Começa em Z=10, espaçamento de 8.8m
            const zPos = 10 + (index % 9) * (spacing * 0.9);

            if (index < 9) {
                // Lado Esquerdo (primeiras 9)
                artMesh.position.set((-corridorWidth / 2) + 0.05, frameHeight, zPos);
                artMesh.rotation.y = Math.PI / 2; // Virado para o centro
                
                plaqueMesh.position.set((-corridorWidth / 2) + 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = Math.PI / 2;

            } else {
                // Lado Direito (últimas 9)
                artMesh.position.set((corridorWidth / 2) - 0.05, frameHeight, zPos);
                artMesh.rotation.y = -Math.PI / 2; // Virado para o centro
                
                plaqueMesh.position.set((corridorWidth / 2) - 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = -Math.PI / 2;
            }

            world2Group.add(artMesh);
            world2Group.add(plaqueMesh); // Adiciona a hitbox invisível
        });

        // 4. Limites de Colisão (Corredor)
        // O jogador não pode atravessar as paredes
        const collisionLimits = {
            minX: -corridorWidth / 2 + 0.5, // 0.5m de folga da parede
            maxX: corridorWidth / 2 - 0.5,
            minZ: 0.5, // Parede inicial (não existe, mas impede de voltar)
            maxZ: corridorLength - 0.5 // Parede do fundo
        };
        
        // Retorna o grupo e os limites
        return { group: world2Group, collisionLimits: collisionLimits };
    }
}
js/controls.js
JavaScript
/*
    ARQUIVO: controls.js
    DESCRIÇÃO: Gerenciador de Controles do Jogador (Input Handler).
    FUNÇÃO: Esta classe gerencia TODO o input do usuário:
    - Movimentação (WASD / Setas / D-Pad Mobile).
    - Rotação da Câmera (Mouse / Toque Mobile).
    - Ações (Tecla [E] / Botão de Ação Mobile).
    - Lógica de Colisão (limitando a posição do jogador).
*/

class PlayerControls {

    /**
     * @param {THREE.Camera} camera - A câmera do jogador.
     * @param {HTMLElement} domElement - O elemento canvas (para eventos).
     * @param {Object} settings - Configurações de velocidade e sensibilidade.
     */
    constructor(camera, domElement, settings) {
        this.camera = camera;
        this.domElement = domElement;
        this.settings = settings;

        // Referência à função de interação (definida em main.js)
        this.onInteract = () => {}; 
        
        // Estado de movimento
        this.moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        // Estado da Câmera (Mouse Look)
        this.cameraLook = {
            pitch: 0, // Rotação vertical (X)
            yaw: 0   // Rotação horizontal (Y)
        };
        
        // Propriedades de física/movimento
        this.velocity = new THREE.Vector3();
        this.direction = new THREE.Vector3();

        // Configurações do mundo atual (Cena 1 ou Cena 2)
        this.currentWorld = 1;
        this.collisionLimits = null; // Limites de colisão do mundo atual
        
        // Detecção de Mobile (baseado em 'touchstart')
        this.isMobile = 'ontouchstart' in window;
        
        // Armazena o ID do toque de movimento (para multi-toque)
        this.moveTouchId = null; 
        this.lookTouchId = null;
        this.lastLookPos = { x: 0, y: 0 };
        
        // Ajusta a sensibilidade para mobile (conforme UX finalizado)
        this.sensitivity = this.isMobile ? 
            this.settings.mobileCameraSpeed : 
            this.settings.desktopCameraSpeed;

        // Inicializa os ouvintes de eventos
        this.initListeners();
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO DOS OUVINTES DE EVENTO
    // -----------------------------------------------------------------
    initListeners() {
        if (this.isMobile) {
            // Se for mobile, inicializa os controles de toque
            this.initMobileControls();
        } else {
            // Se for desktop, inicializa o Pointer Lock (travar mouse)
            this.initPointerLock();
            // E os ouvintes de teclado
            document.addEventListener('keydown', this.onKeyDown.bind(this));
            document.addEventListener('keyup', this.onKeyUp.bind(this));
        }
    }

    // (Desktop) Configura o Pointer Lock
    initPointerLock() {
        this.domElement.addEventListener('click', () => {
            this.domElement.requestPointerLock();
        });

        // Ouve o movimento do mouse APENAS quando o mouse está travado
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === this.domElement) {
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
            } else {
                document.removeEventListener('mousemove', this.onMouseMove.bind(this));
            }
        });
    }

    // (Mobile) Configura os botões de toque
    initMobileControls() {
        // Mostra os botões de D-Pad e Ação
        document.getElementById('dpad-container').style.display = 'grid';
        document.getElementById('action-btn').style.display = 'block';

        // Ouvintes do D-Pad (touchstart = pressionar, touchend = soltar)
        this.addTouchListener('dpad-forward', 'forward');
        this.addTouchListener('dpad-backward', 'backward');
        this.addTouchListener('dpad-left', 'left');
        this.addTouchListener('dpad-right', 'right');

        // Ouvinte do Botão de Ação
        document.getElementById('action-btn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.onInteract(); // Chama a função de interação
        });
        
        // Ouvinte de Toque na Tela (para olhar ao redor)
        this.domElement.addEventListener('touchstart', this.onMobileTouchStart.bind(this));
        this.domElement.addEventListener('touchmove', this.onMobileTouchMove.bind(this));
        this.domElement.addEventListener('touchend', this.onMobileTouchEnd.bind(this));
    }

    // (Mobile) Função auxiliar para adicionar ouvintes de toque
    addTouchListener(elementId, direction) {
        const element = document.getElementById(elementId);
        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.moveState[direction] = true;
        });
        element.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.moveState[direction] = false;
        });
    }

    // -----------------------------------------------------------------
    // HANDLERS DE EVENTO (MOVIMENTO / AÇÃO)
    // -----------------------------------------------------------------

    // (Desktop) Tecla pressionada
    onKeyDown(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = true; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = true; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = true; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = true; break;
            case 'KeyE': this.onInteract(); break; // Tecla de Interação [E]
        }
    }

    // (Desktop) Tecla solta
    onKeyUp(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = false; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = false; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = false; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = false; break;
        }
    }

    // (Desktop) Movimento do mouse (Pointer Lock)
    onMouseMove(event) {
        if (document.pointerLockElement !== this.domElement) return;

        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;

        // Rotação Horizontal (Yaw) - Eixo Y
        this.cameraLook.yaw -= movementX * this.sensitivity;
        
        // Rotação Vertical (Pitch) - Eixo X
        this.cameraLook.pitch -= movementY * this.sensitivity;
        
        // Trava a rotação vertical (para não "quebrar o pescoço")
        this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
        
        // Aplica as rotações (Ordem EULER_YXZ é importante para FPS)
        this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
    }

    // (Mobile) Início do toque na tela
    onMobileTouchStart(event) {
        event.preventDefault();
        // Itera sobre os toques
        for (const touch of event.changedTouches) {
            // Se o toque for na metade direita da tela, é para "olhar"
            if (touch.clientX > window.innerWidth / 2 && this.lookTouchId === null) {
                this.lookTouchId = touch.identifier;
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;
            }
        }
    }

    // (Mobile) Movimento do toque na tela (Olhar)
    onMobileTouchMove(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se for o toque que estamos rastreando para "olhar"
            if (touch.identifier === this.lookTouchId) {
                const deltaX = touch.clientX - this.lastLookPos.x;
                const deltaY = touch.clientY - this.lastLookPos.y;

                // Salva a nova posição
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;

                // Aplica a rotação (similar ao onMouseMove)
                this.cameraLook.yaw -= deltaX * this.sensitivity;
                this.cameraLook.pitch -= deltaY * this.sensitivity;
                this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
                
                this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
            }
        }
    }

    // (Mobile) Fim do toque na tela
    onMobileTouchEnd(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se o toque que terminou era o de "olhar", para de rastrear
            if (touch.identifier === this.lookTouchId) {
                this.lookTouchId = null;
            }
        }
    }


    // -----------------------------------------------------------------
    // ATUALIZAÇÃO (LOOP PRINCIPAL) E COLISÃO
    // -----------------------------------------------------------------

    /**
     * Define os limites de colisão do mundo atual.
     * @param {number} worldId - 1 para Floresta, 2 para Corredor.
     * @param {Object} limits - O objeto de limites vindo de 'scene.js'.
     */
    setWorld(worldId, limits) {
        this.currentWorld = worldId;
        this.collisionLimits = limits;
    }
    
    /**
     * Reseta a rotação da câmera (usado na transição).
     */
    resetRotation() {
        this.cameraLook.pitch = 0;
        this.cameraLook.yaw = 0;
        this.camera.rotation.set(0, 0, 0, 'YXZ');
    }

    /**
     * Chamado a cada frame pelo 'main.js'.
     * @param {number} delta - O tempo (em segundos) desde o último frame.
     */
    update(delta) {
        // Velocidade = 1.8 m/s (conforme UX finalizado)
        const moveSpeed = this.settings.movementSpeed * delta;

        // Reseta a direção do movimento
        this.direction.z = Number(this.moveState.forward) - Number(this.moveState.backward);
        this.direction.x = Number(this.moveState.left) - Number(this.moveState.right);
        this.direction.normalize(); // Garante movimento consistente (diagonal != mais rápido)

        // Salva a posição atual para checagem de colisão
        const oldPosition = this.camera.position.clone();

        // Calcula o movimento relativo à direção que a câmera está olhando
        if (this.moveState.forward || this.moveState.backward) {
            this.camera.translateZ(-this.direction.z * moveSpeed);
        }
        if (this.moveState.left || this.moveState.right) {
            this.camera.translateX(-this.direction.x * moveSpeed);
        }

        // --- LÓGICA DE COLISÃO ---
        // Impede o jogador de sair dos limites definidos
        if (this.collisionLimits) {
            this.applyCollisions(oldPosition);
        }
        
        // Mantém a altura do jogador (impede de voar ou afundar)
        this.camera.position.y = this.settings.playerHeight;
    }

    /**
     * Verifica e aplica as colisões baseadas nos limites do mundo.
     * @param {THREE.Vector3} oldPosition - Posição antes do movimento.
     */
    applyCollisions(oldPosition) {
        const newPosition = this.camera.position;
        const limits = this.collisionLimits;

        // Lógica de Colisão para o MUNDO 1 (Floresta)
        if (this.currentWorld === 1) {
            // A lógica aqui é complexa: a estrada é larga, a trilha é estreita.
            
            // Se estiver na área da estrada (Z > 50)
            if (newPosition.z > limits.trailZStart) {
                newPosition.x = Math.max(limits.minX, Math.min(limits.maxX, newPosition.x));
            } 
            // Se estiver na área da trilha (Z <= 50)
            else {
                newPosition.x = Math.max(limits.trailMinX, Math.min(limits.trailMaxX, newPosition.x));
            }
            
            // Limites gerais Z (frente/trás)
            newPosition.z = Math.max(limits.minZ, Math.min(limits.maxZ, newPosition.z));
        
        // Lógica de Colisão para o MUNDO 2 (Corredor)
        } else if (this.currentWorld === 2) {
            // Lógica simples de "caixa"
            newPosition.x = Math.max(limits.minX, Math.min(limits.maxX, newPosition.x));
            newPosition.z = Math.max(limits.minZ, Math.min(limits.maxZ, newPosition.z));
        }

        // Aplica a posição corrigida
        this.camera.position.copy(newPosition);
    }
}
js/interaction.js
JavaScript
/*
    ARQUIVO: interaction.js
    DESCRIÇÃO: Gerenciador de Interação (Raycaster).
    FUNÇÃO: Esta classe é responsável por "atirar um raio" (Raycast)
    a partir do centro da tela (mira) para detectar com o que
    o jogador está olhando/interagindo.
*/

class InteractionHandler {

    /**
     * @param {THREE.Camera} camera - A câmera do jogador (de onde o raio sai).
     * @param {THREE.Scene} scene - A cena (onde os objetos estão).
     * @param {Function} onInteractCallback - Função em 'main.js' a ser chamada
     * quando uma interação válida ocorre.
     */
    constructor(camera, scene, onInteractCallback) {
        this.camera = camera;
        this.scene = scene;
        this.onInteractCallback = onInteractCallback;

        // O Raycaster do Three.js
        this.raycaster = new THREE.Raycaster();
        
        // Coordenadas da mira (sempre [0, 0] = centro da tela)
        this.crosshairCoords = new THREE.Vector2(0, 0);

        // Distância máxima de interação (ex: 3 metros)
        this.interactionDistance = 3.0; 

        // Armazena o objeto que está atualmente na mira
        this.currentTarget = null;
    }

    /**
     * Chamado quando o jogador pressiona [E] ou o Botão de Ação.
     * Esta é a função que efetivamente "dispara" a interação.
     */
    triggerInteraction() {
        // Verifica se há um alvo válido na mira
        if (this.currentTarget) {
            // Chama a função de callback em 'main.js'
            // e passa os dados do objeto (ex: { type: 'gothic_door' })
            this.onInteractCallback(this.currentTarget.userData);
        } else {
            // (Opcional) Tocar um som de "falha" se não houver nada
            console.log("Nenhum alvo interativo ao alcance.");
        }
    }

    /**
     * Chamado a cada frame pelo 'main.js' (ANTES do update de controles).
     * Esta função *apenas* verifica o que está na mira, mas não
     * dispara a ação.
     */
    update() {
        // 1. Atualiza o raio para sair do centro da câmera
        this.raycaster.setFromCamera(this.crosshairCoords, this.camera);

        // 2. Verifica quais objetos na cena (recursivamente) o raio atinge
        // Passamos 'this.scene.children' e 'true' para verificar os filhos
        // dos grupos (World1_Group, World2_Group).
        const intersects = this.raycaster.intersectObjects(this.scene.children, true);

        // Reseta o alvo atual
        this.currentTarget = null;

        // 3. Itera sobre os objetos atingidos
        for (const intersect of intersects) {
            
            // 4. Verifica se o objeto tem o 'userData' interativo
            // (Nós definimos isso em 'scene.js' na porta e nas placas)
            if (intersect.object.userData && intersect.object.userData.interactive === true) {
                
                // 5. Verifica se está dentro da distância permitida
                if (intersect.distance <= this.interactionDistance) {
                    
                    // Encontramos um alvo válido!
                    this.currentTarget = intersect.object;
                    
                    // (Opcional) Mudar a cor da mira para "ativa"
                    // document.getElementById('crosshair').style.color = 'red';
                    
                    // Para o loop assim que encontrar o primeiro alvo válido
                    break;
                }
            }
        }
        
        // Se o loop terminou e this.currentTarget ainda é nulo,
        // significa que não estamos olhando para nada interativo.
        if (this.currentTarget === null) {
            // (Opcional) Resetar a cor da mira para "passiva"
            // document.getElementById('crosshair').style.color = 'rgba(255, 255, 255, 0.7)';
        }
    }
}
js/main.js
JavaScript
/*
    ARQUIVO: main.js
    DESCRIÇÃO: Ponto de Entrada Principal da Aplicação (O "Maestro").
    FUNÇÃO: Este script inicializa todos os componentes (Cena, Câmera,
    Renderizador, Controles) e gerencia o "Game Loop" (o 'animate').
    Ele coordena o carregamento de assets (JSON e texturas), 
    a transição de cenas e conecta os controles à lógica de interação.
*/

// Classe principal da aplicação
class SungApp {
    
    constructor() {
        // Elementos do DOM
        this.canvas = document.getElementById('game-canvas');
        this.loadingScreen = document.getElementById('loading-screen');
        this.loadingText = document.querySelector('.loading-text');
        this.transitionFade = document.getElementById('transition-fade');
        this.uiElements = [
            document.getElementById('crosshair'),
            document.getElementById('logo'),
            document.getElementById('copyright')
        ];

        // Componentes do Three.js
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true // Suavização de serrilhado
        });
        this.clock = new THREE.Clock(); // Relógio para o 'delta time'

        // Componentes do Jogo
        this.loader = null;
        this.controls = null;
        this.interaction = null;
        this.worldFactory = null;
        
        // Dados (carregados do JSON)
        this.artworkData = [];

        // Grupos de Cena (para fácil adição/remoção)
        this.world1_Group = null;
        this.world2_Group = null;

        // Estado do Jogo
        this.isLoaded = false;
        this.isTransitioning = false;
        this.currentWorldId = 1; // Começa no Mundo 1
        
        // Configurações (conforme UX finalizado)
        this.settings = {
            movementSpeed: 1.8,         // 1.8 m/s
            desktopCameraSpeed: 0.0008, // Sensibilidade Desktop
            mobileCameraSpeed: 0.0025,  // Sensibilidade Mobile
            playerHeight: 1.6           // Altura dos olhos do jogador
        };
        
        // Referência 'bind' para o loop de animação
        this.animate = this.animate.bind(this);
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Método principal de inicialização (agora é assíncrono).
     */
    async init() {
        console.log("Iniciando SungApp...");

        try {
            // 1. Carregar os dados das artes primeiro
            await this.loadArtworkData();
            console.log("Dados de arte (arts.json) carregados.");

            // 2. Configurar o Renderizador
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limita o pixel ratio por performance
            this.renderer.outputEncoding = THREE.sRGBEncoding;

            // 3. Configurar a Posição Inicial da Câmera
            // (Z > 55, conforme requisito da Cena 1)
            this.camera.position.set(0, this.settings.playerHeight, 60);

            // 4. Inicializar o Loader de Assets (Texturas)
            this.loader = new AssetLoader(
                (progress) => {
                    // Função 'onProgress'
                    this.loadingText.textContent = `Carregando... ${progress.toFixed(0)}%`;
                },
                () => {
                    // Função 'onLoad' (Tudo carregado)
                    this.startExperience();
                }
            );

            // 5. Definir quais texturas carregar
            // (Nomes vêm do 'checklist.txt' e 'scene.js')
            const sceneTextures = [
                // Texturas principais (suas imagens)
                { name: 'rodovia', path: 'assets/images/rodovia.png', repeat: [3, 10] },
                { name: 'porta', path: 'assets/images/porta.png' },
                
                // Texturas auxiliares
                { name: 'path', path: 'assets/images/path_texture.jpg', repeat: [1, 10] },
                { name: 'arvore', path: 'assets/images/arvore.png' },
                { name: 'crystalGlow', path: 'assets/images/crystal_glow.png' },
                
                // Texturas do Corredor
                { name: 'wall', path: 'assets/images/wall_texture.jpg', repeat: [20, 2] },
                { name: 'floor', path: 'assets/images/floor_texture.jpg', repeat: [2, 20] }
            ];
            
            // Adiciona as 18 artes (carregadas do JSON) à lista de carregamento
            const artworkTextures = this.artworkData.map(art => ({
                name: `art_${art.id}`, // ex: 'art_1'
                path: art.image // ex: 'img/tattoo_01.png'
            }));
            
            // Carrega TUDO
            const allTexturesToLoad = [...sceneTextures, ...artworkTextures];
            const loadedTextures = this.loader.loadTextures(allTexturesToLoad);
            
            // 6. Inicializar a "Fábrica" de Mundos com as texturas
            this.worldFactory = new WorldSceneFactory(loadedTextures);

            // 7. Ouvinte de redimensionamento da janela
            window.addEventListener('resize', this.onWindowResize.bind(this));
        
        } catch (error) {
            console.error("Falha fatal na inicialização:", error);
            this.loadingText.textContent = "Erro ao carregar. Verifique o console.";
            this.loadingText.style.color = "red";
        }
    }
    
    /**
     * Carrega os dados do arquivo /data/arts.json
     * (Precisa de um servidor local - ver como_rodar.txt)
     */
    async loadArtworkData() {
        try {
            const response = await fetch('data/arts.json');
            if (!response.ok) {
                throw new Error(`Erro HTTP! Status: ${response.status}`);
            }
            this.artworkData = await response.json();
            
            // Verifica se temos 18 artes
            if (this.artworkData.length !== 18) {
                console.warn(`Aviso: 'arts.json' contém ${this.artworkData.length} artes. O corredor foi projetado para 18.`);
            }
            
        } catch (error) {
            console.error("Não foi possível carregar 'data/arts.json':", error);
            // Re-lança o erro para o 'init' principal tratar
            throw error; 
        }
    }

    /**
     * Chamado quando o Loader termina (onLoad).
     */
    startExperience() {
        console.log("Assets carregados. Iniciando a experiência.");
        this.isLoaded = true;
        
        // 1. Construir o Mundo 1 (Floresta)
        const world1Data = this.worldFactory.createWorld1(this.scene);
        this.world1_Group = world1Data.group;
        this.scene.add(this.world1_Group);

        // 2. Inicializar Controles
        this.controls = new PlayerControls(this.camera, this.canvas, this.settings);
        // Define os limites de colisão para o mundo 1
        this.controls.setWorld(1, world1Data.collisionLimits);
        
        // 3. Inicializar Interação
        this.interaction = new InteractionHandler(
            this.camera, 
            this.scene, 
            this.handleInteraction.bind(this) // Callback
        );
        
        // 4. Conectar Controles e Interação
        // Diz ao 'controls' qual função chamar quando [E] é pressionado
        this.controls.onInteract = () => {
            this.interaction.triggerInteraction();
        };

        // 5. Esconder a tela de Loading e mostrar a UI do Jogo
        this.loadingScreen.style.opacity = '0';
        setTimeout(() => {
            this.loadingScreen.style.display = 'none';
        }, 500); // 0.5s (duração da transição do CSS)

        // Mostra a UI (Mira, Logo, etc.)
        this.uiElements.forEach(el => el.style.display = 'block');
        
        // 6. Iniciar o Loop de Animação
        this.animate();
    }
    
    // -----------------------------------------------------------------
    // LOOP DE ANIMAÇÃO (GAME LOOP)
    // -----------------------------------------------------------------

    /**
     * O Loop Principal (requestAnimationFrame).
     */
    animate() {
        // Pede ao navegador para chamar 'animate' no próximo frame
        requestAnimationFrame(this.animate);

        // Se não carregou ou está em transição, não faz nada
        if (!this.isLoaded || this.isTransitioning) {
            return;
        }

        // Pega o tempo delta (diferença do último frame)
        const delta = this.clock.getDelta();

        // 1. Atualiza o handler de interação (verifica o que está na mira)
        this.interaction.update();
        
        // 2. Atualiza os controles do jogador (movimento, colisão)
        this.controls.update(delta);

        // 3. Renderiza a cena 3D
        this.renderer.render(this.scene, this.camera);
    }
    
    // -----------------------------------------------------------------
    // LÓGICA DE TRANSIÇÃO E INTERAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Callback chamado pelo 'InteractionHandler' quando [E] é pressionado
     * em um alvo válido.
     * @param {Object} userData - Os dados do objeto (ex: { type: 'gothic_door' })
     */
    handleInteraction(userData) {
        console.log("Interação disparada:", userData);
        
        // Verifica se é a porta gótica E se estamos no mundo 1
        if (userData.type === 'gothic_door' && this.currentWorldId === 1) {
            this.triggerSceneTransition();
        }
        
        // Lógica para mostrar info da arte no Mundo 2
        if (userData.type === 'artwork' && this.currentWorldId === 2) {
            console.log(`Clicou na Arte: ${userData.title}`);
            // (Ação Futura): Abrir um modal com `userData.title` e `userData.description`
            alert(`Arte: ${userData.title}\nDescrição: ${userData.description}`);
        }
    }

    /**
     * Executa o "Theater Effect" (Transição da Cena 1 para a Cena 2).
     */
    triggerSceneTransition() {
        if (this.isTransitioning) return; // Previne transições duplas
        
        console.log("Iniciando transição de cena...");
        this.isTransitioning = true; // Pausa o 'animate' loop

        // 1. Fade In Rápido (0.5s) para Branco
        this.transitionFade.style.transition = 'opacity 0.5s ease-in';
        this.transitionFade.style.opacity = '1';

        // 2. Atraso de 500ms (enquanto a tela está branca)
        setTimeout(() => {
            // --- O TELEPORTE (acontece instantaneamente) ---
            
            // a. Remove a geometria do Mundo 1
            this.scene.remove(this.world1_Group);
            
            // b. Constrói e adiciona a geometria do Mundo 2
            // Passa os dados do JSON (this.artworkData) para a fábrica
            const world2Data = this.worldFactory.createWorld2(this.scene, this.artworkData);
            this.world2_Group = world2Data.group;
            this.scene.add(this.world2_Group);

            // c. Teleporta o Jogador (Z=10, conforme requisito)
            this.camera.position.set(0, this.settings.playerHeight, 10);
            
            // d. Reseta a Rotação da Câmera (olhar reto)
            this.controls.resetRotation();

            // e. Atualiza os controles para os limites de colisão do Mundo 2
            this.controls.setWorld(2, world2Data.collisionLimits);
            this.currentWorldId = 2;
            
            // --- FIM DO TELEPORTE ---

            // 3. Fade Out Lento (1.5s) do Branco (olhos se ajustando)
            this.transitionFade.style.transition = 'opacity 1.5s ease-out';
            this.transitionFade.style.opacity = '0';
            
            // 4. Atraso de 1500ms (espera o fade out terminar)
            setTimeout(() => {
                this.isTransitioning = false; // Retoma o 'animate' loop
                console.log("Transição completa. Mundo 2 carregado.");
            }, 1500);

        }, 500); // Fim do setTimeout do Fade In
    }

    // -----------------------------------------------------------------
    // UTILITÁRIOS
    // -----------------------------------------------------------------

    /**
     * Chamado quando a janela do navegador muda de tamanho.
     */
    onWindowResize() {
        // Atualiza as proporções da câmera
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();

        // Atualiza o tamanho do renderizador
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}

// -----------------------------------------------------------------
// PONTO DE ENTRADA
// -----------------------------------------------------------------

// Quando o DOM (HTML) estiver pronto, cria e inicializa a aplicação.
window.addEventListener('DOMContentLoaded', () => {
    const app = new SungApp();
    app.init();
});
olha como esta

Obrigado por enviar o vídeo. Consegui ver exatamente o que está acontecendo e posso te ajudar a corrigir.

Você está vendo a geometria (as 'caixas' cinzas) do Corredor (Mundo 2), mas nenhuma das texturas (paredes, chão) está carregando. Além disso, o logo aparece como texto (Sung Studios Logo), o que significa que a imagem belial.png também não foi encontrada.

Mais importante: O projeto está começando no Mundo 2 (O Corredor), em vez de começar no Mundo 1 (A Estrada/Floresta), como pedia o prompt.

Aqui estão os 3 problemas e como corrigi-los, com base na sua captura de tela (image_bcc321.png):

1. Problema: Texturas e Logo Quebrados (Caminho Errado)
Causa: Olhando a sua captura de tela, você colocou as texturas (como rodovia.png, porta.png) diretamente dentro da pasta /assets/. O código que eu escrevi esperava que elas estivessem dentro de uma subpasta /assets/images/.

Solução: Vamos corrigir os caminhos no código para combinar com a sua estrutura de pastas.

A. Corrija js/main.js (para as texturas do mundo)
Abra js/main.js, vá até a função init(), encontre a constante sceneTextures e remova images/ de todos os caminhos.

Mude isto:

JavaScript
            // 5. Definir quais texturas carregar
            const sceneTextures = [
                // Texturas principais (suas imagens)
                { name: 'rodovia', path: 'assets/images/rodovia.png', repeat: [3, 10] },
                { name: 'porta', path: 'assets/images/porta.png' },
                
                // Texturas auxiliares
                { name: 'path', path: 'assets/images/path_texture.jpg', repeat: [1, 10] },
                { name: 'arvore', path: 'assets/images/arvore.png' },
                { name: 'crystalGlow', path: 'assets/images/crystal_glow.png' },
                
                // Texturas do Corredor
                { name: 'wall', path: 'assets/images/wall_texture.jpg', repeat: [20, 2] },
                { name: 'floor', path: 'assets/images/floor_texture.jpg', repeat: [2, 20] }
            ];
Para isto (removendo images/):

JavaScript
            // 5. Definir quais texturas carregar
            const sceneTextures = [
                // Texturas principais (suas imagens)
                { name: 'rodovia', path: 'assets/rodovia.png', repeat: [3, 10] },
                { name: 'porta', path: 'assets/porta.png' },
                
                // Texturas auxiliares
                { name: 'path', path: 'assets/path_texture.jpg', repeat: [1, 10] },
                { name: 'arvore', path: 'assets/arvore.png' },
                { name: 'crystalGlow', path: 'assets/crystal_glow.png' },
                
                // Texturas do Corredor
                { name: 'wall', path: 'assets/wall_texture.jpg', repeat: [20, 2] },
                { name: 'floor', path: 'assets/floor_texture.jpg', repeat: [2, 20] }
            ];
B. Corrija index.html (para o logo)
Abra index.html, encontre a div com id="logo" e remova images/ do caminho da imagem belial.png.

Mude isto:

HTML
    <div id="logo">
        <img src="assets/images/belial.png" alt="Sung Studios Logo">
    </div>
Para isto:

HTML
    <div id="logo">
        <img src="assets/belial.png" alt="Sung Studios Logo">
    </div>
2. Problema: Pasta CSS (Letra Maiúscula)
Causa: Na sua captura de tela, a pasta de estilos se chama CSS (em maiúsculo). O index.html está linkando para css/ (minúsculo). Em alguns servidores, isso falha.

Solução: Corrija o link no index.html para CSS.

Mude isto:

HTML
    <link rel="stylesheet" href="css/styles.css">
Para isto:

HTML
    <link rel="stylesheet" href="CSS/styles.css">
3. Problema: Começando no Mundo 2 (Corredor)
Causa: O vídeo mostra o jogo começando direto no corredor (Mundo 2). O código original que eu enviei começa no Mundo 1 por padrão. Isso significa que algo foi modificado no js/main.js para pular o Mundo 1.

Solução: Verifique se sua função startExperience() no js/main.js está correta. Ela deve carregar createWorld1, não createWorld2.

Verifique se a sua função startExperience está assim:

JavaScript
    /**
     * Chamado quando o Loader termina (onLoad).
     */
    startExperience() {
        console.log("Assets carregados. Iniciando a experiência.");
        this.isLoaded = true;
        
        // 1. Construir o Mundo 1 (Floresta)
        // ESSA LINHA É A MAIS IMPORTANTE:
        const world1Data = this.worldFactory.createWorld1(this.scene);
        this.world1_Group = world1Data.group;
        this.scene.add(this.world1_Group);

        // 2. Inicializar Controles
        this.controls = new PlayerControls(this.camera, this.canvas, this.settings);
        
        // Define os limites de colisão para o mundo 1
        this.controls.setWorld(1, world1Data.collisionLimits);
        
        // 3. Inicializar Interação
        this.interaction = new InteractionHandler(
            this.camera, 
            this.scene, 
            this.handleInteraction.bind(this) // Callback
        );
        
        // ... (resto do código) ...
    }
Se o seu código estiver chamando createWorld2 aqui, este é o erro. Ele deve chamar createWorld1. A posição inicial da câmera (Z=60 na função init()) também está correta para o Mundo 1.

Resumo das Ações
Corrija os caminhos das texturas em js/main.js (remova images/).

Corrija o caminho do logo em index.html (remova images/).

Corrija o caminho do CSS em index.html (mude css/ para CSS/).

Verifique se js/main.js está carregando createWorld1 na função startExperience.

Depois de fazer essas correções, o projeto deve carregar o Mundo 1 (a floresta) com todas as texturas funcionando.

sao os erros no console

Obrigado pelo novo vídeo! O console de erros é exatamente o que eu precisava ver.

O diagnóstico é muito claro. O console está cheio de erros 404 (Not Found). Isso significa que os caminhos no código não batem com os nomes das suas pastas e arquivos.

Vamos corrigir isso agora.

O Erro Principal
Veja o que o console diz:

O código está procurando: GET http://127.0.0.1:5503/assets/images/rodovia.png

Mas a sua estrutura de pastas (da imagem image_bcc321.png) é: assets/rodovia.png (sem a pasta images/ no meio).

Você está executando o código original que eu te enviei, mas ele não reflete a sua estrutura de pastas. Você precisa aplicar as correções que eu sugeri na resposta anterior.

Vamos fazê-las passo a passo:

Correção 1: Arquivo index.html (Corrigir CSS e Logo)
Abra o seu arquivo index.html.

Mude isto:

HTML
    <link rel="stylesheet" href="css/styles.css">
    
    ...
    
    <div id="logo">
        <img src="assets/images/belial.png" alt="Sung Studios Logo">
    </div>
Para isto (corrigindo CSS/ para maiúsculo e removendo images/ do logo):

HTML
    <link rel="stylesheet" href="CSS/styles.css">
    
    ...
    
    <div id="logo">
        <img src="assets/belial.png" alt="Sung Studios Logo">
    </div>
Correção 2: Arquivo js/main.js (Corrigir TODAS as texturas)
Abra o seu arquivo js/main.js, vá até a função init() e encontre a constante sceneTextures.

Mude isto:

JavaScript
            // 5. Definir quais texturas carregar
            const sceneTextures = [
                // Texturas principais (suas imagens)
                { name: 'rodovia', path: 'assets/images/rodovia.png', repeat: [3, 10] },
                { name: 'porta', path: 'assets/images/porta.png' },
                
                // Texturas auxiliares
                { name: 'path', path: 'assets/images/path_texture.jpg', repeat: [1, 10] },
                { name: 'arvore', path: 'assets/images/arvore.png' },
                { name: 'crystalGlow', path: 'assets/images/crystal_glow.png' },
                
                // Texturas do Corredor
                { name: 'wall', path: 'assets/images/wall_texture.jpg', repeat: [20, 2] },
                { name: 'floor', path: 'assets/images/floor_texture.jpg', repeat: [2, 20] }
            ];
Para isto (removendo images/ de TODOS os caminhos):

JavaScript
            // 5. Definir quais texturas carregar
            const sceneTextures = [
                // Texturas principais (suas imagens)
                { name: 'rodovia', path: 'assets/rodovia.png', repeat: [3, 10] },
                { name: 'porta', path: 'assets/porta.png' },
                
                // Texturas auxiliares
                { name: 'path', path: 'assets/path_texture.jpg', repeat: [1, 10] },
                { name: 'arvore', path: 'assets/arvore.png' },
                { name: 'crystalGlow', path: 'assets/crystal_glow.png' },
                
                // Texturas do Corredor
                { name: 'wall', path: 'assets/wall_texture.jpg', repeat: [20, 2] },
                { name: 'floor', path: 'assets/floor_texture.jpg', repeat: [2, 20] }
            ];
Correção 3: Erros nas Imagens de Tatuagem (Pasta /img/)
O console também mostra erros 404 (Not Found) para:

GET http://127.0.0.1:5503/img/tattoo_01.png

GET http://127.0.0.1:5503/img/tattoo_02.png

etc...

O caminho no data/arts.json ("image": "img/tattoo_01.png") está correto de acordo com sua estrutura de pastas.

Este erro 404 significa uma coisa simples: Os arquivos de imagem não estão dentro da sua pasta /img/.

Solução:

Encontre as suas 18 imagens de tatuagem.

Copie todas elas para dentro da pasta /img/.

Verifique se os nomes estão corretos: tattoo_01.png, tattoo_02.png, tattoo_03.png, etc., exatamente como está no data/arts.json.

Erro Final (que será corrigido)
No final do vídeo (00:37), você vê o erro: THREE.Material: 'map' parameter is undefined.

Este erro é apenas um sintoma dos erros 404. Ele acontece porque o loader.js falhou em carregar a textura (ex: assets/images/rodovia.png), então ele passou undefined para o material. O Three.js reclama que o "map" (mapa de textura) está indefinido.

Assim que você corrigir os caminhos (Correção 1 e 2) e adicionar as imagens na pasta /img/ (Correção 3), todos os erros 404 e este erro THREE.Material vão desaparecer.

ata pra colocar as texturas precisa de img ?

pq ai nos temos q criar

Sim, exatamente!

Você entendeu perfeitamente. Um "mapa de textura" (ou map no erro do Three.js) é o arquivo de imagem (.png ou .jpg) que o código usa para "pintar" ou "vestir" os objetos 3D.

O código que escrevemos é apenas o "esqueleto" (a geometria 3D, que são aqueles blocos cinzas que você viu). As imagens de textura são a "pele".

Os erros 404 (Not Found) que você vê no console significam duas coisas:

As imagens do cenário (floresta, paredes): O código está procurando por elas no lugar errado. Ele procura em assets/images/rodovia.png, mas o seu arquivo está em assets/rodovia.png.

As imagens da galeria (tatuagens): O código está procurando por img/tattoo_01.png, img/tattoo_02.png, etc., mas esses arquivos de imagem ainda não existem lá.

O que você precisa criar/adicionar
Você precisa garantir que todos os arquivos de imagem listados no checklist.txt realmente existam nas pastas corretas.

1. Pasta /assets/ (Texturas do Cenário)
Você precisa criar ou encontrar imagens para estes arquivos e colocá-los na pasta /assets/:

rodovia.png (Você já tem - é a imagem que você me enviou)

porta.png (Você já tem - é a imagem que você me enviou)

belial.png (A imagem do seu logo "Sung")

arvore.png (Uma imagem de árvore com fundo transparente)

path_texture.jpg (Uma imagem de chão de terra)

wall_texture.jpg (Uma imagem de textura de parede para o corredor)

floor_texture.jpg (Uma imagem de textura de chão para o corredor)

crystal_glow.png (Uma imagem de um brilho ou faísca, com fundo transparente)

2. Pasta /img/ (Imagens da Galeria)
Você precisa criar e colocar suas 18 imagens de tatuagem aqui:

tattoo_01.png

tattoo_02.png

tattoo_03.png

...até tattoo_18.png

Próximos Passos (A Ordem Correta)
Crie e Adicione as Imagens: Coloque todos os arquivos de imagem listados acima nas pastas corretas (/assets/ e /img/). Você pode usar imagens temporárias (placeholders) por enquanto, só para fazer o código funcionar.

Aplique as Correções de Código: Depois que as imagens estiverem no lugar, faça as correções de código que eu passei na resposta anterior (corrigir os caminhos no index.html e no js/main.js para remover o /images/ e corrigir o CSS/).

Quando você fizer essas duas coisas (adicionar as imagens E corrigir os caminhos no código), os erros 404 vão desaparecer e o mundo 3D aparecerá com as texturas corretas.

Você precisa criar ou encontrar imagens para estes arquivos e colocá-los na pasta /assets/:



rodovia.png (Você já tem - é a imagem que você me enviou)

porta.png (Você já tem - é a imagem que você me enviou)

belial.png (A imagem do seu logo "Sung")

arvore.png (Uma imagem de árvore com fundo transparente)

path_texture.jpg (Uma imagem de chão de terra)

wall_texture.jpg (Uma imagem de textura de parede para o corredor)

floor_texture.jpg (Uma imagem de textura de chão para o corredor)

crystal_glow.png (Uma imagem de um brilho ou faísca, com fundo transparente)

onde eu posso fazer isso

Ótima pergunta. Essa é a parte de "asset pipeline" (produção de assets) do projeto.

Você tem duas opções: CRIAR do zero ou ENCONTRAR imagens prontas. Como você é um desenvolvedor focado no código, o mais rápido é ENCONTRAR texturas prontas e CRIAR apenas o que for muito específico (como o logo).

Aqui estão os melhores lugares para conseguir cada item, com foco em opções gratuitas e de alta qualidade.

Categoria 1: Onde ENCONTRAR Texturas (Grátis)
Para path_texture.jpg, wall_texture.jpg, floor_texture.jpg e arvore.png.

O segredo aqui é procurar por texturas "seamless" ou "tileable" (que se repetem perfeitamente, sem emendas visíveis).

AmbientCG (ambientcg.com)

O que é: O melhor site para texturas PBR (Physically Based Rendering) 100% gratuitas (domínio público, CC0).

Como usar:

Procure por "rock" (pedra), "wall" (parede), "dirt" (terra) ou "floor" (chão).

Baixe a versão 1K ou 2K (JPG).

O arquivo ZIP virá com várias imagens (ex: Rock030_1K_Color.jpg, Rock030_1K_Normal.jpg, etc.).

Você só precisa da imagem _Color.jpg ou _Albedo.jpg. Renomeie ela para wall_texture.jpg ou floor_texture.jpg e coloque na pasta /assets/.

Ideal para: wall_texture.jpg, floor_texture.jpg, path_texture.jpg.

Poly Haven (polyhaven.com)

O que é: Similar ao AmbientCG, qualidade de cinema, 100% gratuito.

Como usar: Vá para a seção "Textures". O processo é o mesmo do AmbientCG. Procure o mapa de "Diffuse" (é o mesmo que "Color").

Ideal para: wall_texture.jpg, floor_texture.jpg, path_texture.jpg.

Pixabay (pixabay.com)

O que é: Banco de imagens gratuitas.

Como usar:

Para arvore.png: Pesquise por "tree png" ou "dead tree transparent". Você encontrará imagens de árvores já com fundo transparente.

Para path_texture.jpg: Você pode pesquisar por "dirt path texture".

Ideal para: arvore.png (principalmente).

Categoria 2: Onde CRIAR Imagens (Grátis)
Para belial.png (logo) e crystal_glow.png (efeito de brilho).

Canva (canva.com)

O que é: Ferramenta de design online super fácil de usar, com um ótimo plano gratuito.

Como usar para belial.png (Logo):

Crie um design novo (ex: 500x500 pixels).

Clique em "Texto" e adicione "Sung".

Procure uma fonte gótica ou "cinematic" (como a fonte "Cinzel", que está no Canva).

Quando estiver pronto, clique em "Baixar" (Download) e escolha "PNG".

Importante: Marque a opção "Fundo transparente" (Transparent background).

Ideal para: belial.png (O jeito mais fácil de fazer um logo).

Photopea (photopea.com)

O que é: Um clone do Photoshop que roda 100% no seu navegador. É gratuito.

Como usar para crystal_glow.png (Brilho):

Acesse photopea.com.

Vá em Arquivo > Novo. Crie um arquivo pequeno, como 256 x 256 pixels.

Na barra lateral, selecione a ferramenta Pincel (Brush Tool, tecla B).

No topo, clique na bolinha do pincel e defina a Dureza (Hardness) para 0% (para ter uma borda suave).

Escolha uma cor (ex: azul claro ou branco).

Clique uma ou duas vezes no centro da tela. Você terá um brilho suave.

Na janela de "Camadas" (Layers) à direita, clique no ícone do olho ao lado de "Background" para esconder o fundo.

Vá em Arquivo > Exportar como > PNG. Salve como crystal_glow.png.

Ideal para: crystal_glow.png.

GIMP (gimp.org)

O que é: O equivalente gratuito e de código aberto do Photoshop (precisa baixar e instalar).

Como usar: É uma ferramenta profissional. Você pode usá-lo para criar o logo e o brilho da mesma forma que o Photopea, mas é mais complexo.

Ideal para: belial.png e crystal_glow.png, se você já tiver alguma experiência com edição de imagem.

Minha Recomendação (O Caminho mais Rápido)
Texturas de Chão/Parede/Caminho: Vá ao AmbientCG.

Procure "stone wall" -> baixe o _Color.jpg -> renomeie para wall_texture.jpg.

Procure "stone floor" -> baixe o _Color.jpg -> renomeie para floor_texture.jpg.

Procure "dirt" -> baixe o _Color.jpg -> renomeie para path_texture.jpg.

Árvore: Vá ao Pixabay.

Procure "dead tree png" -> baixe uma com fundo transparente -> renomeie para arvore.png.

Logo: Vá ao Canva.

Crie "Sung" com uma fonte gótica, baixe como PNG com fundo transparente -> renomeie para belial.png.

Brilho: Vá ao Photopea.

Faça o tutorial rápido de 8 passos que eu listei acima -> salve como crystal_glow.png.

ta o belial eu ja tenho

agr nos precisamos das texturas das arvores

da porta da rodovia da parede de arvores

do cristal luminoso

do chao de terra e umas rochas

OK, vamos lá. Organização é tudo.

Primeiro, vamos esclarecer sua lista:

belial.png (Logo): OK. Você já tem.

rodovia.png (Textura da Rodovia): OK. Você já me enviou este arquivo (rodovia .png).

porta.png (Textura da Porta): OK. Você já me enviou este arquivo (porta.png).

parede de arvores: Isto não é um arquivo de textura. Este é o efeito que criamos no js/scene.js ao colocar muitas imagens de arvore.png juntas. Nós já fizemos isso no código.

crystal_glow.png (Cristal Luminoso): FALTANDO. Precisamos encontrar.

chao de terra (para a trilha): FALTANDO. (Arquivo: path_texture.jpg)

umas rochas: NOVO ITEM. (Arquivo: rock.png)

Texturas do Corredor: FALTANDO. (Arquivos: wall_texture.jpg e floor_texture.jpg)

Links para Baixar as Texturas Faltantes
Aqui estão os links para você baixar todas as imagens que faltam. Todos são de sites gratuitos (CCO - Domínio Público) que eu encontrei.

IMPORTANTE: Em sites como o AmbientCG, baixe a versão JPG de 1K ou 2K e pegue apenas o arquivo _Color.jpg (ou _Diffuse.jpg) do ZIP.

arvore.png (Árvore com fundo transparente)

O que fazer: Escolha uma árvore morta/sombria desta lista.

Link de Busca: https://www.rawpixel.com/search/dead%20tree%20png%20transparent

Nome do Arquivo: arvore.png

path_texture.jpg (Chão de Terra)

O que fazer: Escolha uma textura de terra escura ou lama. A Ground037 ou Dirt007 são boas opções.

Link de Busca: https://ambientcg.com/list?q=dirt

Nome do Arquivo: path_texture.jpg

rock.png (Rochas com fundo transparente)

O que fazer: Escolha algumas pedras que combinem com o tema (ex: "moss covered rock").

Link de Busca: https://www.rawpixel.com/search/rock%20png%20transparent

Nome do Arquivo: rock.png (ou rock_01.png, rock_02.png, etc.)

crystal_glow.png (Brilho do Cristal)

O que fazer: Escolha um brilho (flare) azulado ou branco.

Link de Busca: https://pngtree.com/so/Blue-Glow

Nome do Arquivo: crystal_glow.png

wall_texture.jpg (Parede do Corredor)

O que fazer: Recomendo uma pedra escura para o corredor. Rock030 é uma ótima opção gótica.

Link de Busca: https://ambientcg.com/view?id=Rock030

Nome do Arquivo: wall_texture.jpg

floor_texture.jpg (Chão do Corredor)

O que fazer: Um chão de pedra escura (cobblestone) ficará perfeito.

Link de Busca: https://ambientcg.com/view?id=PavingStones070

Nome do Arquivo: floor_texture.jpg

Código Atualizado para Incluir as Rochas
Depois de baixar todas essas imagens e colocá-las na sua pasta /assets/, você precisa atualizar o js/main.js para carregar a nova rocha e o js/scene.js para colocá-la no mundo.

1. js/main.js (ATUALIZADO)
Adicione rock.png à lista sceneTextures dentro da função init().

JavaScript
/*
    ARQUIVO: main.js
    DESCRIÇÃO: Ponto de Entrada Principal da Aplicação (O "Maestro").
    FUNÇÃO: Este script inicializa todos os componentes (Cena, Câmera,
    Renderizador, Controles) e gerencia o "Game Loop" (o 'animate').
    Ele coordena o carregamento de assets (JSON e texturas), 
    a transição de cenas e conecta os controles à lógica de interação.
*/

// Classe principal da aplicação
class SungApp {
    
    constructor() {
        // Elementos do DOM
        this.canvas = document.getElementById('game-canvas');
        this.loadingScreen = document.getElementById('loading-screen');
        this.loadingText = document.querySelector('.loading-text');
        this.transitionFade = document.getElementById('transition-fade');
        this.uiElements = [
            document.getElementById('crosshair'),
            document.getElementById('logo'),
            document.getElementById('copyright')
        ];

        // Componentes do Three.js
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true // Suavização de serrilhado
        });
        this.clock = new THREE.Clock(); // Relógio para o 'delta time'

        // Componentes do Jogo
        this.loader = null;
        this.controls = null;
        this.interaction = null;
        this.worldFactory = null;
        
        // Dados (carregados do JSON)
        this.artworkData = [];

        // Grupos de Cena (para fácil adição/remoção)
        this.world1_Group = null;
        this.world2_Group = null;

        // Estado do Jogo
        this.isLoaded = false;
        this.isTransitioning = false;
        this.currentWorldId = 1; // Começa no Mundo 1
        
        // Configurações (conforme UX finalizado)
        this.settings = {
            movementSpeed: 1.8,         // 1.8 m/s
            desktopCameraSpeed: 0.0008, // Sensibilidade Desktop
            mobileCameraSpeed: 0.0025,  // Sensibilidade Mobile
            playerHeight: 1.6           // Altura dos olhos do jogador
        };
        
        // Referência 'bind' para o loop de animação
        this.animate = this.animate.bind(this);
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Método principal de inicialização (agora é assíncrono).
     */
    async init() {
        console.log("Iniciando SungApp...");

        try {
            // 1. Carregar os dados das artes primeiro
            await this.loadArtworkData();
            console.log("Dados de arte (arts.json) carregados.");

            // 2. Configurar o Renderizador
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limita o pixel ratio por performance
            this.renderer.outputEncoding = THREE.sRGBEncoding;

            // 3. Configurar a Posição Inicial da Câmera
            // (Z > 55, conforme requisito da Cena 1)
            this.camera.position.set(0, this.settings.playerHeight, 60);

            // 4. Inicializar o Loader de Assets (Texturas)
            this.loader = new AssetLoader(
                (progress) => {
                    // Função 'onProgress'
                    this.loadingText.textContent = `Carregando... ${progress.toFixed(0)}%`;
                },
                () => {
                    // Função 'onLoad' (Tudo carregado)
                    this.startExperience();
                }
            );

            // 5. Definir quais texturas carregar
            const sceneTextures = [
                // Texturas principais (suas imagens)
                { name: 'rodovia', path: 'assets/rodovia.png', repeat: [3, 10] },
                { name: 'porta', path: 'assets/porta.png' },
                
                // Texturas auxiliares
                { name: 'path', path: 'assets/path_texture.jpg', repeat: [1, 10] },
                { name: 'arvore', path: 'assets/arvore.png' },
                { name: 'crystalGlow', path: 'assets/crystal_glow.png' },
                { name: 'rock', path: 'assets/rock.png' }, // <-- NOVA ROCHA AQUI
                
                // Texturas do Corredor
                { name: 'wall', path: 'assets/wall_texture.jpg', repeat: [20, 2] },
                { name: 'floor', path: 'assets/floor_texture.jpg', repeat: [2, 20] }
            ];
            
            // Adiciona as 18 artes (carregadas do JSON) à lista de carregamento
            const artworkTextures = this.artworkData.map(art => ({
                name: `art_${art.id}`, // ex: 'art_1'
                path: art.image // ex: 'img/tattoo_01.png'
            }));
            
            // Carrega TUDO
            const allTexturesToLoad = [...sceneTextures, ...artworkTextures];
            const loadedTextures = this.loader.loadTextures(allTexturesToLoad);
            
            // 6. Inicializar a "Fábrica" de Mundos com as texturas
            this.worldFactory = new WorldSceneFactory(loadedTextures);

            // 7. Ouvinte de redimensionamento da janela
            window.addEventListener('resize', this.onWindowResize.bind(this));
        
        } catch (error) {
            console.error("Falha fatal na inicialização:", error);
            this.loadingText.textContent = "Erro ao carregar. Verifique o console.";
            this.loadingText.style.color = "red";
        }
    }
    
    /**
     * Carrega os dados do arquivo /data/arts.json
     * (Precisa de um servidor local - ver como_rodar.txt)
     */
    async loadArtworkData() {
        try {
            const response = await fetch('data/arts.json');
            if (!response.ok) {
                throw new Error(`Erro HTTP! Status: ${response.status}`);
            }
            this.artworkData = await response.json();
            
            // Verifica se temos 18 artes
            if (this.artworkData.length !== 18) {
                console.warn(`Aviso: 'arts.json' contém ${this.artworkData.length} artes. O corredor foi projetado para 18.`);
            }
            
        } catch (error) {
            console.error("Não foi possível carregar 'data/arts.json':", error);
            // Re-lança o erro para o 'init' principal tratar
            throw error; 
        }
    }

    /**
     * Chamado quando o Loader termina (onLoad).
     */
    startExperience() {
        console.log("Assets carregados. Iniciando a experiência.");
        this.isLoaded = true;
        
        // 1. Construir o Mundo 1 (Floresta)
        const world1Data = this.worldFactory.createWorld1(this.scene);
        this.world1_Group = world1Data.group;
        this.scene.add(this.world1_Group);

        // 2. Inicializar Controles
        this.controls = new PlayerControls(this.camera, this.canvas, this.settings);
        // Define os limites de colisão para o mundo 1
        this.controls.setWorld(1, world1Data.collisionLimits);
        
        // 3. Inicializar Interação
        this.interaction = new InteractionHandler(
            this.camera, 
            this.scene, 
            this.handleInteraction.bind(this) // Callback
        );
        
        // 4. Conectar Controles e Interação
        // Diz ao 'controls' qual função chamar quando [E] é pressionado
        this.controls.onInteract = () => {
            this.interaction.triggerInteraction();
        };

        // 5. Esconder a tela de Loading e mostrar a UI do Jogo
        this.loadingScreen.style.opacity = '0';
        setTimeout(() => {
            this.loadingScreen.style.display = 'none';
        }, 500); // 0.5s (duração da transição do CSS)

        // Mostra a UI (Mira, Logo, etc.)
        this.uiElements.forEach(el => el.style.display = 'block');
        
        // 6. Iniciar o Loop de Animação
        this.animate();
    }
    
    // -----------------------------------------------------------------
    // LOOP DE ANIMAÇÃO (GAME LOOP)
    // -----------------------------------------------------------------

    /**
     * O Loop Principal (requestAnimationFrame).
     */
    animate() {
        // Pede ao navegador para chamar 'animate' no próximo frame
        requestAnimationFrame(this.animate);

        // Se não carregou ou está em transição, não faz nada
        if (!this.isLoaded || this.isTransitioning) {
            return;
        }

        // Pega o tempo delta (diferença do último frame)
        const delta = this.clock.getDelta();

        // 1. Atualiza o handler de interação (verifica o que está na mira)
        this.interaction.update();
        
        // 2. Atualiza os controles do jogador (movimento, colisão)
        this.controls.update(delta);

        // 3. Renderiza a cena 3D
        this.renderer.render(this.scene, this.camera);
    }
    
    // -----------------------------------------------------------------
    // LÓGICA DE TRANSIÇÃO E INTERAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Callback chamado pelo 'InteractionHandler' quando [E] é pressionado
     * em um alvo válido.
     * @param {Object} userData - Os dados do objeto (ex: { type: 'gothic_door' })
     */
    handleInteraction(userData) {
        console.log("Interação disparada:", userData);
        
        // Verifica se é a porta gótica E se estamos no mundo 1
        if (userData.type === 'gothic_door' && this.currentWorldId === 1) {
            this.triggerSceneTransition();
        }
        
        // Lógica para mostrar info da arte no Mundo 2
        if (userData.type === 'artwork' && this.currentWorldId === 2) {
            console.log(`Clicou na Arte: ${userData.title}`);
            // (Ação Futura): Abrir um modal com `userData.title` e `userData.description`
            alert(`Arte: ${userData.title}\nDescrição: ${userData.description}`);
        }
    }

    /**
     * Executa o "Theater Effect" (Transição da Cena 1 para a Cena 2).
     */
    triggerSceneTransition() {
        if (this.isTransitioning) return; // Previne transições duplas
        
        console.log("Iniciando transição de cena...");
        this.isTransitioning = true; // Pausa o 'animate' loop

        // 1. Fade In Rápido (0.5s) para Branco
        this.transitionFade.style.transition = 'opacity 0.5s ease-in';
        this.transitionFade.style.opacity = '1';

        // 2. Atraso de 500ms (enquanto a tela está branca)
        setTimeout(() => {
            // --- O TELEPORTE (acontece instantaneamente) ---
            
            // a. Remove a geometria do Mundo 1
            this.scene.remove(this.world1_Group);
            
            // b. Constrói e adiciona a geometria do Mundo 2
            // Passa os dados do JSON (this.artworkData) para a fábrica
            const world2Data = this.worldFactory.createWorld2(this.scene, this.artworkData);
            this.world2_Group = world2Data.group;
            this.scene.add(this.world2_Group);

            // c. Teleporta o Jogador (Z=10, conforme requisito)
            this.camera.position.set(0, this.settings.playerHeight, 10);
            
            // d. Reseta a Rotação da Câmera (olhar reto)
            this.controls.resetRotation();

            // e. Atualiza os controles para os limites de colisão do Mundo 2
            this.controls.setWorld(2, world2Data.collisionLimits);
            this.currentWorldId = 2;
            
            // --- FIM DO TELEPORTE ---

            // 3. Fade Out Lento (1.5s) do Branco (olhos se ajustando)
            this.transitionFade.style.transition = 'opacity 1.5s ease-out';
            this.transitionFade.style.opacity = '0';
            
            // 4. Atraso de 1500ms (espera o fade out terminar)
            setTimeout(() => {
                this.isTransitioning = false; // Retoma o 'animate' loop
                console.log("Transição completa. Mundo 2 carregado.");
            }, 1500);

        }, 500); // Fim do setTimeout do Fade In
    }

    // -----------------------------------------------------------------
    // UTILITÁRIOS
    // -----------------------------------------------------------------

    /**
     * Chamado quando a janela do navegador muda de tamanho.
     */
    onWindowResize() {
        // Atualiza as proporções da câmera
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();

        // Atualiza o tamanho do renderizador
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}

// -----------------------------------------------------------------
// PONTO DE ENTRADA
// -----------------------------------------------------------------

// Quando o DOM (HTML) estiver pronto, cria e inicializa a aplicação.
window.addEventListener('DOMContentLoaded', () => {
    const app = new SungApp();
    app.init();
});
2. js/scene.js (ATUALIZADO)
Adicione o material da rocha e o loop para espalhar as rochas pela floresta.

JavaScript
/*
    ARQUIVO: scene.js
    DESCRIÇÃO: Construtor de Cenários 3D.
    FUNÇÃO: Esta classe é uma "fábrica" de geometria. Ela não
    mantém estado, apenas contém métodos que criam e retornam
    os mundos (Cena 1 e Cena 2) como grupos de objetos (THREE.Group).
*/

class WorldSceneFactory {

    constructor(textures) {
        // Armazena as texturas que o 'loader.js' carregou.
        this.textures = textures;
        // Altura padrão da câmera (nível dos olhos)
        this.playerHeight = 1.6;
    }

    // -----------------------------------------------------------------
    // CENA 1: A DESCOBERTA (HIGHWAY / FLORESTA)
    // -----------------------------------------------------------------
    createWorld1(scene) {
        const world1Group = new THREE.Group();
        world1Group.name = "World1_Group"; // Nome para depuração

        // 1. Configuração do Clima (Névoa e Luz)
        // Cor cinza-azulado escuro, inspirada em 'clima.png' (Sleepy Hollow)
        const fogColor = 0x2c3e50; 
        scene.background = new THREE.Color(fogColor);
        // A névoa começa perto e fica densa rapidamente
        scene.fog = new THREE.Fog(fogColor, 1, 35); 

        // Luz ambiente fraca, para dar o tom sombrio
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // (cor, intensidade)
        world1Group.add(ambientLight);

        // Luz direcional (simulando lua/crepúsculo)
        const directionalLight = new THREE.DirectionalLight(0x505a70, 0.4);
        directionalLight.position.set(5, 10, 5);
        world1Group.add(directionalLight);


        // 2. Geometria do Chão (Estrada e Trilha)
        // Usamos a textura 'rodovia.png'
        const roadMaterial = new THREE.MeshBasicMaterial({ map: this.textures.rodovia });
        const roadGeometry = new THREE.PlaneGeometry(15, 80); // (largura, comprimento)
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; // Deita o plano no chão
        road.position.set(0, 0, 80); // Posiciona na área Z > 55
        world1Group.add(road);

        // Trilha de terra
        const pathMaterial = new THREE.MeshBasicMaterial({ map: this.textures.path });
        const pathGeometry = new THREE.PlaneGeometry(5, 60); // (largura, comprimento)
        const path = new THREE.Mesh(pathGeometry, pathMaterial);
        path.rotation.x = -Math.PI / 2;
        path.position.set(0, 0.01, 20); // Z < 55 (começa em -10, vai até 50)
        world1Group.add(path);

        // 3. Floresta Densa (Billboards de Árvores)
        // Material da árvore (usa 'arvore.png')
        const treeMaterial = new THREE.SpriteMaterial({ 
            map: this.textures.tree,
            fog: true,
            color: 0xcccccc // Um pouco mais escuras/cinzas
        });
        
        // Material do brilho do cristal
        const crystalMaterial = new THREE.SpriteMaterial({
            map: this.textures.crystalGlow,
            blending: THREE.AdditiveBlending, // Efeito de brilho
            fog: false, // Cristais brilham através da névoa
            transparent: true,
            opacity: 0.8
        });

        // *** NOVO: Material da Rocha ***
        const rockMaterial = new THREE.SpriteMaterial({
            map: this.textures.rock,
            fog: true,
            color: 0xbbbbbb // Tom cinza para integrar
        });

        // Cria 350 árvores para densidade
        for (let i = 0; i < 350; i++) {
            const sprite = new THREE.Sprite(treeMaterial);
            
            // Posição Z aleatória ao longo de todo o mapa
            const z = Math.random() * 130 - 10; // (Z de -10 a 120)
            
            // Posição X aleatória (para criar as "paredes" espelhadas)
            let x;
            if (z > 50) { // Área da estrada (mais larga)
                x = Math.random() < 0.5 ? -Math.random() * 20 - 7.5 : Math.random() * 20 + 7.5;
            } else { // Área da trilha (mais estreita)
                x = Math.random() < 0.5 ? -Math.random() * 20 - 2.5 : Math.random() * 20 + 2.5;
            }

            // Tamanho aleatório (árvores grandes e médias)
            const scale = Math.random() * 3 + 4; // Escala entre 4m e 7m
            sprite.scale.set(scale, scale, 1);
            sprite.position.set(x, scale / 2, z); // (x, altura, z)
            world1Group.add(sprite);
            
            // Adiciona Cristais Luminosos (Losangos)
            // 10% de chance de uma árvore na trilha (Z < 50) ter um cristal
            if (z < 50 && z > -10 && Math.random() < 0.1) {
                // Luz Pontual (azulada)
                const light = new THREE.PointLight(0xadd8e6, 1, 5); // (cor, intensidade, distância)
                light.position.set(x * 0.9, 2.5, z); // Posição próxima à árvore
                world1Group.add(light);
                
                // Sprite visual do cristal (forma de losango/brilho)
                const crystalSprite = new THREE.Sprite(crystalMaterial);
                crystalSprite.position.copy(light.position);
                crystalSprite.scale.set(1.5, 2.5, 1); // Escala para parecer um losango (mais alto que largo)
                world1Group.add(crystalSprite);
            }
        }

        // *** NOVO: Adiciona Rochas na Trilha ***
        for (let i = 0; i < 40; i++) { // Espalha 40 rochas
            const rockSprite = new THREE.Sprite(rockMaterial);
            
            // Apenas na área da trilha (Z < 50)
            const z = Math.random() * 60 - 10; // Z de -10 a 50
            // Perto das bordas da trilha
            const x = Math.random() < 0.5 ? Math.random() * 3 + 2.5 : -Math.random() * 3 - 2.5; // (X entre 2.5 e 5.5)

            const scale = Math.random() * 0.5 + 0.5; // Rochas pequenas (0.5m a 1m)
            rockSprite.scale.set(scale, scale, 1);
            rockSprite.position.set(x, scale / 2, z); // No chão
            world1Group.add(rockSprite);
        }

        // 4. A Porta Gótica (Objetivo)
        // Usamos a textura 'porta.png'
        
        // Simula a "rocha" onde a porta está (como na imagem 'porta.png')
        const rockFaceMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 }); // Material escuro
        const rockFaceGeometry = new THREE.PlaneGeometry(8, 8); // Parede de rocha
        const rockFace = new THREE.Mesh(rockFaceGeometry, rockFaceMaterial);
        rockFace.position.set(0, 4, -10.5); // (x, altura, z) - Posição atrás da porta
        world1Group.add(rockFace);
        
        // A porta em si
        const doorMaterial = new THREE.MeshBasicMaterial({ 
            map: this.textures.porta,
            transparent: true // Necessário se 'porta.png' tiver transparência
        });
        const doorGeometry = new THREE.PlaneGeometry(4, 5); // Tamanho da porta
        const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
        
        // Posiciona no final da trilha, em frente à rocha
        doorMesh.position.set(0, 2.5, -10); // (x, altura, z)
        
        // Adiciona um 'userData' para o interaction.js saber que este
        // objeto é interativo.
        doorMesh.userData = { 
            interactive: true, 
            type: 'gothic_door' 
        };
        world1Group.add(doorMesh);


        // 5. Limites de Colisão (Invisíveis)
        // O 'controls.js' usará estes limites.
        // Limite da estrada: X = +/- 7.5
        // Limite da trilha: X = +/- 2.5
        const pathLimits = {
            minX: -7.5,
            maxX: 7.5,
            minZ: -9.5, // Perto da porta (para permitir interação)
            maxZ: 120, // Fim da estrada
            
            // Definição da área estreita (trilha)
            trailZStart: 50, // Onde a estrada (larga) termina
            trailMinX: -2.5, // Largura da trilha
            trailMaxX: 2.5
        };

        // Retorna o grupo de objetos e os limites de colisão
        return { group: world1Group, collisionLimits: pathLimits };
    }


    // -----------------------------------------------------------------
    // CENA 2: A GALERIA (CORREDOR)
    // -----------------------------------------------------------------
    createWorld2(scene, artworkData) { // Recebe os dados do JSON
        const world2Group = new THREE.Group();
        world2Group.name = "World2_Group";

        // 1. Limpa a Névoa e Luz da Cena 1
        scene.fog = null; // Remove a névoa
        scene.background = new THREE.Color(0x000000); // Fundo preto

        // Luz ambiente muito escura (soturna)
        const ambientLight = new THREE.AmbientLight(0x101010, 1.0); // (cor, intensidade)
        world2Group.add(ambientLight);

        // Luz "falsa" no teto (HemisphereLight)
        // Simula uma luz fraca vindo de cima, sem sombras (performance)
        const hemiLight = new THREE.HemisphereLight(0x404040, 0x080808, 0.5);
        world2Group.add(hemiLight);

        // 2. Geometria do Corredor
        // Comprimento de 80m (conforme solicitado), Largura 5m, Altura 4m
        const corridorLength = 80;
        const corridorWidth = 5;
        const corridorHeight = 4;

        // Chão
        const floorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.floor });
        const floorGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, 0, corridorLength / 2); // Centraliza no Z
        world2Group.add(floor);

        // Teto
        const ceilMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 }); // Teto escuro
        const ceilGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const ceil = new THREE.Mesh(ceilGeometry, ceilMaterial);
        ceil.rotation.x = Math.PI / 2;
        ceil.position.set(0, corridorHeight, corridorLength / 2);
        world2Group.add(ceil);

        // Parede Esquerda
        const wallMaterial = new THREE.MeshBasicMaterial({ map: this.textures.wall });
        const wallGeometry = new THREE.PlaneGeometry(corridorLength, corridorHeight);
        const wallLeft = new THREE.Mesh(wallGeometry, wallMaterial);
        wallLeft.rotation.y = Math.PI / 2;
        wallLeft.position.set(-corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallLeft);

        // Parede Direita
        const wallRight = new THREE.Mesh(wallGeometry, wallMaterial);
        wallRight.rotation.y = -Math.PI / 2;
        wallRight.position.set(corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallRight);

        // Parede do Fundo (Fechando o corredor)
        const endWallGeom = new THREE.PlaneGeometry(corridorWidth, corridorHeight);
        const endWall = new THREE.Mesh(endWallGeom, wallMaterial);
        endWall.position.set(0, corridorHeight / 2, corridorLength);
        world2Group.add(endWall);

        // 3. Criação das Obras de Arte (Quadros)
        // 18 obras, 9 de cada lado.
        // Espaçamento: 80m / 9 obras = ~8.8m por obra
        const spacing = corridorLength / 9;
        const frameSize = 2.0; // Quadros de 2m x 2m
        const frameHeight = this.playerHeight + 0.2; // Altura dos olhos

        // Itera sobre os dados do JSON (artworkData)
        artworkData.forEach((artwork, index) => {
            // Carrega a textura da arte (já pré-carregada pelo loader)
            const artTexture = this.textures[`art_${artwork.id}`];
            const artMaterial = new THREE.MeshBasicMaterial({ map: artTexture });

            const artGeometry = new THREE.PlaneGeometry(frameSize, frameSize);
            const artMesh = new THREE.Mesh(artGeometry, artMaterial);
            
            // Cria a "placa" de interação (hitbox)
            // É um plano invisível e maior (3x3) para facilitar a interação (forgiving hitbox)
            const plaqueGeometry = new THREE.PlaneGeometry(frameSize + 1, frameSize + 1);
            const plaqueMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const plaqueMesh = new THREE.Mesh(plaqueGeometry, plaqueMaterial);
            
            // Adiciona os dados de interação na PLACA (não na arte)
            plaqueMesh.userData = {
                interactive: true,
                type: 'artwork',
                id: artwork.id,
                title: artwork.title,
                description: artwork.description
            };

            // Posição Z (ao longo do corredor)
            // Começa em Z=10, espaçamento de 8.8m
            const zPos = 10 + (index % 9) * (spacing * 0.9);

            if (index < 9) {
                // Lado Esquerdo (primeiras 9)
                artMesh.position.set((-corridorWidth / 2) + 0.05, frameHeight, zPos);
                artMesh.rotation.y = Math.PI / 2; // Virado para o centro
                
                plaqueMesh.position.set((-corridorWidth / 2) + 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = Math.PI / 2;

            } else {
                // Lado Direito (últimas 9)
                artMesh.position.set((corridorWidth / 2) - 0.05, frameHeight, zPos);
                artMesh.rotation.y = -Math.PI / 2; // Virado para o centro
                
                plaqueMesh.position.set((corridorWidth / 2) - 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = -Math.PI / 2;
            }

            world2Group.add(artMesh);
            world2Group.add(plaqueMesh); // Adiciona a hitbox invisível
        });

        // 4. Limites de Colisão (Corredor)
        // O jogador não pode atravessar as paredes
        const collisionLimits = {
            minX: -corridorWidth / 2 + 0.5, // 0.5m de folga da parede
            maxX: corridorWidth / 2 - 0.5,
            minZ: 0.5, // Parede inicial (não existe, mas impede de voltar)
            maxZ: corridorLength - 0.5 // Parede do fundo
        };
        
        // Retorna o grupo e os limites
        return { group: world2Group, collisionLimits: collisionLimits };
    }
}
Lembrete de Correção de Erros 404
Depois de baixar todas as imagens e colocá-las nas pastas /assets/ e /img/, você ainda precisa fazer as correções de caminho que vimos antes para corrigir os erros 404 (Not Found):

No index.html:

Mude href="css/styles.css" para href="CSS/styles.css" (maiúsculo).

Mude src="assets/images/belial.png" para src="assets/belial.png" (remova images/).

No js/main.js:

Eu já fiz isso no código acima, mas verifique se a sua lista sceneTextures não tem images/ no caminho (ex: path: 'assets/rodovia.png', e não assets/images/rodovia.png).

as imagesn q eu te enviei sevem pq elas eram pra vc ter uma ideia de como eu queria o site

Ah, sim! Entendido. Perfeito, obrigado por esclarecer.

Você está 100% correto. As imagens rodovia.png e porta.png que você enviou são as referências de estilo (o mood board), para me mostrar a atmosfera gótica e cinematográfica que você quer. Elas não são os arquivos de textura finais.

O código que eu escrevi no js/scene.js (com a floresta densa dos dois lados, a névoa, a trilha estreita, a porta na rocha e os cristais) foi feito exatamente para recriar essa atmosfera que você mostrou nas imagens de referência.

Para que esse código funcione e pare de dar erros 404, ele precisa dos "ingredientes" (os arquivos de imagem de textura reais).

Portanto, a lista que eu te passei na mensagem anterior (com os links para o AmbientCG, Pixabay, etc.) é exatamente o que você precisa. Aqueles links são onde você pode baixar os arquivos de imagem reais que o código está pedindo:

path_texture.jpg (o chão de terra da trilha)

arvore.png (a árvore com fundo transparente para criar a floresta)

wall_texture.jpg (a parede de pedra escura do corredor)

floor_texture.jpg (o chão de pedra do corredor)

crystal_glow.png (o brilho do cristal)

rock.png (as pedras no chão da trilha)

Resumindo: Você deu a ideia (referências), eu fiz o "esqueleto" (código), agora só falta você buscar o "material de construção" (as texturas daquela lista) para o código poder "pintar" a cena.

vc pode me dar o link de novo do ambiente cg

Com certeza. O site principal é:

https://ambientcg.com/

Para facilitar, aqui estão os links diretos para as buscas que recomendei (são as texturas que você precisa para o projeto):

Chão de Terra (para path_texture.jpg):

https://ambientcg.com/list?q=dirt (Procure por Ground037 ou Dirt007)

Parede do Corredor (para wall_texture.jpg):

https://ambientcg.com/view?id=Rock030 (Esta é uma ótima opção gótica)

Chão do Corredor (para floor_texture.jpg):

https://ambientcg.com/view?id=PavingStones070 (Chão de pedras escuras)

Lembre-se: Baixe a versão JPG de 1K ou 2K e pegue apenas o arquivo que termina em _Color.jpg de dentro do ZIP.

gostei dessa terra pro chao da floresta

https://ambientcg.com/view?id=Ground082S

e pro chao da trilha https://ambientcg.com/view?id=Bricks075B

o vd em anexo e como era a estrutura anterior do site

Entendido. O vídeo é a versão antiga, então ele serviu como uma boa referência de conceito (cena de entrada, corredor, popup de interação).

Vamos focar 100% no nosso projeto atual: Cena 1 (Floresta/Estrada) -> Cena 2 (Corredor).

Excelentes escolhas de textura!

Chão da Floresta: Ground082S (terra escura/molhada) - Perfeito.

Chão da Trilha: Bricks075B (tijolos escuros) - Entendido. Isso muda a "trilha de terra" para uma "trilha de tijolos antigos", o que é ótimo para o tema Sleepy Hollow.

Plano de Ação:

Vou modificar o js/scene.js para adicionar um novo plano de chão (enorme) para a floresta, que usará a textura Ground082S.

Vou manter o código da trilha como está, mas você vai substituir o arquivo de textura dela pelos tijolos.

Importante: A textura da rodovia (rodovia.png) que você enviou é uma imagem de referência, não uma textura "seamless" (que se repete). Ela vai ficar estranha. Recomendo fortemente que você também pegue uma textura de asfalto escuro/molhado para a rodovia.

Passo 1: Baixe estas 3 Texturas
Por favor, baixe os arquivos JPG (1K ou 2K) e pegue apenas o arquivo _Color.jpg de cada um. Renomeie-os exatamente assim e coloque na sua pasta /assets/:

Rodovia (Asfalto): https://ambientcg.com/view?id=Asphalt033

Baixe e renomeie o Asphalt033..._Color.jpg para: rodovia_texture.jpg

Trilha (Tijolos): https://ambientcg.com/view?id=Bricks075B

Baixe e renomeie o Bricks075B..._Color.jpg para: path_texture.jpg (substituindo o antigo)

Floresta (Terra): https://ambientcg.com/view?id=Ground082S

Baixe e renomeie o Ground082S..._Color.jpg para: forest_floor.jpg

Passo 2: Código Atualizado (js/main.js e js/scene.js)
Aqui estão os dois arquivos atualizados que carregam e exibem essas novas texturas.

js/main.js (ATUALIZADO)
(Eu atualizei a lista sceneTextures para carregar a nova textura forest_floor.jpg e corrigi o caminho da rodovia para usar rodovia_texture.jpg)

JavaScript
/*
    ARQUIVO: main.js
    DESCRIÇÃO: Ponto de Entrada Principal da Aplicação (O "Maestro").
    FUNÇÃO: Este script inicializa todos os componentes (Cena, Câmera,
    Renderizador, Controles) e gerencia o "Game Loop" (o 'animate').
    Ele coordena o carregamento de assets (JSON e texturas), 
    a transição de cenas e conecta os controles à lógica de interação.
    
    COMENTÁRIOS: PT-BR
*/

// Classe principal da aplicação
class SungApp {
    
    constructor() {
        // Elementos do DOM
        this.canvas = document.getElementById('game-canvas');
        this.loadingScreen = document.getElementById('loading-screen');
        this.loadingText = document.querySelector('.loading-text');
        this.transitionFade = document.getElementById('transition-fade');
        this.uiElements = [
            document.getElementById('crosshair'),
            document.getElementById('logo'),
            document.getElementById('copyright')
        ];

        // Componentes do Three.js
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true // Suavização de serrilhado
        });
        this.clock = new THREE.Clock(); // Relógio para o 'delta time'

        // Componentes do Jogo
        this.loader = null;
        this.controls = null;
        this.interaction = null;
        this.worldFactory = null;
        
        // Dados (carregados do JSON)
        this.artworkData = [];

        // Grupos de Cena (para fácil adição/remoção)
        this.world1_Group = null;
        this.world2_Group = null;

        // Estado do Jogo
        this.isLoaded = false;
        this.isTransitioning = false;
        this.currentWorldId = 1; // Começa no Mundo 1
        
        // Configurações (conforme UX finalizado)
        this.settings = {
            movementSpeed: 1.8,         // 1.8 m/s
            desktopCameraSpeed: 0.0008, // Sensibilidade Desktop
            mobileCameraSpeed: 0.0025,  // Sensibilidade Mobile
            playerHeight: 1.6           // Altura dos olhos do jogador
        };
        
        // Referência 'bind' para o loop de animação
        this.animate = this.animate.bind(this);
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Método principal de inicialização (agora é assíncrono).
     */
    async init() {
        console.log("Iniciando SungApp...");

        try {
            // 1. Carregar os dados das artes primeiro (de data/arts.json)
            await this.loadArtworkData();
            console.log("Dados de arte (arts.json) carregados.");

            // 2. Configurar o Renderizador
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limita o pixel ratio por performance
            this.renderer.outputEncoding = THREE.sRGBEncoding;

            // 3. Configurar a Posição Inicial da Câmera
            // (Z > 55, conforme requisito da Cena 1)
            this.camera.position.set(0, this.settings.playerHeight, 60);

            // 4. Inicializar o Loader de Assets (Texturas)
            this.loader = new AssetLoader(
                (progress) => {
                    // Função 'onProgress'
                    this.loadingText.textContent = `Carregando... ${progress.toFixed(0)}%`;
                },
                () => {
                    // Função 'onLoad' (Tudo carregado)
                    this.startExperience();
                }
            );

            // 5. Definir quais texturas carregar
            // **** ATUALIZADO AQUI ****
            // Corrigido o caminho da 'rodovia' e adicionado 'forest_floor'
            const sceneTextures = [
                // Texturas principais (suas imagens)
                { name: 'rodovia', path: 'assets/rodovia_texture.jpg', repeat: [3, 10] }, // <-- ATUALIZADO (Asfalto)
                { name: 'porta', path: 'assets/porta.png' }, // (Sua referência, ok)
                
                // Texturas auxiliares
                { name: 'path', path: 'assets/path_texture.jpg', repeat: [2, 12] }, // (Agora são os Tijolos)
                { name: 'arvore', path: 'assets/arvore.png' },
                { name: 'crystalGlow', path: 'assets/crystal_glow.png' },
                { name: 'rock', path: 'assets/rock.png' },
                { name: 'forest_floor', path: 'assets/forest_floor.jpg', repeat: [20, 20] }, // <-- NOVO (Terra)
                
                // Texturas do Corredor
                { name: 'wall', path: 'assets/wall_texture.jpg', repeat: [20, 2] },
                { name: 'floor', path: 'assets/floor_texture.jpg', repeat: [2, 20] }
            ];
            
            // Adiciona as 18 artes (carregadas do JSON) à lista de carregamento
            const artworkTextures = this.artworkData.map(art => ({
                name: `art_${art.id}`, // ex: 'art_1'
                path: art.image // ex: 'img/tattoo_01.png'
            }));
            
            // Carrega TUDO
            const allTexturesToLoad = [...sceneTextures, ...artworkTextures];
            const loadedTextures = this.loader.loadTextures(allTexturesToLoad);
            
            // 6. Inicializar a "Fábrica" de Mundos com as texturas
            this.worldFactory = new WorldSceneFactory(loadedTextures);

            // 7. Ouvinte de redimensionamento da janela
            window.addEventListener('resize', this.onWindowResize.bind(this));
        
        } catch (error) {
            console.error("Falha fatal na inicialização:", error);
            this.loadingText.textContent = "Erro ao carregar. Verifique o console.";
            this.loadingText.style.color = "red";
        }
    }
    
    /**
     * Carrega os dados do arquivo /data/arts.json
     * (Precisa de um servidor local - ver como_rodar.txt)
     */
    async loadArtworkData() {
        try {
            // Usa 'fetch' para buscar o arquivo JSON
            const response = await fetch('data/arts.json');
            if (!response.ok) {
                // Se o arquivo não for encontrado (404) ou der erro, falha
                throw new Error(`Erro HTTP! Status: ${response.status}`);
            }
            this.artworkData = await response.json();
            
            // Validação
            if (this.artworkData.length !== 18) {
                console.warn(`Aviso: 'arts.json' contém ${this.artworkData.length} artes. O corredor foi projetado para 18.`);
            }
            
        } catch (error) {
            console.error("Não foi possível carregar 'data/arts.json':", error);
            // Re-lança o erro para o 'init' principal tratar
            throw error; 
        }
    }

    /**
     * Chamado quando o Loader termina (onLoad).
     */
    startExperience() {
        console.log("Assets carregados. Iniciando a experiência.");
        this.isLoaded = true;
        
        // 1. Construir o Mundo 1 (Floresta)
        const world1Data = this.worldFactory.createWorld1(this.scene);
        this.world1_Group = world1Data.group;
        this.scene.add(this.world1_Group);

        // 2. Inicializar Controles
        this.controls = new PlayerControls(this.camera, this.canvas, this.settings);
        // Define os limites de colisão para o mundo 1
        this.controls.setWorld(1, world1Data.collisionLimits);
        
        // 3. Inicializar Interação
        this.interaction = new InteractionHandler(
            this.camera, 
            this.scene, 
            this.handleInteraction.bind(this) // Callback
        );
        
        // 4. Conectar Controles e Interação
        // Diz ao 'controls' qual função chamar quando [E] é pressionado
        this.controls.onInteract = () => {
            this.interaction.triggerInteraction();
        };

        // 5. Esconder a tela de Loading e mostrar a UI do Jogo
        this.loadingScreen.style.opacity = '0';
        setTimeout(() => {
            this.loadingScreen.style.display = 'none';
        }, 500); // 0.5s (duração da transição do CSS)

        // Mostra a UI (Mira, Logo, etc.)
        this.uiElements.forEach(el => el.style.display = 'block');
        
        // 6. Iniciar o Loop de Animação
        this.animate();
    }
    
    // -----------------------------------------------------------------
    // LOOP DE ANIMAÇÃO (GAME LOOP)
    // -----------------------------------------------------------------

    /**
     * O Loop Principal (requestAnimationFrame).
     */
    animate() {
        // Pede ao navegador para chamar 'animate' no próximo frame
        requestAnimationFrame(this.animate);

        // Se não carregou ou está em transição, não faz nada
        if (!this.isLoaded || this.isTransitioning) {
            return;
        }

        // Pega o tempo delta (diferença do último frame)
        const delta = this.clock.getDelta();

        // 1. Atualiza o handler de interação (verifica o que está na mira)
        this.interaction.update();
        
        // 2. Atualiza os controles do jogador (movimento, colisão)
        this.controls.update(delta);

        // 3. Renderiza a cena 3D
        this.renderer.render(this.scene, this.camera);
    }
    
    // -----------------------------------------------------------------
    // LÓGICA DE TRANSIÇÃO E INTERAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Callback chamado pelo 'InteractionHandler' quando [E] é pressionado
     * em um alvo válido.
     * @param {Object} userData - Os dados do objeto (ex: { type: 'gothic_door' })
     */
    handleInteraction(userData) {
        console.log("Interação disparada:", userData);
        
        // Verifica se é a porta gótica E se estamos no mundo 1
        if (userData.type === 'gothic_door' && this.currentWorldId === 1) {
            this.triggerSceneTransition();
        }
        
        // Lógica para mostrar info da arte no Mundo 2
        if (userData.type === 'artwork' && this.currentWorldId === 2) {
            console.log(`Clicou na Arte: ${userData.title}`);
            // (Ação Futura): Abrir um modal com `userData.title` e `userData.description`
            alert(`Arte: ${userData.title}\nDescrição: ${userData.description}`);
        }
    }

    /**
     * Executa o "Theater Effect" (Transição da Cena 1 para a Cena 2).
     */
    triggerSceneTransition() {
        if (this.isTransitioning) return; // Previne transições duplas
        
        console.log("Iniciando transição de cena...");
        this.isTransitioning = true; // Pausa o 'animate' loop

        // 1. Fade In Rápido (0.5s) para Branco
        this.transitionFade.style.transition = 'opacity 0.5s ease-in';
        this.transitionFade.style.opacity = '1';

        // 2. Atraso de 500ms (enquanto a tela está branca)
        setTimeout(() => {
            // --- O TELEPORTE (acontece instantaneamente) ---
            
            // a. Remove a geometria do Mundo 1
            this.scene.remove(this.world1_Group);
            
            // b. Constrói e adiciona a geometria do Mundo 2
            // Passa os dados do JSON (this.artworkData) para a fábrica
            const world2Data = this.worldFactory.createWorld2(this.scene, this.artworkData);
            this.world2_Group = world2Data.group;
            this.scene.add(this.world2_Group);

            // c. Teleporta o Jogador (Z=10, conforme requisito)
            this.camera.position.set(0, this.settings.playerHeight, 10);
            
            // d. Reseta a Rotação da Câmera (olhar reto)
            this.controls.resetRotation();

            // e. Atualiza os controles para os limites de colisão do Mundo 2
            this.controls.setWorld(2, world2Data.collisionLimits);
            this.currentWorldId = 2;
            
            // --- FIM DO TELEPORTE ---

            // 3. Fade Out Lento (1.5s) do Branco (olhos se ajustando)
            this.transitionFade.style.transition = 'opacity 1.5s ease-out';
            this.transitionFade.style.opacity = '0';
            
            // 4. Atraso de 1500ms (espera o fade out terminar)
            setTimeout(() => {
                this.isTransitioning = false; // Retoma o 'animate' loop
                console.log("Transição completa. Mundo 2 carregado.");
            }, 1500);

        }, 500); // Fim do setTimeout do Fade In
    }

    // -----------------------------------------------------------------
    // UTILITÁRIOS
    // -----------------------------------------------------------------

    /**
     * Chamado quando a janela do navegador muda de tamanho.
     */
    onWindowResize() {
        // Atualiza as proporções da câmera
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();

        // Atualiza o tamanho do renderizador
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}

// -----------------------------------------------------------------
// PONTO DE ENTRADA
// -----------------------------------------------------------------

// Quando o DOM (HTML) estiver pronto, cria e inicializa a aplicação.
window.addEventListener('DOMContentLoaded', () => {
    // Lembrete sobre o servidor local (para o 'fetch' funcionar)
    if (window.location.protocol === 'file:') {
        console.error("ERRO: O projeto não pode ser executado localmente via 'file://'. Use um servidor local (veja como_rodar.txt).");
        document.body.innerHTML = '<div style="color: red; font-size: 20px; padding: 20px;">ERRO: O projeto não pode ser executado localmente. Por favor, use um servidor (veja o arquivo como_rodar.txt).</div>';
        return;
    }
    
    const app = new SungApp();
    app.init();
});
js/scene.js (ATUALIZADO)
(Adicionei o novo forestFloor e atualizei os materiais da rodovia e trilha para usar as texturas corretas que você está baixando)

JavaScript
/*
    ARQUIVO: scene.js
    DESCRIÇÃO: Construtor de Cenários 3D.
    FUNÇÃO: Esta classe é uma "fábrica" de geometria. Ela não
    mantém estado, apenas contém métodos que criam e retornam
    os mundos (Cena 1 e Cena 2) como grupos de objetos (THREE.Group).
    
    COMENTÁRIOS: PT-BR
*/

class WorldSceneFactory {

    constructor(textures) {
        // Armazena as texturas que o 'loader.js' carregou.
        this.textures = textures;
        // Altura padrão da câmera (nível dos olhos)
        this.playerHeight = 1.6;
    }

    // -----------------------------------------------------------------
    // CENA 1: A DESCOBERTA (HIGHWAY / FLORESTA)
    // -----------------------------------------------------------------
    createWorld1(scene) {
        const world1Group = new THREE.Group();
        world1Group.name = "World1_Group"; // Nome para depuração

        // 1. Configuração do Clima (Névoa e Luz)
        // Cor cinza-azulado escuro, inspirada em 'clima.png' (Sleepy Hollow)
        const fogColor = 0x2c3e50; 
        scene.background = new THREE.Color(fogColor);
        // A névoa começa perto e fica densa rapidamente
        scene.fog = new THREE.Fog(fogColor, 1, 35); 

        // Luz ambiente fraca, para dar o tom sombrio
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // (cor, intensidade)
        world1Group.add(ambientLight);

        // Luz direcional (simulando lua/crepúsculo)
        const directionalLight = new THREE.DirectionalLight(0x505a70, 0.4);
        directionalLight.position.set(5, 10, 5);
        world1Group.add(directionalLight);

        
        // 2. Geometria do Chão (Rodovia, Trilha e Floresta)
        
        // *** NOVO: Chão da Floresta (Ground082S) ***
        // Este é um plano enorme que fica embaixo de tudo
        const forestFloorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.forest_floor });
        const forestFloorGeometry = new THREE.PlaneGeometry(200, 200); // 200m x 200m
        const forestFloor = new THREE.Mesh(forestFloorGeometry, forestFloorMaterial);
        forestFloor.rotation.x = -Math.PI / 2;
        forestFloor.position.set(0, -0.05, 50); // Posição Y levemente abaixo do resto
        world1Group.add(forestFloor);

        // Rodovia (Asphalt033)
        // Usamos a textura 'rodovia_texture.jpg'
        const roadMaterial = new THREE.MeshBasicMaterial({ map: this.textures.rodovia });
        const roadGeometry = new THREE.PlaneGeometry(15, 80); // (largura, comprimento)
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; // Deita o plano no chão
        road.position.set(0, 0, 80); // Posiciona na área Z > 55
        world1Group.add(road);

        // Trilha de Tijolos (Bricks075B)
        // Usamos a textura 'path_texture.jpg' (que agora é de tijolos)
        const pathMaterial = new THREE.MeshBasicMaterial({ map: this.textures.path });
        const pathGeometry = new THREE.PlaneGeometry(5, 60); // (largura, comprimento)
        const path = new THREE.Mesh(pathGeometry, pathMaterial);
        path.rotation.x = -Math.PI / 2;
        path.position.set(0, 0.01, 20); // Z < 55 (e Y levemente acima do chão da floresta)
        world1Group.add(path);


        // 3. Floresta Densa (Billboards de Árvores)
        // Material da árvore (usa 'arvore.png')
        const treeMaterial = new THREE.SpriteMaterial({ 
            map: this.textures.tree,
            fog: true,
            color: 0xcccccc // Um pouco mais escuras/cinzas
        });
        
        // Material do brilho do cristal
        const crystalMaterial = new THREE.SpriteMaterial({
            map: this.textures.crystalGlow,
            blending: THREE.AdditiveBlending, // Efeito de brilho
            fog: false, // Cristais brilham através da névoa
            transparent: true,
            opacity: 0.8
        });

        // Material da Rocha
        const rockMaterial = new THREE.SpriteMaterial({
            map: this.textures.rock,
            fog: true,
            color: 0xbbbbbb // Tom cinza para integrar
        });

        // Cria 350 árvores para densidade
        for (let i = 0; i < 350; i++) {
            const sprite = new THREE.Sprite(treeMaterial);
            
            // Posição Z aleatória ao longo de todo o mapa
            const z = Math.random() * 130 - 10; // (Z de -10 a 120)
            
            // Posição X aleatória (para criar as "paredes" espelhadas)
            let x;
            if (z > 50) { // Área da estrada (mais larga)
                x = Math.random() < 0.5 ? -Math.random() * 20 - 7.5 : Math.random() * 20 + 7.5;
            } else { // Área da trilha (mais estreita)
                x = Math.random() < 0.5 ? -Math.random() * 20 - 2.5 : Math.random() * 20 + 2.5;
            }

            // Tamanho aleatório (árvores grandes e médias)
            const scale = Math.random() * 3 + 4; // Escala entre 4m e 7m
            sprite.scale.set(scale, scale, 1);
            sprite.position.set(x, scale / 2, z); // (x, altura, z)
            world1Group.add(sprite);
            
            // Adiciona Cristais Luminosos (Losangos)
            // 10% de chance de uma árvore na trilha (Z < 50) ter um cristal
            if (z < 50 && z > -10 && Math.random() < 0.1) {
                // Luz Pontual (azulada)
                const light = new THREE.PointLight(0xadd8e6, 1, 5); // (cor, intensidade, distância)
                light.position.set(x * 0.9, 2.5, z); // Posição próxima à árvore
                world1Group.add(light);
                
                // Sprite visual do cristal (forma de losango/brilho)
                const crystalSprite = new THREE.Sprite(crystalMaterial);
                crystalSprite.position.copy(light.position);
                crystalSprite.scale.set(1.5, 2.5, 1); // Escala para parecer um losango (mais alto que largo)
                world1Group.add(crystalSprite);
            }
        }

        // Adiciona Rochas na Trilha
        for (let i = 0; i < 40; i++) { // Espalha 40 rochas
            const rockSprite = new THREE.Sprite(rockMaterial);
            
            // Apenas na área da trilha (Z < 50)
            const z = Math.random() * 60 - 10; // Z de -10 a 50
            // Perto das bordas da trilha
            const x = Math.random() < 0.5 ? Math.random() * 3 + 2.5 : -Math.random() * 3 - 2.5; // (X entre 2.5 e 5.5)

            const scale = Math.random() * 0.5 + 0.5; // Rochas pequenas (0.5m a 1m)
            rockSprite.scale.set(scale, scale, 1);
            rockSprite.position.set(x, scale / 2, z); // No chão
            world1Group.add(rockSprite);
        }

        // 4. A Porta Gótica (Objetivo)
        // Usamos a textura 'porta.png'
        
        // Simula a "rocha" onde a porta está (como na imagem 'porta.png')
        const rockFaceMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 }); // Material escuro
        const rockFaceGeometry = new THREE.PlaneGeometry(8, 8); // Parede de rocha
        const rockFace = new THREE.Mesh(rockFaceGeometry, rockFaceMaterial);
        rockFace.position.set(0, 4, -10.5); // (x, altura, z) - Posição atrás da porta
        world1Group.add(rockFace);
        
        // A porta em si
        const doorMaterial = new THREE.MeshBasicMaterial({ 
            map: this.textures.porta,
            transparent: true // Necessário se 'porta.png' tiver transparência
        });
        const doorGeometry = new THREE.PlaneGeometry(4, 5); // Tamanho da porta
        const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
        
        // Posiciona no final da trilha, em frente à rocha
        doorMesh.position.set(0, 2.5, -10); // (x, altura, z)
        
        // Adiciona um 'userData' para o interaction.js saber que este
        // objeto é interativo.
        doorMesh.userData = { 
            interactive: true, 
            type: 'gothic_door' 
        };
        world1Group.add(doorMesh);


        // 5. Limites de Colisão (Invisíveis)
        // O 'controls.js' usará estes limites.
        // Limite da estrada: X = +/- 7.5
        // Limite da trilha: X = +/- 2.5
        const pathLimits = {
            minX: -7.5,
            maxX: 7.5,
            minZ: -9.5, // Perto da porta (para permitir interação)
            maxZ: 120, // Fim da estrada
            
            // Definição da área estreita (trilha)
            trailZStart: 50, // Onde a estrada (larga) termina
            trailMinX: -2.5, // Largura da trilha
            trailMaxX: 2.5
        };

        // Retorna o grupo de objetos e os limites de colisão
        return { group: world1Group, collisionLimits: pathLimits };
    }


    // -----------------------------------------------------------------
    // CENA 2: A GALERIA (CORREDOR)
    // -----------------------------------------------------------------
    createWorld2(scene, artworkData) { // Recebe os dados do JSON
        const world2Group = new THREE.Group();
        world2Group.name = "World2_Group";

        // 1. Limpa a Névoa e Luz da Cena 1
        scene.fog = null; // Remove a névoa
        scene.background = new THREE.Color(0x000000); // Fundo preto

        // Luz ambiente muito escura (soturna)
        const ambientLight = new THREE.AmbientLight(0x101010, 1.0); // (cor, intensidade)
        world2Group.add(ambientLight);

        // Luz "falsa" no teto (HemisphereLight)
        // Simula uma luz fraca vindo de cima, sem sombras (performance)
        const hemiLight = new THREE.HemisphereLight(0x404040, 0x080808, 0.5);
        world2Group.add(hemiLight);

        // 2. Geometria do Corredor
        // Comprimento de 80m (conforme solicitado), Largura 5m, Altura 4m
        const corridorLength = 80;
        const corridorWidth = 5;
        const corridorHeight = 4;

        // Chão (Usa 'floor_texture.jpg')
        const floorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.floor });
        const floorGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, 0, corridorLength / 2); // Centraliza no Z
        world2Group.add(floor);

        // Teto
        const ceilMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 }); // Teto escuro
        const ceilGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const ceil = new THREE.Mesh(ceilGeometry, ceilMaterial);
        ceil.rotation.x = Math.PI / 2;
        ceil.position.set(0, corridorHeight, corridorLength / 2);
        world2Group.add(ceil);

        // Parede Esquerda (Usa 'wall_texture.jpg')
        const wallMaterial = new THREE.MeshBasicMaterial({ map: this.textures.wall });
        const wallGeometry = new THREE.PlaneGeometry(corridorLength, corridorHeight);
        const wallLeft = new THREE.Mesh(wallGeometry, wallMaterial);
        wallLeft.rotation.y = Math.PI / 2;
        wallLeft.position.set(-corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallLeft);

        // Parede Direita (Usa 'wall_texture.jpg')
        const wallRight = new THREE.Mesh(wallGeometry, wallMaterial);
        wallRight.rotation.y = -Math.PI / 2;
        wallRight.position.set(corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallRight);

        // Parede do Fundo (Fechando o corredor)
        const endWallGeom = new THREE.PlaneGeometry(corridorWidth, corridorHeight);
        const endWall = new THREE.Mesh(endWallGeom, wallMaterial);
        endWall.position.set(0, corridorHeight / 2, corridorLength);
        world2Group.add(endWall);

        // 3. Criação das Obras de Arte (Quadros)
        // 18 obras, 9 de cada lado.
        // Espaçamento: 80m / 9 obras = ~8.8m por obra
        const spacing = corridorLength / 9;
        const frameSize = 2.0; // Quadros de 2m x 2m
        const frameHeight = this.playerHeight + 0.2; // Altura dos olhos

        // Itera sobre os dados do JSON (artworkData)
        artworkData.forEach((artwork, index) => {
            // Carrega a textura da arte (já pré-carregada pelo loader)
            const artTexture = this.textures[`art_${artwork.id}`];
            const artMaterial = new THREE.MeshBasicMaterial({ map: artTexture });

            const artGeometry = new THREE.PlaneGeometry(frameSize, frameSize);
            const artMesh = new THREE.Mesh(artGeometry, artMaterial);
            
            // Cria a "placa" de interação (hitbox)
            // É um plano invisível e maior (3x3) para facilitar a interação (forgiving hitbox)
            const plaqueGeometry = new THREE.PlaneGeometry(frameSize + 1, frameSize + 1);
            const plaqueMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const plaqueMesh = new THREE.Mesh(plaqueGeometry, plaqueMaterial);
            
            // Adiciona os dados de interação na PLACA (não na arte)
            plaqueMesh.userData = {
                interactive: true,
                type: 'artwork',
                id: artwork.id,
                title: artwork.title,
                description: artwork.description
            };

            // Posição Z (ao longo do corredor)
            // Começa em Z=10, espaçamento de 8.8m
            const zPos = 10 + (index % 9) * (spacing * 0.9);

            if (index < 9) {
                // Lado Esquerdo (primeiras 9)
                artMesh.position.set((-corridorWidth / 2) + 0.05, frameHeight, zPos);
                artMesh.rotation.y = Math.PI / 2; // Virado para o centro
                
                plaqueMesh.position.set((-corridorWidth / 2) + 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = Math.PI / 2;

            } else {
                // Lado Direito (últimas 9)
                artMesh.position.set((corridorWidth / 2) - 0.05, frameHeight, zPos);
                artMesh.rotation.y = -Math.PI / 2; // Virado para o centro
                
                plaqueMesh.position.set((corridorWidth / 2) - 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = -Math.PI / 2;
            }

            world2Group.add(artMesh);
            world2Group.add(plaqueMesh); // Adiciona a hitbox invisível
        });

        // 4. Limites de Colisão (Corredor)
        // O jogador não pode atravessar as paredes
        const collisionLimits = {
            minX: -corridorWidth / 2 + 0.5, // 0.5m de folga da parede
            maxX: corridorWidth / 2 - 0.5,
            minZ: 0.5, // Parede inicial (não existe, mas impede de voltar)
            maxZ: corridorLength - 0.5 // Parede do fundo
        };
        
        // Retorna o grupo e os limites
        return { group: world2Group, collisionLimits: collisionLimits };
    }
}
e pq eu tava querndo q o player

procurasse a porta sabe e como um game msm porem com um portifolio na segunda cena

Entendido perfeitamente. Você quer que a Cena 1 seja um mini-jogo de exploração, não um corredor. O jogador começa na rodovia, mas tem que procurar ativamente pela trilha e pela porta, como em um "game" de verdade.

Para fazer isso, o código atual não serve, porque ele força o jogador a ficar na trilha (com a colisão).

Vamos mudar a lógica para criar um "mundo aberto" (na verdade, uma clareira de 200x200m) onde o jogador terá que explorar.

O Novo Plano (A Caçada):

O Mapa: Vamos usar o chão de terra (Ground082S) como o chão principal de uma floresta gigante (200x200m).

A Rodovia: A rodovia (Asphalt033) será apenas o ponto de spawn (início), em uma das bordas desse mapa.

A Trilha Escondida: A trilha de tijolos (Bricks075B) não estará conectada à rodovia. Ela estará escondida em algum lugar dentro da floresta.

A Pista (Os Cristais): Os cristais luminosos não serão mais aleatórios. Eles serão as "migalhas de pão" que o jogador deve seguir. Eles vão formar um caminho até a trilha de tijolos escondida.

A Liberdade: Vamos remover a colisão que te prende na trilha. Você terá liberdade total para andar pela floresta de 200x200m.

Isso transforma a Cena 1 de um "passeio" para um "objetivo".

Aqui estão os 3 arquivos que precisamos modificar para fazer isso.

js/main.js (ATUALIZADO)
(A única mudança aqui é a posição inicial da câmera, para começar na borda do novo mapa, na rodovia).

JavaScript
/*
    ARQUIVO: main.js
    DESCRIÇÃO: Ponto de Entrada Principal da Aplicação (O "Maestro").
    FUNÇÃO: Este script inicializa todos os componentes (Cena, Câmera,
    Renderizador, Controles) e gerencia o "Game Loop" (o 'animate').
    Ele coordena o carregamento de assets (JSON e texturas), 
    a transição de cenas e conecta os controles à lógica de interação.
    
    COMENTÁRIOS: PT-BR
*/

// Classe principal da aplicação
class SungApp {
    
    constructor() {
        // Elementos do DOM
        this.canvas = document.getElementById('game-canvas');
        this.loadingScreen = document.getElementById('loading-screen');
        this.loadingText = document.querySelector('.loading-text');
        this.transitionFade = document.getElementById('transition-fade');
        this.uiElements = [
            document.getElementById('crosshair'),
            document.getElementById('logo'),
            document.getElementById('copyright')
        ];

        // Componentes do Three.js
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true // Suavização de serrilhado
        });
        this.clock = new THREE.Clock(); // Relógio para o 'delta time'

        // Componentes do Jogo
        this.loader = null;
        this.controls = null;
        this.interaction = null;
        this.worldFactory = null;
        
        // Dados (carregados do JSON)
        this.artworkData = [];

        // Grupos de Cena (para fácil adição/remoção)
        this.world1_Group = null;
        this.world2_Group = null;

        // Estado do Jogo
        this.isLoaded = false;
        this.isTransitioning = false;
        this.currentWorldId = 1; // Começa no Mundo 1
        
        // Configurações (conforme UX finalizado)
        this.settings = {
            movementSpeed: 1.8,         // 1.8 m/s
            desktopCameraSpeed: 0.0008, // Sensibilidade Desktop
            mobileCameraSpeed: 0.0025,  // Sensibilidade Mobile
            playerHeight: 1.6           // Altura dos olhos do jogador
        };
        
        // Referência 'bind' para o loop de animação
        this.animate = this.animate.bind(this);
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Método principal de inicialização (agora é assíncrono).
     */
    async init() {
        console.log("Iniciando SungApp...");

        try {
            // 1. Carregar os dados das artes primeiro (de data/arts.json)
            await this.loadArtworkData();
            console.log("Dados de arte (arts.json) carregados.");

            // 2. Configurar o Renderizador
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limita o pixel ratio por performance
            this.renderer.outputEncoding = THREE.sRGBEncoding;

            // 3. Configurar a Posição Inicial da Câmera
            // **** ATUALIZADO AQUI ****
            // Movido para a borda do novo mapa (na rodovia)
            this.camera.position.set(0, this.settings.playerHeight, 90);

            // 4. Inicializar o Loader de Assets (Texturas)
            this.loader = new AssetLoader(
                (progress) => {
                    // Função 'onProgress'
                    this.loadingText.textContent = `Carregando... ${progress.toFixed(0)}%`;
                },
                () => {
                    // Função 'onLoad' (Tudo carregado)
                    this.startExperience();
                }
            );

            // 5. Definir quais texturas carregar
            const sceneTextures = [
                // Texturas principais (suas imagens)
                { name: 'rodovia', path: 'assets/rodovia_texture.jpg', repeat: [3, 10] }, // (Asfalto)
                { name: 'porta', path: 'assets/porta.png' }, 
                
                // Texturas auxiliares
                { name: 'path', path: 'assets/path_texture.jpg', repeat: [2, 12] }, // (Tijolos)
                { name: 'arvore', path: 'assets/arvore.png' },
                { name: 'crystalGlow', path: 'assets/crystal_glow.png' },
                { name: 'rock', path: 'assets/rock.png' },
                { name: 'forest_floor', path: 'assets/forest_floor.jpg', repeat: [50, 50] }, // <-- Repetição maior
                
                // Texturas do Corredor
                { name: 'wall', path: 'assets/wall_texture.jpg', repeat: [20, 2] },
                { name: 'floor', path: 'assets/floor_texture.jpg', repeat: [2, 20] }
            ];
            
            // Adiciona as 18 artes (carregadas do JSON) à lista de carregamento
            const artworkTextures = this.artworkData.map(art => ({
                name: `art_${art.id}`, // ex: 'art_1'
                path: art.image // ex: 'img/tattoo_01.png'
            }));
            
            // Carrega TUDO
            const allTexturesToLoad = [...sceneTextures, ...artworkTextures];
            const loadedTextures = this.loader.loadTextures(allTexturesToLoad);
            
            // 6. Inicializar a "Fábrica" de Mundos com as texturas
            this.worldFactory = new WorldSceneFactory(loadedTextures);

            // 7. Ouvinte de redimensionamento da janela
            window.addEventListener('resize', this.onWindowResize.bind(this));
        
        } catch (error) {
            console.error("Falha fatal na inicialização:", error);
            this.loadingText.textContent = "Erro ao carregar. Verifique o console.";
            this.loadingText.style.color = "red";
        }
    }
    
    /**
     * Carrega os dados do arquivo /data/arts.json
     * (Precisa de um servidor local - ver como_rodar.txt)
     */
    async loadArtworkData() {
        try {
            // Usa 'fetch' para buscar o arquivo JSON
            const response = await fetch('data/arts.json');
            if (!response.ok) {
                // Se o arquivo não for encontrado (404) ou der erro, falha
                throw new Error(`Erro HTTP! Status: ${response.status}`);
            }
            this.artworkData = await response.json();
            
            // Validação
            if (this.artworkData.length !== 18) {
                console.warn(`Aviso: 'arts.json' contém ${this.artworkData.length} artes. O corredor foi projetado para 18.`);
            }
            
        } catch (error) {
            console.error("Não foi possível carregar 'data/arts.json':", error);
            // Re-lança o erro para o 'init' principal tratar
            throw error; 
        }
    }

    /**
     * Chamado quando o Loader termina (onLoad).
     */
    startExperience() {
        console.log("Assets carregados. Iniciando a experiência.");
        this.isLoaded = true;
        
        // 1. Construir o Mundo 1 (Floresta)
        const world1Data = this.worldFactory.createWorld1(this.scene);
        this.world1_Group = world1Data.group;
        this.scene.add(this.world1_Group);

        // 2. Inicializar Controles
        this.controls = new PlayerControls(this.camera, this.canvas, this.settings);
        // Define os limites de colisão para o mundo 1
        this.controls.setWorld(1, world1Data.collisionLimits);
        
        // 3. Inicializar Interação
        this.interaction = new InteractionHandler(
            this.camera, 
            this.scene, 
            this.handleInteraction.bind(this) // Callback
        );
        
        // 4. Conectar Controles e Interação
        // Diz ao 'controls' qual função chamar quando [E] é pressionado
        this.controls.onInteract = () => {
            this.interaction.triggerInteraction();
        };

        // 5. Esconder a tela de Loading e mostrar a UI do Jogo
        this.loadingScreen.style.opacity = '0';
        setTimeout(() => {
            this.loadingScreen.style.display = 'none';
        }, 500); // 0.5s (duração da transição do CSS)

        // Mostra a UI (Mira, Logo, etc.)
        this.uiElements.forEach(el => el.style.display = 'block');
        
        // 6. Iniciar o Loop de Animação
        this.animate();
    }
    
    // -----------------------------------------------------------------
    // LOOP DE ANIMAÇÃO (GAME LOOP)
    // -----------------------------------------------------------------

    /**
     * O Loop Principal (requestAnimationFrame).
     */
    animate() {
        // Pede ao navegador para chamar 'animate' no próximo frame
        requestAnimationFrame(this.animate);

        // Se não carregou ou está em transição, não faz nada
        if (!this.isLoaded || this.isTransitioning) {
            return;
        }

        // Pega o tempo delta (diferença do último frame)
        const delta = this.clock.getDelta();

        // 1. Atualiza o handler de interação (verifica o que está na mira)
        this.interaction.update();
        
        // 2. Atualiza os controles do jogador (movimento, colisão)
        this.controls.update(delta);

        // 3. Renderiza a cena 3D
        this.renderer.render(this.scene, this.camera);
    }
    
    // -----------------------------------------------------------------
    // LÓGICA DE TRANSIÇÃO E INTERAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Callback chamado pelo 'InteractionHandler' quando [E] é pressionado
     * em um alvo válido.
     * @param {Object} userData - Os dados do objeto (ex: { type: 'gothic_door' })
     */
    handleInteraction(userData) {
        console.log("Interação disparada:", userData);
        
        // Verifica se é a porta gótica E se estamos no mundo 1
        if (userData.type === 'gothic_door' && this.currentWorldId === 1) {
            this.triggerSceneTransition();
        }
        
        // Lógica para mostrar info da arte no Mundo 2
        if (userData.type === 'artwork' && this.currentWorldId === 2) {
            console.log(`Clicou na Arte: ${userData.title}`);
            // (Ação Futura): Abrir um modal com `userData.title` e `userData.description`
            alert(`Arte: ${userData.title}\nDescrição: ${userData.description}`);
        }
    }

    /**
     * Executa o "Theater Effect" (Transição da Cena 1 para a Cena 2).
     */
    triggerSceneTransition() {
        if (this.isTransitioning) return; // Previne transições duplas
        
        console.log("Iniciando transição de cena...");
        this.isTransitioning = true; // Pausa o 'animate' loop

        // 1. Fade In Rápido (0.5s) para Branco
        this.transitionFade.style.transition = 'opacity 0.5s ease-in';
        this.transitionFade.style.opacity = '1';

        // 2. Atraso de 500ms (enquanto a tela está branca)
        setTimeout(() => {
            // --- O TELEPORTE (acontece instantaneamente) ---
            
            // a. Remove a geometria do Mundo 1
            this.scene.remove(this.world1_Group);
            
            // b. Constrói e adiciona a geometria do Mundo 2
            // Passa os dados do JSON (this.artworkData) para a fábrica
            const world2Data = this.worldFactory.createWorld2(this.scene, this.artworkData);
            this.world2_Group = world2Data.group;
            this.scene.add(this.world2_Group);

            // c. Teleporta o Jogador (Z=10, conforme requisito)
            this.camera.position.set(0, this.settings.playerHeight, 10);
            
            // d. Reseta a Rotação da Câmera (olhar reto)
            this.controls.resetRotation();

            // e. Atualiza os controles para os limites de colisão do Mundo 2
            this.controls.setWorld(2, world2Data.collisionLimits);
            this.currentWorldId = 2;
            
            // --- FIM DO TELEPORTE ---

            // 3. Fade Out Lento (1.5s) do Branco (olhos se ajustando)
            this.transitionFade.style.transition = 'opacity 1.5s ease-out';
            this.transitionFade.style.opacity = '0';
            
            // 4. Atraso de 1500ms (espera o fade out terminar)
            setTimeout(() => {
                this.isTransitioning = false; // Retoma o 'animate' loop
                console.log("Transição completa. Mundo 2 carregado.");
            }, 1500);

        }, 500); // Fim do setTimeout do Fade In
    }

    // -----------------------------------------------------------------
    // UTILITÁRIOS
    // -----------------------------------------------------------------

    /**
     * Chamado quando a janela do navegador muda de tamanho.
     */
    onWindowResize() {
        // Atualiza as proporções da câmera
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();

        // Atualiza o tamanho do renderizador
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}

// -----------------------------------------------------------------
// PONTO DE ENTRADA
// -----------------------------------------------------------------

// Quando o DOM (HTML) estiver pronto, cria e inicializa a aplicação.
window.addEventListener('DOMContentLoaded', () => {
    // Lembrete sobre o servidor local (para o 'fetch' funcionar)
    if (window.location.protocol === 'file:') {
        console.error("ERRO: O projeto não pode ser executado localmente via 'file://'. Use um servidor local (veja como_rodar.txt).");
        document.body.innerHTML = '<div style="color: red; font-size: 20px; padding: 20px;">ERRO: O projeto não pode ser executado localmente. Por favor, use um servidor (veja o arquivo como_rodar.txt).</div>';
        return;
    }
    
    const app = new SungApp();
    app.init();
});
js/scene.js (ATUALIZADO)
(Esta é a maior mudança. Mudei toda a lógica de createWorld1 para criar o mapa aberto, a trilha escondida e a trilha de cristais).

JavaScript
/*
    ARQUIVO: scene.js
    DESCRIÇÃO: Construtor de Cenários 3D.
    FUNÇÃO: Esta classe é uma "fábrica" de geometria. Ela não
    mantém estado, apenas contém métodos que criam e retornam
    os mundos (Cena 1 e Cena 2) como grupos de objetos (THREE.Group).
    
    COMENTÁRIOS: PT-BR
*/

class WorldSceneFactory {

    constructor(textures) {
        // Armazena as texturas que o 'loader.js' carregou.
        this.textures = textures;
        // Altura padrão da câmera (nível dos olhos)
        this.playerHeight = 1.6;
    }

    // -----------------------------------------------------------------
    // CENA 1: A DESCOBERTA (HIGHWAY / FLORESTA)
    // -----------------------------------------------------------------
    createWorld1(scene) {
        const world1Group = new THREE.Group();
        world1Group.name = "World1_Group"; // Nome para depuração

        // 1. Configuração do Clima (Névoa e Luz)
        // Cor cinza-azulado escuro, inspirada em 'clima.png' (Sleepy Hollow)
        const fogColor = 0x2c3e50; 
        scene.background = new THREE.Color(fogColor);
        // A névoa começa perto e fica densa rapidamente
        scene.fog = new THREE.Fog(fogColor, 1, 40); // <-- Névoa um pouco mais distante

        // Luz ambiente fraca, para dar o tom sombrio
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // (cor, intensidade)
        world1Group.add(ambientLight);

        // Luz direcional (simulando lua/crepúsculo)
        const directionalLight = new THREE.DirectionalLight(0x505a70, 0.4);
        directionalLight.position.set(5, 10, 5);
        world1Group.add(directionalLight);

        
        // 2. Geometria do Chão (Mundo Aberto)
        
        // Chão da Floresta (Ground082S) - O MAPA INTEIRO
        const forestFloorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.forest_floor });
        const forestFloorGeometry = new THREE.PlaneGeometry(200, 200); // 200m x 200m
        const forestFloor = new THREE.Mesh(forestFloorGeometry, forestFloorMaterial);
        forestFloor.rotation.x = -Math.PI / 2;
        forestFloor.position.set(0, 0, 0); // Centralizado na origem
        world1Group.add(forestFloor);

        // Rodovia (Asphalt033) - PONTO DE INÍCIO
        const roadMaterial = new THREE.MeshBasicMaterial({ map: this.textures.rodovia });
        const roadGeometry = new THREE.PlaneGeometry(15, 60); // (largura, comprimento)
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; 
        road.position.set(0, 0.01, 70); // Na borda do mapa (Z=70 a Z=100)
        world1Group.add(road);

        // Trilha de Tijolos ESCONDIDA (Bricks075B)
        const pathMaterial = new THREE.MeshBasicMaterial({ map: this.textures.path });
        const pathGeometry = new THREE.PlaneGeometry(3, 40); // Trilha estreita (3m x 40m)
        const path = new THREE.Mesh(pathGeometry, pathMaterial);
        path.rotation.x = -Math.PI / 2;
        // Posição escondida dentro da floresta
        path.position.set(30, 0.01, -20); // Escondida em X=30, Z=-20
        world1Group.add(path);


        // 3. Floresta Densa (Billboards de Árvores)
        // Material da árvore (usa 'arvore.png')
        const treeMaterial = new THREE.SpriteMaterial({ 
            map: this.textures.tree,
            fog: true,
            color: 0xcccccc 
        });
        
        // Material do brilho do cristal
        const crystalMaterial = new THREE.SpriteMaterial({
            map: this.textures.crystalGlow,
            blending: THREE.AdditiveBlending, // Efeito de brilho
            fog: false, // Cristais brilham através da névoa
            transparent: true,
            opacity: 0.8
        });

        // Material da Rocha
        const rockMaterial = new THREE.SpriteMaterial({
            map: this.textures.rock,
            fog: true,
            color: 0xbbbbbb 
        });

        // Cria 2000 árvores para densidade
        for (let i = 0; i < 2000; i++) {
            const sprite = new THREE.Sprite(treeMaterial);
            
            const x = (Math.random() - 0.5) * 200; // X de -100 a 100
            const z = (Math.random() - 0.5) * 200; // Z de -100 a 100

            // *** LÓGICA PARA NÃO NASCER ÁRVORE NA ESTRADA OU NA TRILHA ***
            // Checa área da estrada (X -7.5 a 7.5, Z 40 a 100)
            if (x > -7.5 && x < 7.5 && z > 40 && z < 100) {
                continue; // Pula esta árvore
            }
            // Checa área da trilha (X 28.5 a 31.5, Z -40 a 0)
            if (x > 28.5 && x < 31.5 && z > -40 && z < 0) {
                continue; // Pula esta árvore
            }

            // Tamanho aleatório (árvores grandes e médias)
            const scale = Math.random() * 3 + 4; // Escala entre 4m e 7m
            sprite.scale.set(scale, scale, 1);
            sprite.position.set(x, scale / 2, z); // (x, altura, z)
            world1Group.add(sprite);
        }

        // Adiciona Rochas (100)
        for (let i = 0; i < 100; i++) {
            const rockSprite = new THREE.Sprite(rockMaterial);
            const x = (Math.random() - 0.5) * 200; 
            const z = (Math.random() - 0.5) * 200;
            
            // Checa área da estrada
            if (x > -7.5 && x < 7.5 && z > 40 && z < 100) continue; 
            // Checa área da trilha
            if (x > 28.5 && x < 31.5 && z > -40 && z < 0) continue; 

            const scale = Math.random() * 0.5 + 0.5; // Rochas pequenas (0.5m a 1m)
            rockSprite.scale.set(scale, scale, 1);
            rockSprite.position.set(x, scale / 2, z); // No chão
            world1Group.add(rockSprite);
        }

        // 4. A Pista de Cristais (As "Migalhas de Pão")
        // Coloca 15 cristais guiando da estrada até a trilha escondida
        const crystalPath = [
            {x: 5, z: 60},
            {x: 10, z: 55},
            {x: 15, z: 50},
            {x: 20, z: 40},
            {x: 25, z: 30},
            {x: 30, z: 20},
            {x: 30, z: 10},
            {x: 30, z: 0}, // Chegou na trilha
            {x: 30, z: -10},
            {x: 30, z: -20},
            {x: 30, z: -30} // Perto da porta
        ];

        crystalPath.forEach(pos => {
            // Luz Pontual (azulada)
            const light = new THREE.PointLight(0xadd8e6, 1.5, 8); // (cor, intensidade, distância)
            light.position.set(pos.x, 1.5, pos.z); // Posição
            world1Group.add(light);
            
            // Sprite visual do cristal
            const crystalSprite = new THREE.Sprite(crystalMaterial);
            crystalSprite.position.copy(light.position);
            crystalSprite.scale.set(1.5, 2.5, 1); 
            world1Group.add(crystalSprite);
        });


        // 5. A Porta Gótica (Objetivo)
        // Simula a "rocha" onde a porta está
        const rockFaceMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 }); 
        const rockFaceGeometry = new THREE.PlaneGeometry(8, 8); // Parede de rocha
        const rockFace = new THREE.Mesh(rockFaceGeometry, rockFaceMaterial);
        // Posicionada no final da trilha escondida
        rockFace.position.set(30, 4, -40.5); // (x, altura, z)
        world1Group.add(rockFace);
        
        // A porta em si
        const doorMaterial = new THREE.MeshBasicMaterial({ 
            map: this.textures.porta,
            transparent: true 
        });
        const doorGeometry = new THREE.PlaneGeometry(4, 5); // Tamanho da porta
        const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
        
        // Posiciona no final da trilha, em frente à rocha
        doorMesh.position.set(30, 2.5, -40); // (x, altura, z)
        
        // Adiciona o 'userData' para interação
        doorMesh.userData = { 
            interactive: true, 
            type: 'gothic_door' 
        };
        world1Group.add(doorMesh);


        // 6. Limites de Colisão (Mundo Aberto)
        // Agora, os limites são apenas as bordas do mapa (chão da floresta)
        const worldLimits = {
            minX: -98, // 2m de margem
            maxX: 98,
            minZ: -98,
            maxZ: 98
        };

        // Retorna o grupo de objetos e os limites de colisão
        return { group: world1Group, collisionLimits: worldLimits };
    }


    // -----------------------------------------------------------------
    // CENA 2: A GALERIA (CORREDOR)
    // -----------------------------------------------------------------
    createWorld2(scene, artworkData) { // Recebe os dados do JSON
        const world2Group = new THREE.Group();
        world2Group.name = "World2_Group";

        // 1. Limpa a Névoa e Luz da Cena 1
        scene.fog = null; // Remove a névoa
        scene.background = new THREE.Color(0x000000); // Fundo preto

        // Luz ambiente muito escura (soturna)
        const ambientLight = new THREE.AmbientLight(0x101010, 1.0); // (cor, intensidade)
        world2Group.add(ambientLight);

        // Luz "falsa" no teto (HemisphereLight)
        const hemiLight = new THREE.HemisphereLight(0x404040, 0x080808, 0.5);
        world2Group.add(hemiLight);

        // 2. Geometria do Corredor
        const corridorLength = 80;
        const corridorWidth = 5;
        const corridorHeight = 4;

        // Chão (Usa 'floor_texture.jpg')
        const floorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.floor });
        const floorGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, 0, corridorLength / 2); 
        world1Group.add(floor);

        // Teto
        const ceilMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 }); // Teto escuro
        const ceilGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const ceil = new THREE.Mesh(ceilGeometry, ceilMaterial);
        ceil.rotation.x = Math.PI / 2;
        ceil.position.set(0, corridorHeight, corridorLength / 2);
        world2Group.add(ceil);

        // Parede Esquerda (Usa 'wall_texture.jpg')
        const wallMaterial = new THREE.MeshBasicMaterial({ map: this.textures.wall });
        const wallGeometry = new THREE.PlaneGeometry(corridorLength, corridorHeight);
        const wallLeft = new THREE.Mesh(wallGeometry, wallMaterial);
        wallLeft.rotation.y = Math.PI / 2;
        wallLeft.position.set(-corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallLeft);

        // Parede Direita (Usa 'wall_texture.jpg')
        const wallRight = new THREE.Mesh(wallGeometry, wallMaterial);
        wallRight.rotation.y = -Math.PI / 2;
        wallRight.position.set(corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallRight);

        // Parede do Fundo (Fechando o corredor)
        const endWallGeom = new THREE.PlaneGeometry(corridorWidth, corridorHeight);
        const endWall = new THREE.Mesh(endWallGeom, wallMaterial);
        endWall.position.set(0, corridorHeight / 2, corridorLength);
        world2Group.add(endWall);

        // 3. Criação das Obras de Arte (Quadros)
        const spacing = corridorLength / 9;
        const frameSize = 2.0; 
        const frameHeight = this.playerHeight + 0.2; 

        // Itera sobre os dados do JSON (artworkData)
        artworkData.forEach((artwork, index) => {
            const artTexture = this.textures[`art_${artwork.id}`];
            const artMaterial = new THREE.MeshBasicMaterial({ map: artTexture });

            const artGeometry = new THREE.PlaneGeometry(frameSize, frameSize);
            const artMesh = new THREE.Mesh(artGeometry, artMaterial);
            
            // Placa de interação (hitbox)
            const plaqueGeometry = new THREE.PlaneGeometry(frameSize + 1, frameSize + 1);
            const plaqueMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const plaqueMesh = new THREE.Mesh(plaqueGeometry, plaqueMaterial);
            
            plaqueMesh.userData = {
                interactive: true,
                type: 'artwork',
                id: artwork.id,
                title: artwork.title,
                description: artwork.description
            };

            const zPos = 10 + (index % 9) * (spacing * 0.9);

            if (index < 9) {
                // Lado Esquerdo
                artMesh.position.set((-corridorWidth / 2) + 0.05, frameHeight, zPos);
                artMesh.rotation.y = Math.PI / 2; 
                plaqueMesh.position.set((-corridorWidth / 2) + 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = Math.PI / 2;
            } else {
                // Lado Direito
                artMesh.position.set((corridorWidth / 2) - 0.05, frameHeight, zPos);
                artMesh.rotation.y = -Math.PI / 2; 
                plaqueMesh.position.set((corridorWidth / 2) - 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = -Math.PI / 2;
            }
            world2Group.add(artMesh);
            world2Group.add(plaqueMesh); 
        });

        // 4. Limites de Colisão (Corredor)
        const collisionLimits = {
            minX: -corridorWidth / 2 + 0.5, 
            maxX: corridorWidth / 2 - 0.5,
            minZ: 0.5, 
            maxZ: corridorLength - 0.5 
        };
        
        // Retorna o grupo e os limites
        return { group: world2Group, collisionLimits: collisionLimits };
    }
}
js/controls.js (ATUALIZADO)
(A única mudança é na função applyCollisions, para permitir a exploração livre no Mundo 1).

JavaScript
/*
    ARQUIVO: controls.js
    DESCRIÇÃO: Gerenciador de Controles do Jogador (Input Handler).
    FUNÇÃO: Esta classe gerencia TODO o input do usuário:
    - Movimentação (WASD / Setas / D-Pad Mobile).
    - Rotação da Câmera (Mouse / Toque Mobile).
    - Ações (Tecla [E] / Botão de Ação Mobile).
    - Lógica de Colisão (limitando a posição do jogador).
    
    COMENTÁRIOS: PT-BR
*/

class PlayerControls {

    /**
     * @param {THREE.Camera} camera - A câmera do jogador.
     * @param {HTMLElement} domElement - O elemento canvas (para eventos).
     * @param {Object} settings - Configurações de velocidade e sensibilidade.
     */
    constructor(camera, domElement, settings) {
        this.camera = camera;
        this.domElement = domElement;
        this.settings = settings;

        // Referência à função de interação (definida em main.js)
        this.onInteract = () => {}; 
        
        // Estado de movimento
        this.moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        // Estado da Câmera (Mouse Look)
        this.cameraLook = {
            pitch: 0, // Rotação vertical (X)
            yaw: 0   // Rotação horizontal (Y)
        };
        
        // Propriedades de física/movimento
        this.velocity = new THREE.Vector3();
        this.direction = new THREE.Vector3();

        // Configurações do mundo atual (Cena 1 ou Cena 2)
        this.currentWorld = 1;
        this.collisionLimits = null; // Limites de colisão do mundo atual
        
        // Detecção de Mobile (baseado em 'touchstart')
        this.isMobile = 'ontouchstart' in window;
        
        // Armazena o ID do toque de movimento (para multi-toque)
        this.moveTouchId = null; 
        this.lookTouchId = null;
        this.lastLookPos = { x: 0, y: 0 };
        
        // Ajusta a sensibilidade para mobile (conforme UX finalizado)
        this.sensitivity = this.isMobile ? 
            this.settings.mobileCameraSpeed : 
            this.settings.desktopCameraSpeed;

        // Inicializa os ouvintes de eventos
        this.initListeners();
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO DOS OUVINTES DE EVENTO
    // -----------------------------------------------------------------
    initListeners() {
        if (this.isMobile) {
            // Se for mobile, inicializa os controles de toque
            this.initMobileControls();
        } else {
            // Se for desktop, inicializa o Pointer Lock (travar mouse)
            this.initPointerLock();
            // E os ouvintes de teclado
            document.addEventListener('keydown', this.onKeyDown.bind(this));
            document.addEventListener('keyup', this.onKeyUp.bind(this));
        }
    }

    // (Desktop) Configura o Pointer Lock
    initPointerLock() {
        this.domElement.addEventListener('click', () => {
            this.domElement.requestPointerLock();
        });

        // Ouve o movimento do mouse APENAS quando o mouse está travado
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === this.domElement) {
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
            } else {
                document.removeEventListener('mousemove', this.onMouseMove.bind(this));
            }
        });
    }

    // (Mobile) Configura os botões de toque
    initMobileControls() {
        // Mostra os botões de D-Pad e Ação
        document.getElementById('dpad-container').style.display = 'grid';
        document.getElementById('action-btn').style.display = 'block';

        // Ouvintes do D-Pad (touchstart = pressionar, touchend = soltar)
        this.addTouchListener('dpad-forward', 'forward');
        this.addTouchListener('dpad-backward', 'backward');
        this.addTouchListener('dpad-left', 'left');
        this.addTouchListener('dpad-right', 'right');

        // Ouvinte do Botão de Ação
        document.getElementById('action-btn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.onInteract(); // Chama a função de interação
        });
        
        // Ouvinte de Toque na Tela (para olhar ao redor)
        this.domElement.addEventListener('touchstart', this.onMobileTouchStart.bind(this));
        this.domElement.addEventListener('touchmove', this.onMobileTouchMove.bind(this));
        this.domElement.addEventListener('touchend', this.onMobileTouchEnd.bind(this));
    }

    // (Mobile) Função auxiliar para adicionar ouvintes de toque
    addTouchListener(elementId, direction) {
        const element = document.getElementById(elementId);
        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.moveState[direction] = true;
        });
        element.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.moveState[direction] = false;
        });
    }

    // -----------------------------------------------------------------
    // HANDLERS DE EVENTO (MOVIMENTO / AÇÃO)
    // -----------------------------------------------------------------

    // (Desktop) Tecla pressionada
    onKeyDown(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = true; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = true; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = true; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = true; break;
            case 'KeyE': this.onInteract(); break; // Tecla de Interação [E]
        }
    }

    // (Desktop) Tecla solta
    onKeyUp(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = false; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = false; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = false; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = false; break;
        }
    }

    // (Desktop) Movimento do mouse (Pointer Lock)
    onMouseMove(event) {
        if (document.pointerLockElement !== this.domElement) return;

        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;

        // Rotação Horizontal (Yaw) - Eixo Y
        this.cameraLook.yaw -= movementX * this.sensitivity;
        
        // Rotação Vertical (Pitch) - Eixo X
        this.cameraLook.pitch -= movementY * this.sensitivity;
        
        // Trava a rotação vertical (para não "quebrar o pescoço")
        this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
        
        // Aplica as rotações (Ordem EULER_YXZ é importante para FPS)
        this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
    }

    // (Mobile) Início do toque na tela
    onMobileTouchStart(event) {
        event.preventDefault();
        // Itera sobre os toques
        for (const touch of event.changedTouches) {
            // Se o toque for na metade direita da tela, é para "olhar"
            if (touch.clientX > window.innerWidth / 2 && this.lookTouchId === null) {
                this.lookTouchId = touch.identifier;
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;
            }
        }
    }

    // (Mobile) Movimento do toque na tela (Olhar)
    onMobileTouchMove(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se for o toque que estamos rastreando para "olhar"
            if (touch.identifier === this.lookTouchId) {
                const deltaX = touch.clientX - this.lastLookPos.x;
                const deltaY = touch.clientY - this.lastLookPos.y;

                // Salva a nova posição
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;

                // Aplica a rotação (similar ao onMouseMove)
                this.cameraLook.yaw -= deltaX * this.sensitivity;
                this.cameraLook.pitch -= deltaY * this.sensitivity;
                this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
                
                this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
            }
        }
    }

    // (Mobile) Fim do toque na tela
    onMobileTouchEnd(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se o toque que terminou era o de "olhar", para de rastrear
            if (touch.identifier === this.lookTouchId) {
                this.lookTouchId = null;
            }
        }
    }


    // -----------------------------------------------------------------
    // ATUALIZAÇÃO (LOOP PRINCIPAL) E COLISÃO
    // -----------------------------------------------------------------

    /**
     * Define os limites de colisão do mundo atual.
     * @param {number} worldId - 1 para Floresta, 2 para Corredor.
     * @param {Object} limits - O objeto de limites vindo de 'scene.js'.
     */
    setWorld(worldId, limits) {
        this.currentWorld = worldId;
        this.collisionLimits = limits;
    }
    
    /**
     * Reseta a rotação da câmera (usado na transição).
     */
    resetRotation() {
        this.cameraLook.pitch = 0;
        this.cameraLook.yaw = 0;
        this.camera.rotation.set(0, 0, 0, 'YXZ');
    }

    /**
     * Chamado a cada frame pelo 'main.js'.
     * @param {number} delta - O tempo (em segundos) desde o último frame.
     */
    update(delta) {
        // Velocidade = 1.8 m/s (conforme UX finalizado)
        const moveSpeed = this.settings.movementSpeed * delta;

        // Reseta a direção do movimento
        this.direction.z = Number(this.moveState.forward) - Number(this.moveState.backward);
        this.direction.x = Number(this.moveState.left) - Number(this.moveState.right);
        this.direction.normalize(); // Garante movimento consistente (diagonal != mais rápido)

        // Salva a posição atual para checagem de colisão
        const oldPosition = this.camera.position.clone();

        // Calcula o movimento relativo à direção que a câmera está olhando
        if (this.moveState.forward || this.moveState.backward) {
            this.camera.translateZ(-this.direction.z * moveSpeed);
        }
        if (this.moveState.left || this.moveState.right) {
            this.camera.translateX(-this.direction.x * moveSpeed);
        }

        // --- LÓGICA DE COLISÃO ---
        // Impede o jogador de sair dos limites definidos
        if (this.collisionLimits) {
            this.applyCollisions(oldPosition);
        }
        
        // Mantém a altura do jogador (impede de voar ou afundar)
        this.camera.position.y = this.settings.playerHeight;
    }

    /**
     * Verifica e aplica as colisões baseadas nos limites do mundo.
     * @param {THREE.Vector3} oldPosition - Posição antes do movimento.
     */
    applyCollisions(oldPosition) {
        const newPosition = this.camera.position;
        const limits = this.collisionLimits;

        // Lógica de Colisão simples de "caixa" (para ambos os mundos)
        // Isso nos dá a liberdade de explorar no Mundo 1
        newPosition.x = Math.max(limits.minX, Math.min(limits.maxX, newPosition.x));
        newPosition.z = Math.max(limits.minZ, Math.min(limits.maxZ, newPosition.z));
        
        // Aplica a posição corrigida
        this.camera.position.copy(newPosition);
    }
}
vamos refazer todo o codigo pq eu aco mais facil

Certo, vamos fazer isso.

Aqui está o projeto completo, do zero, com a lógica mais recente que desenvolvemos:

Cena 1: Um "mundo aberto" (floresta 200x200m) para explorar.

Ponto de Início: Você começa em uma rodovia na borda da floresta.

Objetivo: Você precisa procurar uma trilha de tijolos escondida.

Pista: Uma "trilha" de cristais luminosos guia você da rodovia até a trilha escondida.

Transição: No final da trilha escondida, você encontra a porta gótica.

Cena 2: A galeria (corredor) com as 18 artes.

IMPORTANTE: Esta estrutura de código assume que você tem a seguinte estrutura de pastas (baseada na sua captura de tela image_bcc321.png e nossas conversas):

/
│
├── index.html
├── README.md
├── COMO_EDITAR.txt
├── como_rodar.txt
├── checklist.txt
│
├── assets/
│   ├── belial.png
│   ├── rodovia_texture.jpg  (Asfalto)
│   ├── porta.png            (Sua referência)
│   ├── arvore.png           (Árvore com fundo transparente)
│   ├── path_texture.jpg     (Os Tijolos)
│   ├── forest_floor.jpg     (A Terra Molhada)
│   ├── wall_texture.jpg     (Parede do corredor)
│   ├── floor_texture.jpg    (Chão do corredor)
│   ├── crystal_glow.png     (Brilho)
│   ├── rock.png             (Rocha)
│   └── audio/ (Vazio)
│
├── CSS/  <-- (MAIÚSCULO, como na sua imagem)
│   └── styles.css
│
├── data/
│   └── arts.json
│
├── img/
│   ├── tattoo_01.png
│   └── ... (etc.)
│
└── js/
    ├── main.js
    ├── scene.js
    ├── controls.js
    ├── interaction.js
    └── loader.js
index.html
HTML
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sung Studios - 3D Portfolio</title>
    
    <link rel="stylesheet" href="CSS/styles.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-text">Carregando...</div>
    </div>

    <div id="rotate-message">
        <p>Por favor, gire seu dispositivo para a posição horizontal (paisagem) para iniciar a experiência.</p>
    </div>

    <div id="transition-fade"></div>

    <div id="crosshair">+</div>

    <div id="dpad-container">
        <button id="dpad-forward" class="dpad-btn">▲</button>
        <button id="dpad-backward" class="dpad-btn">▼</button>
        <button id="dpad-left" class="dpad-btn">◄</button>
        <button id="dpad-right" class="dpad-btn">►</button>
    </div>

    <button id="action-btn">E</button>

    <div id="logo">
        <img src="assets/belial.png" alt="Sung Studios Logo">
    </div>
    <div id="copyright">© 2025 Sung</div>

    <canvas id="game-canvas"></canvas>

    <script src="js/loader.js"></script>
    <script src="js/scene.js"></script>
    <script src="js/controls.js"></script>
    <script src="js/interaction.js"></script>
    <script src="js/main.js"></script>

</body>
</html>
README.md
Markdown
# Sung Studios - Portfólio 3D Gótico

Este é o repositório do projeto para o site interativo 3D "Sung Studios", um portfólio de tatuagem com tema de horror cinematográfico.

## Visão Geral

O projeto é uma experiência narrativa em primeira pessoa que guia o usuário por duas cenas distintas:
1.  **A Descoberta:** Uma floresta escura e aberta (200x200m) para explorar. O jogador começa em uma rodovia e deve seguir uma trilha de cristais luminosos para encontrar uma trilha de tijolos escondida, que leva à porta gótica.
2.  **A Galeria:** Um corredor linear e sombrio onde as 18 artes do portfólio estão em exibição.

A experiência é construída com uma estética de horror sutil, inspirada em *Sleepy Hollow* de Tim Burton.

## Stack Técnica

* **HTML5**
* **CSS3**
* **JavaScript (ES6+)**
* **Three.js** (incluído via CDN)

## Estrutura de Arquivos

* `/index.html` (Página principal)
* `/CSS/styles.css` (Folha de estilos)
* `/data/arts.json` (Dados das obras de arte)
* `/js/*.js` (Scripts da aplicação)
* `/assets/` (Texturas principais, como `rodovia_texture.jpg`, `porta.png`, `arvore.png`, etc.)
* `/img/` (As 18 imagens de tatuagem da galeria)
* `/assets/audio/` (Reservado para sons)

## Instruções de Edição

Para adicionar ou alterar as artes exibidas no corredor, consulte o arquivo `COMO_EDITAR.txt` para instruções detalhadas.

## Como Rodar

Consulte `como_rodar.txt` para instruções sobre como iniciar um servidor local, que é **obrigatório** para carregar os assets.

---
© 2025 Sung
COMO_EDITAR.txt
Plaintext
=================================================
GUIA DE MANUTENÇÃO - SUNG STUDIOS (PT-BR)
=================================================

Este arquivo explica como atualizar o conteúdo do site 3D sem precisar mexer no código principal.

-------------------------------------------------
1. COMO ADICIONAR OU MUDAR AS TATUAGENS (OBRAS DE ARTE)
-------------------------------------------------

Toda a galeria no "Mundo 2" (O Corredor) é gerada automaticamente a partir de um único arquivo.

ARQUIVO PARA EDITAR: /data/arts.json

PASSO 1: ADICIONE SUAS IMAGENS
1.  Pegue seus 18 arquivos de imagem (.png ou .jpg).
2.  Renomeie-os para nomes simples (ex: 'tattoo_01.png', 'tattoo_02.png', etc.).
3.  Coloque TODOS os 18 arquivos dentro da pasta: /img/

PASSO 2: ATUALIZE O ARQUIVO 'arts.json'
1.  Abra o arquivo /data/arts.json em um editor de texto.
2.  Você verá uma lista (array) `[ ... ]` de objetos `{ ... }`.
3.  Cada objeto `{}` representa uma obra de arte.

Exemplo de um objeto:
{
    "id": 1,
    "image": "img/tattoo_01.png",            // <-- MUDE ESTE CAMINHO
    "title": "Nome da Arte 1",                  // <-- MUDE O TÍTULO
    "description": "Descrição da sua arte aqui."  // <-- MUDE A DESCRIÇÃO
},

4.  Para cada uma das 18 obras, atualize:
    * `image`: Coloque o caminho exato para a imagem na pasta /img/.
    * `title`: O título que aparecerá.
    * `description`: O texto de descrição.

5.  **IMPORTANTE**: O formato JSON exige aspas duplas ("") em todas as chaves (como "id") e valores de texto. O último item da lista NÃO deve ter uma vírgula no final.

6.  Salve o arquivo. O site será atualizado automaticamente.

-------------------------------------------------
2. COMO MUDAR TEXTURAS DO CENÁRIO (AVANÇADO)
-------------------------------------------------

PASTA DE TEXTURAS: /assets/

* `rodovia_texture.jpg`: A textura do asfalto da estrada.
* `porta.png`: A textura da porta gótica (sua referência).
* `belial.png`: O logo no canto da tela.
* `arvore.png`: A imagem da árvore usada na floresta (formato billboard).
* `path_texture.jpg`: A textura dos tijolos da trilha escondida.
* `forest_floor.jpg`: A textura de terra molhada da floresta.
* `wall_texture.jpg`: A textura das paredes do corredor.
* `floor_texture.jpg`: A textura do chão do corredor.
* `crystal_glow.png`: A imagem do brilho do cristal (fundo transparente).
* `rock.png`: A imagem da rocha na floresta (fundo transparente).

Basta substituir o arquivo de imagem nesta pasta pelo seu novo arquivo, MANTENDO O MESMO NOME E EXTENSÃO.
como_rodar.txt
Plaintext
=================================================
COMO RODAR O PROJETO (PT-BR)
=================================================

Este projeto **NÃO FUNCIONA** se você apenas abrir o arquivo `index.html` diretamente no navegador (ex: `file:///C:/.../index.html`).

Isso acontece por causa das políticas de segurança (CORS) dos navegadores, que bloqueiam o carregamento de texturas e arquivos de dados (como o `arts.json`) dessa maneira.

Você **PRECISA** de um servidor local.

-------------------------------------------------
COMO RODAR (MÉTODO FÁCIL - VS CODE)
-------------------------------------------------

1.  Abra a pasta do projeto no Visual Studio Code (VS Code).
2.  Vá até a aba "Extensions" (Extensões) na barra lateral.
3.  Procure por "Live Server" (feito por Ritwick Dey).
4.  Instale a extensão.
5.  Depois de instalado, volte para a lista de arquivos.
6.  Clique com o botão direito no arquivo `index.html`.
7.  Selecione "Open with Live Server" (Abrir com Live Server).

Isso iniciará um servidor local (ex: `http://127.0.0.1:5500`) e o projeto funcionará.

-------------------------------------------------
COMO RODAR (MÉTODO ALTERNATIVO - PYTHON)
-------------------------------------------------

Se você tem Python 3 instalado:

1.  Abra o terminal (Prompt de Comando, PowerShell, etc.).
2.  Navegue até a pasta raiz do projeto (onde o `index.html` está).
3.  Digite o comando:
    `python -m http.server`
4.  Abra o seu navegador e acesse:
    `http://localhost:8000`
checklist.txt
Plaintext
=================================================
CHECKLIST DE ASSETS DO PROJETO (PT-BR)
=================================================

Verifique se todos os assets (arquivos de mídia) necessários estão nas pastas corretas antes de testar o projeto.

### 1. Imagens de Cenário (Obrigatórias)
Local: /assets/

[ ] belial.png             (Logo "Sung" que aparece no canto)
[ ] rodovia_texture.jpg    (Textura de asfalto molhado)
[ ] porta.png              (Textura da porta gótica - IMAGEM QUE VOCÊ FORNECEU)
[ ] arvore.png             (Imagem da árvore com fundo transparente para a floresta)
[ ] path_texture.jpg       (Textura de tijolos escuros para a trilha)
[ ] forest_floor.jpg     (Textura de terra molhada para a floresta)
[ ] wall_texture.jpg       (Textura das paredes da galeria/corredor)
[ ] floor_texture.jpg      (Textura do chão da galeria/corredor)
[ ] crystal_glow.png       (Textura de brilho para os cristais, ex: um ponto suave)
[ ] rock.png               (Imagem de rocha com fundo transparente)

### 2. Imagens da Galeria (Obrigatórias)
Local: /img/

[ ] tattoo_01.png
[ ] tattoo_02.png
... (Total de 18 imagens de tatuagem)

### 3. Áudio (Opcional)
Local: /assets/audio/
(Vazio por enquanto)
CSS/styles.css
CSS
/*
    ARQUIVO: styles.css (conforme sua estrutura)
    DESCRIÇÃO: Folha de Estilos Principal.
    FUNÇÃO: Define todos os estilos visuais da aplicação, incluindo:
    - Reset básico (fundo preto, tela cheia).
    - Tipografia (estilo Cinzel/Inter).
    - Estilos da UI (Mira, Logo, Copyright).
    - Estilos dos Controles Mobile (D-Pad, Botão de Ação).
    - Animação de Transição (Fade branco).
    - Responsividade (Mensagem de Rotação).
    
    COMENTÁRIOS EM: PT-BR
*/

/* 1. CONFIGURAÇÃO GLOBAL E FONTES */

/* Importação de fontes (Exemplo: Cinzel e Inter) */
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400&display=swap');

/*
    Reset Global:
    Remove margens, preenchimentos e define o 'box-sizing' para
    facilitar o layout. Define a cor de fundo padrão como preta
    e a cor do texto como branca (Paleta B&W).
*/
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden; /* Impede barras de rolagem */
    background-color: #000000;
    color: #ffffff;
    
    /* Define a pilha de fontes: Cinzel para títulos, Inter para texto. */
    font-family: 'Inter', sans-serif;
}

/* 2. ELEMENTOS 3D E OVERLAYS */

/*
    Canvas do Jogo:
    O canvas onde o Three.js desenha a cena.
    Deve ocupar a tela inteira, fixo no fundo.
*/
#game-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* Fica atrás de toda a UI */
    cursor: pointer; /* Indica que é clicável (para PointerLock) */
}

/*
    Tela de Carregamento (Loading):
    Overlay que cobre a tela enquanto os assets carregam.
*/
#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000000;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 200; /* Fica acima de tudo */
    transition: opacity 0.5s ease-out;
}

.loading-text {
    font-family: 'Cinzel', serif;
    font-size: 1.5rem;
    color: #ffffff;
}

/*
    Tela de Transição (Flash Branco):
    Usada para o "Theater Effect". Começa transparente.
*/
#transition-fade {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #ffffff;
    opacity: 0;
    pointer-events: none; /* Não pode ser clicado */
    z-index: 150; /* Acima da UI, abaixo do Loading */
    
    /* A transição é controlada via JS (main.js) */
}

/* 3. UI FIXA (MIRA, LOGO, COPYRIGHT) */

/*
    Mira (Crosshair):
    O '+' no centro da tela para interação.
*/
#crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    font-weight: bold;
    color: rgba(255, 255, 255, 0.7); /* Branco semi-transparente */
    pointer-events: none; /* Não pode ser clicado */
    z-index: 100;
    display: none; /* Começa escondido, 'main.js' mostra após carregar */
}

/* Logo "Sung" */
#logo {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 100;
    opacity: 0.8;
    pointer-events: none;
    display: none; /* Começa escondido */
}

#logo img {
    width: 100px; /* Tamanho do logo */
    height: auto;
}

/* Texto de Copyright */
#copyright {
    position: fixed;
    bottom: 10px;
    right: 10px;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.5);
    z-index: 100;
    pointer-events: none;
    display: none; /* Começa escondido */
}


/* 4. CONTROLES MOBILE (D-PAD E BOTÃO DE AÇÃO) */

/*
    Os controles mobile só aparecem em telas de toque.
    O 'controls.js' vai detectar se é mobile e mostrá-los.
*/
#dpad-container,
#action-btn {
    display: none; /* Escondidos por padrão (Desktop) */
    position: fixed;
    z-index: 110;
    user-select: none; /* Impede seleção de texto ao tocar */
    -webkit-user-select: none;
}

/* Contêiner do D-Pad */
#dpad-container {
    bottom: 30px;
    left: 30px;
    width: 150px;
    height: 150px;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr 1fr;
    opacity: 0.5; /* Semi-transparente para não atrapalhar a visão */
}

/* Botões do D-Pad (layout) */
#dpad-forward { grid-area: 1 / 2 / 2 / 3; }
#dpad-left { grid-area: 2 / 1 / 3 / 2; }
#dpad-right { grid-area: 2 / 3 / 3 / 4; }
#dpad-backward { grid-area: 3 / 2 / 4 / 3; }

/* Estilo comum dos botões do D-Pad */
.dpad-btn {
    background-color: rgba(255, 255, 255, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.5);
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
    border-radius: 8px; /* Bordas arredondadas */
}

/* Efeito ao pressionar o botão (feedback tátil) */
.dpad-btn:active {
    background-color: rgba(255, 255, 255, 0.6);
}

/* Botão de Ação [E] */
#action-btn {
    bottom: 40px;
    right: 40px;
    width: 80px;
    height: 80px;
    background-color: rgba(255, 255, 255, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.7);
    color: white;
    font-size: 2rem;
    font-weight: bold;
    font-family: 'Cinzel', serif;
    border-radius: 50%; /* Botão redondo */
    cursor: pointer;
    opacity: 0.6;
}

#action-btn:active {
    background-color: rgba(255, 255, 255, 0.6);
}


/* 5. RESPONSIVIDADE (MENSAGEM DE ROTAÇÃO) */

/*
    Mensagem de Rotação (Modo Retrato em Mobile):
    Por padrão, fica escondida.
*/
#rotate-message {
    display: none; /* Escondido por padrão */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000000;
    color: #ffffff;
    z-index: 250; /* Acima de TUDO */
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 20px;
    font-family: 'Cinzel', serif;
    font-size: 1.2rem;
}

/*
    Media Query para Orientação:
    Se o dispositivo estiver em modo "retrato" (altura > largura),
    mostra a mensagem de rotação e esconde todo o resto da UI.
*/
@media (orientation: portrait) {
    #rotate-message {
        display: flex; /* Mostra a mensagem */
    }

    /* Esconde toda a UI do jogo */
    #crosshair,
    #dpad-container,
    #action-btn,
    #logo,
    #copyright,
    #loading-screen {
        display: none !important;
    }
}
data/arts.json
JSON
[
    {
        "id": 1,
        "image": "img/tattoo_01.png",
        "title": "Título da Arte 1",
        "description": "Descrição detalhada da obra de arte número 1."
    },
    {
        "id": 2,
        "image": "img/tattoo_02.png",
        "title": "Título da Arte 2",
        "description": "Descrição detalhada da obra de arte número 2."
    },
    {
        "id": 3,
        "image": "img/tattoo_03.png",
        "title": "Título da Arte 3",
        "description": "Descrição detalhada da obra de arte número 3."
    },
    {
        "id": 4,
        "image": "img/tattoo_04.png",
        "title": "Título da Arte 4",
        "description": "Descrição detalhada da obra de arte número 4."
    },
    {
        "id": 5,
        "image": "img/tattoo_05.png",
        "title": "Título da Arte 5",
        "description": "Descrição detalhada da obra de arte número 5."
    },
    {
        "id": 6,
        "image": "img/tattoo_06.png",
        "title": "Título da Arte 6",
        "description": "Descrição detalhada da obra de arte número 6."
    },
    {
        "id": 7,
        "image": "img/tattoo_07.png",
        "title": "Título da Arte 7",
        "description": "Descrição detalhada da obra de arte número 7."
    },
    {
        "id": 8,
        "image": "img/tattoo_08.png",
        "title": "Título da Arte 8",
        "description": "Descrição detalhada da obra de arte número 8."
    },
    {
        "id": 9,
        "image": "img/tattoo_09.png",
        "title": "Título da Arte 9",
        "description": "Descrição detalhada da obra de arte número 9."
    },
    {
        "id": 10,
        "image": "img/tattoo_10.png",
        "title": "Título da Arte 10",
        "description": "Descrição detalhada da obra de arte número 10."
    },
    {
        "id": 11,
        "image": "img/tattoo_11.png",
        "title": "Título da Arte 11",
        "description": "Descrição detalhada da obra de arte número 11."
    },
    {
        "id": 12,
        "image": "img/tattoo_12.png",
        "title": "Título da Arte 12",
        "description": "Descrição detalhada da obra de arte número 12."
    },
    {
        "id": 13,
        "image": "img/tattoo_13.png",
        "title": "Título da Arte 13",
        "description": "Descrição detalhada da obra de arte número 13."
    },
    {
        "id": 14,
        "image": "img/tattoo_14.png",
        "title": "Título da Arte 14",
        "description": "Descrição detalhada da obra de arte número 14."
    },
    {
        "id": 15,
        "image": "img/tattoo_15.png",
        "title": "Título da Arte 15",
        "description": "Descrição detalhada da obra de arte número 15."
    },
    {
        "id": 16,
        "image": "img/tattoo_16.png",
        "title": "Título da Arte 16",
        "description": "Descrição detalhada da obra de arte número 16."
    },
    {
        "id": 17,
        "image": "img/tattoo_17.png",
        "title": "Título da Arte 17",
        "description": "Descrição detalhada da obra de arte número 17."
    },
    {
        "id": 18,
        "image": "img/tattoo_18.png",
        "title": "Título da Arte 18",
        "description": "Descrição detalhada da obra de arte número 18."
    }
]
js/loader.js
JavaScript
/*
    ARQUIVO: loader.js
    DESCRIÇÃO: Gerenciador de Carregamento de Assets.
    FUNÇÃO: Este script é responsável por carregar todas as texturas (imagens)
    necessárias para o projeto ANTES que a experiência comece.
    Ele usa o LoadingManager do Three.js para rastrear o progresso e
    notificar o 'main.js' quando tudo estiver pronto.
    
    COMENTÁRIOS EM: PT-BR
*/

class AssetLoader {
    // O construtor recebe as funções que devem ser chamadas
    // durante o carregamento (onProgress) e ao finalizar (onLoad).
    constructor(onProgress, onLoad) {
        // O LoadingManager monitora todos os loaders.
        this.manager = new THREE.LoadingManager();
        
        // Define as funções de callback do manager.
        this.manager.onProgress = (url, itemsLoaded, itemsTotal) => {
            // Calcula a porcentagem
            const progress = (itemsLoaded / itemsTotal) * 100;
            // Chama a função onProgress (definida em main.js)
            onProgress(progress);
            console.log(`Carregando: ${url} (${progress.toFixed(0)}%)`);
        };

        this.manager.onLoad = () => {
            // Chama a função onLoad (definida em main.js)
            onLoad();
            console.log('Todos os assets foram carregados.');
        };

        this.manager.onError = (url) => {
            console.error(`Erro ao carregar o asset: ${url}`);
        };

        // O TextureLoader é o responsável por carregar as imagens.
        // Passamos o manager para ele.
        this.textureLoader = new THREE.TextureLoader(this.manager);
    }

    /**
     * Carrega uma lista de texturas.
     * @param {Array<Object>} texturesToLoad - Um array de objetos { name, path }
     * @returns {Object} - Um objeto onde as chaves são os nomes (name) e os
     * valores são as texturas (THREE.Texture) carregadas.
     */
    loadTextures(texturesToLoad) {
        const textures = {};
        
        texturesToLoad.forEach(tex => {
            // Carrega a textura
            const texture = this.textureLoader.load(tex.path);
            
            // Configurações de repetição (wrapping) e filtro
            // Essencial para texturas de chão e parede.
            if (tex.repeat) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(tex.repeat[0], tex.repeat[1]);
            }

            // Adiciona ao nosso objeto de texturas
            textures[tex.name] = texture;
        });

        // Retorna o objeto com todas as texturas (que ainda estão carregando,
        // mas o manager vai saber quando terminarem).
        return textures;
    }
}
js/main.js
JavaScript
/*
    ARQUIVO: main.js
    DESCRIÇÃO: Ponto de Entrada Principal da Aplicação (O "Maestro").
    FUNÇÃO: Este script inicializa todos os componentes (Cena, Câmera,
    Renderizador, Controles) e gerencia o "Game Loop" (o 'animate').
    Ele coordena o carregamento de assets (JSON e texturas), 
    a transição de cenas e conecta os controles à lógica de interação.
    
    COMENTÁRIOS EM: PT-BR
*/

// Classe principal da aplicação
class SungApp {
    
    constructor() {
        // Elementos do DOM
        this.canvas = document.getElementById('game-canvas');
        this.loadingScreen = document.getElementById('loading-screen');
        this.loadingText = document.querySelector('.loading-text');
        this.transitionFade = document.getElementById('transition-fade');
        this.uiElements = [
            document.getElementById('crosshair'),
            document.getElementById('logo'),
            document.getElementById('copyright')
        ];

        // Componentes do Three.js
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true // Suavização de serrilhado
        });
        this.clock = new THREE.Clock(); // Relógio para o 'delta time'

        // Componentes do Jogo
        this.loader = null;
        this.controls = null;
        this.interaction = null;
        this.worldFactory = null;
        
        // Dados (carregados do JSON)
        this.artworkData = [];

        // Grupos de Cena (para fácil adição/remoção)
        this.world1_Group = null;
        this.world2_Group = null;

        // Estado do Jogo
        this.isLoaded = false;
        this.isTransitioning = false;
        this.currentWorldId = 1; // Começa no Mundo 1
        
        // Configurações (conforme UX finalizado)
        this.settings = {
            movementSpeed: 1.8,         // 1.8 m/s
            desktopCameraSpeed: 0.0008, // Sensibilidade Desktop
            mobileCameraSpeed: 0.0025,  // Sensibilidade Mobile
            playerHeight: 1.6           // Altura dos olhos do jogador
        };
        
        // Referência 'bind' para o loop de animação
        this.animate = this.animate.bind(this);
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Método principal de inicialização (agora é assíncrono).
     */
    async init() {
        console.log("Iniciando SungApp...");

        try {
            // 1. Carregar os dados das artes primeiro (de data/arts.json)
            await this.loadArtworkData();
            console.log("Dados de arte (arts.json) carregados.");

            // 2. Configurar o Renderizador
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limita o pixel ratio por performance
            this.renderer.outputEncoding = THREE.sRGBEncoding;

            // 3. Configurar a Posição Inicial da Câmera
            // (Na borda do mapa, na rodovia, em Z=90)
            this.camera.position.set(0, this.settings.playerHeight, 90);

            // 4. Inicializar o Loader de Assets (Texturas)
            this.loader = new AssetLoader(
                (progress) => {
                    // Função 'onProgress'
                    this.loadingText.textContent = `Carregando... ${progress.toFixed(0)}%`;
                },
                () => {
                    // Função 'onLoad' (Tudo carregado)
                    this.startExperience();
                }
            );

            // 5. Definir quais texturas carregar
            // Todos os caminhos apontam para 'assets/'
            const sceneTextures = [
                // Texturas principais (suas imagens)
                { name: 'rodovia', path: 'assets/rodovia_texture.jpg', repeat: [3, 10] }, // (Asfalto)
                { name: 'porta', path: 'assets/porta.png' }, 
                
                // Texturas auxiliares
                { name: 'path', path: 'assets/path_texture.jpg', repeat: [2, 12] }, // (Tijolos)
                { name: 'arvore', path: 'assets/arvore.png' },
                { name: 'crystalGlow', path: 'assets/crystal_glow.png' },
                { name: 'rock', path: 'assets/rock.png' },
                { name: 'forest_floor', path: 'assets/forest_floor.jpg', repeat: [50, 50] }, // (Terra)
                
                // Texturas do Corredor
                { name: 'wall', path: 'assets/wall_texture.jpg', repeat: [20, 2] },
                { name: 'floor', path: 'assets/floor_texture.jpg', repeat: [2, 20] }
            ];
            
            // Adiciona as 18 artes (carregadas do JSON) à lista de carregamento
            const artworkTextures = this.artworkData.map(art => ({
                name: `art_${art.id}`, // ex: 'art_1'
                path: art.image // ex: 'img/tattoo_01.png'
            }));
            
            // Carrega TUDO
            const allTexturesToLoad = [...sceneTextures, ...artworkTextures];
            const loadedTextures = this.loader.loadTextures(allTexturesToLoad);
            
            // 6. Inicializar a "Fábrica" de Mundos com as texturas
            this.worldFactory = new WorldSceneFactory(loadedTextures);

            // 7. Ouvinte de redimensionamento da janela
            window.addEventListener('resize', this.onWindowResize.bind(this));
        
        } catch (error) {
            console.error("Falha fatal na inicialização:", error);
            this.loadingText.textContent = "Erro ao carregar. Verifique o console.";
            this.loadingText.style.color = "red";
        }
    }
    
    /**
     * Carrega os dados do arquivo /data/arts.json
     * (Precisa de um servidor local - ver como_rodar.txt)
     */
    async loadArtworkData() {
        try {
            // Usa 'fetch' para buscar o arquivo JSON
            const response = await fetch('data/arts.json');
            if (!response.ok) {
                // Se o arquivo não for encontrado (404) ou der erro, falha
                throw new Error(`Erro HTTP! Status: ${response.status}`);
            }
            this.artworkData = await response.json();
            
            // Validação
            if (this.artworkData.length !== 18) {
                console.warn(`Aviso: 'arts.json' contém ${this.artworkData.length} artes. O corredor foi projetado para 18.`);
            }
            
        } catch (error) {
            console.error("Não foi possível carregar 'data/arts.json':", error);
            // Re-lança o erro para o 'init' principal tratar
            throw error; 
        }
    }

    /**
     * Chamado quando o Loader termina (onLoad).
     */
    startExperience() {
        console.log("Assets carregados. Iniciando a experiência.");
        this.isLoaded = true;
        
        // 1. Construir o Mundo 1 (Floresta)
        const world1Data = this.worldFactory.createWorld1(this.scene);
        this.world1_Group = world1Data.group;
        this.scene.add(this.world1_Group);

        // 2. Inicializar Controles
        this.controls = new PlayerControls(this.camera, this.canvas, this.settings);
        // Define os limites de colisão para o mundo 1
        this.controls.setWorld(1, world1Data.collisionLimits);
        
        // 3. Inicializar Interação
        this.interaction = new InteractionHandler(
            this.camera, 
            this.scene, 
            this.handleInteraction.bind(this) // Callback
        );
        
        // 4. Conectar Controles e Interação
        // Diz ao 'controls' qual função chamar quando [E] é pressionado
        this.controls.onInteract = () => {
            this.interaction.triggerInteraction();
        };

        // 5. Esconder a tela de Loading e mostrar a UI do Jogo
        this.loadingScreen.style.opacity = '0';
        setTimeout(() => {
            this.loadingScreen.style.display = 'none';
        }, 500); // 0.5s (duração da transição do CSS)

        // Mostra a UI (Mira, Logo, etc.)
        this.uiElements.forEach(el => el.style.display = 'block');
        
        // 6. Iniciar o Loop de Animação
        this.animate();
    }
    
    // -----------------------------------------------------------------
    // LOOP DE ANIMAÇÃO (GAME LOOP)
    // -----------------------------------------------------------------

    /**
     * O Loop Principal (requestAnimationFrame).
     */
    animate() {
        // Pede ao navegador para chamar 'animate' no próximo frame
        requestAnimationFrame(this.animate);

        // Se não carregou ou está em transição, não faz nada
        if (!this.isLoaded || this.isTransitioning) {
            return;
        }

        // Pega o tempo delta (diferença do último frame)
        const delta = this.clock.getDelta();

        // 1. Atualiza o handler de interação (verifica o que está na mira)
        this.interaction.update();
        
        // 2. Atualiza os controles do jogador (movimento, colisão)
        this.controls.update(delta);

        // 3. Renderiza a cena 3D
        this.renderer.render(this.scene, this.camera);
    }
    
    // -----------------------------------------------------------------
    // LÓGICA DE TRANSIÇÃO E INTERAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Callback chamado pelo 'InteractionHandler' quando [E] é pressionado
     * em um alvo válido.
     * @param {Object} userData - Os dados do objeto (ex: { type: 'gothic_door' })
     */
    handleInteraction(userData) {
        console.log("Interação disparada:", userData);
        
        // Verifica se é a porta gótica E se estamos no mundo 1
        if (userData.type === 'gothic_door' && this.currentWorldId === 1) {
            this.triggerSceneTransition();
        }
        
        // Lógica para mostrar info da arte no Mundo 2
        if (userData.type === 'artwork' && this.currentWorldId === 2) {
            console.log(`Clicou na Arte: ${userData.title}`);
            // (Ação Futura): Abrir um modal com `userData.title` e `userData.description`
            alert(`Arte: ${userData.title}\nDescrição: ${userData.description}`);
        }
    }

    /**
     * Executa o "Theater Effect" (Transição da Cena 1 para a Cena 2).
     */
    triggerSceneTransition() {
        if (this.isTransitioning) return; // Previne transições duplas
        
        console.log("Iniciando transição de cena...");
        this.isTransitioning = true; // Pausa o 'animate' loop

        // 1. Fade In Rápido (0.5s) para Branco
        this.transitionFade.style.transition = 'opacity 0.5s ease-in';
        this.transitionFade.style.opacity = '1';

        // 2. Atraso de 500ms (enquanto a tela está branca)
        setTimeout(() => {
            // --- O TELEPORTE (acontece instantaneamente) ---
            
            // a. Remove a geometria do Mundo 1
            this.scene.remove(this.world1_Group);
            
            // b. Constrói e adiciona a geometria do Mundo 2
            // Passa os dados do JSON (this.artworkData) para a fábrica
            const world2Data = this.worldFactory.createWorld2(this.scene, this.artworkData);
            this.world2_Group = world2Data.group;
            this.scene.add(this.world2_Group);

            // c. Teleporta o Jogador (Z=10, conforme requisito)
            this.camera.position.set(0, this.settings.playerHeight, 10);
            
            // d. Reseta a Rotação da Câmera (olhar reto)
            this.controls.resetRotation();

            // e. Atualiza os controles para os limites de colisão do Mundo 2
            this.controls.setWorld(2, world2Data.collisionLimits);
            this.currentWorldId = 2;
            
            // --- FIM DO TELEPORTE ---

            // 3. Fade Out Lento (1.5s) do Branco (olhos se ajustando)
            this.transitionFade.style.transition = 'opacity 1.5s ease-out';
            this.transitionFade.style.opacity = '0';
            
            // 4. Atraso de 1500ms (espera o fade out terminar)
            setTimeout(() => {
                this.isTransitioning = false; // Retoma o 'animate' loop
                console.log("Transição completa. Mundo 2 carregado.");
            }, 1500);

        }, 500); // Fim do setTimeout do Fade In
    }

    // -----------------------------------------------------------------
    // UTILITÁRIOS
    // -----------------------------------------------------------------

    /**
     * Chamado quando a janela do navegador muda de tamanho.
     */
    onWindowResize() {
        // Atualiza as proporções da câmera
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();

        // Atualiza o tamanho do renderizador
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}

// -----------------------------------------------------------------
// PONTO DE ENTRADA
// -----------------------------------------------------------------

// Quando o DOM (HTML) estiver pronto, cria e inicializa a aplicação.
window.addEventListener('DOMContentLoaded', () => {
    // Lembrete sobre o servidor local (para o 'fetch' funcionar)
    if (window.location.protocol === 'file:') {
        console.error("ERRO: O projeto não pode ser executado localmente via 'file://'. Use um servidor local (veja como_rodar.txt).");
        document.body.innerHTML = '<div style="color: red; font-size: 20px; padding: 20px;">ERRO: O projeto não pode ser executado localmente. Por favor, use um servidor (veja o arquivo como_rodar.txt).</div>';
        return;
    }
    
    const app = new SungApp();
    app.init();
});
js/scene.js
JavaScript
/*
    ARQUIVO: scene.js
    DESCRIÇÃO: Construtor de Cenários 3D.
    FUNÇÃO: Esta classe é uma "fábrica" de geometria. Ela não
    mantém estado, apenas contém métodos que criam e retornam
    os mundos (Cena 1 e Cena 2) como grupos de objetos (THREE.Group).
    
    COMENTÁRIOS EM: PT-BR
*/

class WorldSceneFactory {

    constructor(textures) {
        // Armazena as texturas que o 'loader.js' carregou.
        this.textures = textures;
        // Altura padrão da câmera (nível dos olhos)
        this.playerHeight = 1.6;
    }

    // -----------------------------------------------------------------
    // CENA 1: A DESCOBERTA (MUNDO ABERTO / FLORESTA)
    // -----------------------------------------------------------------
    createWorld1(scene) {
        const world1Group = new THREE.Group();
        world1Group.name = "World1_Group"; // Nome para depuração

        // 1. Configuração do Clima (Névoa e Luz)
        // Cor cinza-azulado escuro, inspirada em 'clima.png' (Sleepy Hollow)
        const fogColor = 0x2c3e50; 
        scene.background = new THREE.Color(fogColor);
        // A névoa começa perto e fica densa rapidamente
        scene.fog = new THREE.Fog(fogColor, 1, 40); // Névoa densa

        // Luz ambiente fraca, para dar o tom sombrio
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // (cor, intensidade)
        world1Group.add(ambientLight);

        // Luz direcional (simulando lua/crepúsculo)
        const directionalLight = new THREE.DirectionalLight(0x505a70, 0.4);
        directionalLight.position.set(5, 10, 5);
        world1Group.add(directionalLight);

        
        // 2. Geometria do Chão (Mundo Aberto)
        
        // Chão da Floresta (Ground082S) - O MAPA INTEIRO
        const forestFloorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.forest_floor });
        const forestFloorGeometry = new THREE.PlaneGeometry(200, 200); // 200m x 200m
        const forestFloor = new THREE.Mesh(forestFloorGeometry, forestFloorMaterial);
        forestFloor.rotation.x = -Math.PI / 2;
        forestFloor.position.set(0, 0, 0); // Centralizado na origem
        world1Group.add(forestFloor);

        // Rodovia (Asphalt033) - PONTO DE INÍCIO
        const roadMaterial = new THREE.MeshBasicMaterial({ map: this.textures.rodovia });
        const roadGeometry = new THREE.PlaneGeometry(15, 60); // (largura, comprimento)
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; 
        road.position.set(0, 0.01, 70); // Na borda do mapa (Z=70 a Z=100)
        world1Group.add(road);

        // Trilha de Tijolos ESCONDIDA (Bricks075B)
        const pathMaterial = new THREE.MeshBasicMaterial({ map: this.textures.path });
        const pathGeometry = new THREE.PlaneGeometry(3, 40); // Trilha estreita (3m x 40m)
        const path = new THREE.Mesh(pathGeometry, pathMaterial);
        path.rotation.x = -Math.PI / 2;
        // Posição escondida dentro da floresta
        path.position.set(30, 0.01, -20); // Escondida em X=30, Z=-20
        world1Group.add(path);


        // 3. Floresta Densa (Billboards de Árvores)
        // Material da árvore (usa 'arvore.png')
        const treeMaterial = new THREE.SpriteMaterial({ 
            map: this.textures.tree,
            fog: true,
            color: 0xcccccc // Um pouco mais escuras/cinzas
        });
        
        // Material do brilho do cristal
        const crystalMaterial = new THREE.SpriteMaterial({
            map: this.textures.crystalGlow,
            blending: THREE.AdditiveBlending, // Efeito de brilho
            fog: false, // Cristais brilham através da névoa
            transparent: true,
            opacity: 0.8
        });

        // Material da Rocha
        const rockMaterial = new THREE.SpriteMaterial({
            map: this.textures.rock,
            fog: true,
            color: 0xbbbbbb // Tom cinza para integrar
        });

        // Cria 2000 árvores para densidade
        for (let i = 0; i < 2000; i++) {
            const sprite = new THREE.Sprite(treeMaterial);
            
            const x = (Math.random() - 0.5) * 200; // X de -100 a 100
            const z = (Math.random() - 0.5) * 200; // Z de -100 a 100

            // *** LÓGICA PARA NÃO NASCER ÁRVORE NA ESTRADA OU NA TRILHA ***
            // Checa área da estrada (X -7.5 a 7.5, Z 40 a 100)
            if (x > -7.5 && x < 7.5 && z > 40 && z < 100) {
                continue; // Pula esta árvore
            }
            // Checa área da trilha (X 28.5 a 31.5, Z -40 a 0)
            if (x > 28.5 && x < 31.5 && z > -40 && z < 0) {
                continue; // Pula esta árvore
            }

            // Tamanho aleatório (árvores grandes e médias)
            const scale = Math.random() * 3 + 4; // Escala entre 4m e 7m
            sprite.scale.set(scale, scale, 1);
            sprite.position.set(x, scale / 2, z); // (x, altura, z)
            world1Group.add(sprite);
        }

        // Adiciona Rochas (100)
        for (let i = 0; i < 100; i++) {
            const rockSprite = new THREE.Sprite(rockMaterial);
            const x = (Math.random() - 0.5) * 200; 
            const z = (Math.random() - 0.5) * 200;
            
            // Checa área da estrada
            if (x > -7.5 && x < 7.5 && z > 40 && z < 100) continue; 
            // Checa área da trilha
            if (x > 28.5 && x < 31.5 && z > -40 && z < 0) continue; 

            const scale = Math.random() * 0.5 + 0.5; // Rochas pequenas (0.5m a 1m)
            rockSprite.scale.set(scale, scale, 1);
            rockSprite.position.set(x, scale / 2, z); // No chão
            world1Group.add(rockSprite);
        }

        // 4. A Pista de Cristais (As "Migalhas de Pão")
        // Coloca cristais guiando da estrada (0, 60) até a trilha (30, 0)
        const crystalPath = [
            {x: 5, z: 60},
            {x: 10, z: 55},
            {x: 15, z: 50},
            {x: 20, z: 40},
            {x: 25, z: 30},
            {x: 30, z: 20},
            {x: 30, z: 10},
            {x: 30, z: 0}, // Chegou na trilha
            {x: 30, z: -10},
            {x: 30, z: -20},
            {x: 30, z: -30} // Perto da porta
        ];

        crystalPath.forEach(pos => {
            // Luz Pontual (azulada)
            const light = new THREE.PointLight(0xadd8e6, 1.5, 8); // (cor, intensidade, distância)
            light.position.set(pos.x, 1.5, pos.z); // Posição
            world1Group.add(light);
            
            // Sprite visual do cristal
            const crystalSprite = new THREE.Sprite(crystalMaterial);
            crystalSprite.position.copy(light.position);
            crystalSprite.scale.set(1.5, 2.5, 1); 
            world1Group.add(crystalSprite);
        });


        // 5. A Porta Gótica (Objetivo)
        // Simula a "rocha" onde a porta está
        const rockFaceMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 }); 
        const rockFaceGeometry = new THREE.PlaneGeometry(8, 8); // Parede de rocha
        const rockFace = new THREE.Mesh(rockFaceGeometry, rockFaceMaterial);
        // Posicionada no final da trilha escondida
        rockFace.position.set(30, 4, -40.5); // (x, altura, z)
        world1Group.add(rockFace);
        
        // A porta em si
        const doorMaterial = new THREE.MeshBasicMaterial({ 
            map: this.textures.porta,
            transparent: true 
        });
        const doorGeometry = new THREE.PlaneGeometry(4, 5); // Tamanho da porta
        const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
        
        // Posiciona no final da trilha, em frente à rocha
        doorMesh.position.set(30, 2.5, -40); // (x, altura, z)
        
        // Adiciona o 'userData' para interação
        doorMesh.userData = { 
            interactive: true, 
            type: 'gothic_door' 
        };
        world1Group.add(doorMesh);


        // 6. Limites de Colisão (Mundo Aberto)
        // Agora, os limites são apenas as bordas do mapa (chão da floresta)
        const worldLimits = {
            minX: -98, // 2m de margem
            maxX: 98,
            minZ: -98,
            maxZ: 98
        };

        // Retorna o grupo de objetos e os limites de colisão
        return { group: world1Group, collisionLimits: worldLimits };
    }


    // -----------------------------------------------------------------
    // CENA 2: A GALERIA (CORREDOR)
    // -----------------------------------------------------------------
    createWorld2(scene, artworkData) { // Recebe os dados do JSON
        const world2Group = new THREE.Group();
        world2Group.name = "World2_Group";

        // 1. Limpa a Névoa e Luz da Cena 1
        scene.fog = null; // Remove a névoa
        scene.background = new THREE.Color(0x000000); // Fundo preto

        // Luz ambiente muito escura (soturna)
        const ambientLight = new THREE.AmbientLight(0x101010, 1.0); // (cor, intensidade)
        world2Group.add(ambientLight);

        // Luz "falsa" no teto (HemisphereLight)
        const hemiLight = new THREE.HemisphereLight(0x404040, 0x080808, 0.5);
        world2Group.add(hemiLight);

        // 2. Geometria do Corredor
        const corridorLength = 80;
        const corridorWidth = 5;
        const corridorHeight = 4;

        // Chão (Usa 'floor_texture.jpg')
        const floorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.floor });
        const floorGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, 0, corridorLength / 2); 
        world2Group.add(floor); // <-- CORREÇÃO: ADICIONADO AO GRUPO CERTO

        // Teto
        const ceilMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 }); // Teto escuro
        const ceilGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const ceil = new THREE.Mesh(ceilGeometry, ceilMaterial);
        ceil.rotation.x = Math.PI / 2;
        ceil.position.set(0, corridorHeight, corridorLength / 2);
        world2Group.add(ceil);

        // Parede Esquerda (Usa 'wall_texture.jpg')
        const wallMaterial = new THREE.MeshBasicMaterial({ map: this.textures.wall });
        const wallGeometry = new THREE.PlaneGeometry(corridorLength, corridorHeight);
        const wallLeft = new THREE.Mesh(wallGeometry, wallMaterial);
        wallLeft.rotation.y = Math.PI / 2;
        wallLeft.position.set(-corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallLeft);

        // Parede Direita (Usa 'wall_texture.jpg')
        const wallRight = new THREE.Mesh(wallGeometry, wallMaterial);
        wallRight.rotation.y = -Math.PI / 2;
        wallRight.position.set(corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallRight);

        // Parede do Fundo (Fechando o corredor)
        const endWallGeom = new THREE.PlaneGeometry(corridorWidth, corridorHeight);
        const endWall = new THREE.Mesh(endWallGeom, wallMaterial);
        endWall.position.set(0, corridorHeight / 2, corridorLength);
        world2Group.add(endWall);

        // 3. Criação das Obras de Arte (Quadros)
        const spacing = corridorLength / 9;
        const frameSize = 2.0; 
        const frameHeight = this.playerHeight + 0.2; 

        // Itera sobre os dados do JSON (artworkData)
        artworkData.forEach((artwork, index) => {
            const artTexture = this.textures[`art_${artwork.id}`];
            const artMaterial = new THREE.MeshBasicMaterial({ map: artTexture });

            const artGeometry = new THREE.PlaneGeometry(frameSize, frameSize);
            const artMesh = new THREE.Mesh(artGeometry, artMaterial);
            
            // Placa de interação (hitbox)
            const plaqueGeometry = new THREE.PlaneGeometry(frameSize + 1, frameSize + 1);
            const plaqueMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const plaqueMesh = new THREE.Mesh(plaqueGeometry, plaqueMaterial);
            
            plaqueMesh.userData = {
                interactive: true,
                type: 'artwork',
                id: artwork.id,
                title: artwork.title,
                description: artwork.description
            };

            const zPos = 10 + (index % 9) * (spacing * 0.9);

            if (index < 9) {
                // Lado Esquerdo
                artMesh.position.set((-corridorWidth / 2) + 0.05, frameHeight, zPos);
                artMesh.rotation.y = Math.PI / 2; 
                plaqueMesh.position.set((-corridorWidth / 2) + 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = Math.PI / 2;
            } else {
                // Lado Direito
                artMesh.position.set((corridorWidth / 2) - 0.05, frameHeight, zPos);
                artMesh.rotation.y = -Math.PI / 2; 
                plaqueMesh.position.set((corridorWidth / 2) - 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = -Math.PI / 2;
            }
            world2Group.add(artMesh);
            world2Group.add(plaqueMesh); 
        });

        // 4. Limites de Colisão (Corredor)
        const collisionLimits = {
            minX: -corridorWidth / 2 + 0.5, 
            maxX: corridorWidth / 2 - 0.5,
            minZ: 0.5, 
            maxZ: corridorLength - 0.5 
        };
        
        // Retorna o grupo e os limites
        return { group: world2Group, collisionLimits: collisionLimits };
    }
}
js/controls.js
JavaScript
/*
    ARQUIVO: controls.js
    DESCRIÇÃO: Gerenciador de Controles do Jogador (Input Handler).
    FUNÇÃO: Esta classe gerencia TODO o input do usuário:
    - Movimentação (WASD / Setas / D-Pad Mobile).
    - Rotação da Câmera (Mouse / Toque Mobile).
    - Ações (Tecla [E] / Botão de Ação Mobile).
    - Lógica de Colisão (limitando a posição do jogador).
    
    COMENTÁRIOS EM: PT-BR
*/

class PlayerControls {

    /**
     * @param {THREE.Camera} camera - A câmera do jogador.
     * @param {HTMLElement} domElement - O elemento canvas (para eventos).
     * @param {Object} settings - Configurações de velocidade e sensibilidade.
     */
    constructor(camera, domElement, settings) {
        this.camera = camera;
        this.domElement = domElement;
        this.settings = settings;

        // Referência à função de interação (definida em main.js)
        this.onInteract = () => {}; 
        
        // Estado de movimento
        this.moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        // Estado da Câmera (Mouse Look)
        this.cameraLook = {
            pitch: 0, // Rotação vertical (X)
            yaw: 0   // Rotação horizontal (Y)
        };
        
        // Propriedades de física/movimento
        this.velocity = new THREE.Vector3();
        this.direction = new THREE.Vector3();

        // Configurações do mundo atual (Cena 1 ou Cena 2)
        this.currentWorld = 1;
        this.collisionLimits = null; // Limites de colisão do mundo atual
        
        // Detecção de Mobile (baseado em 'touchstart')
        this.isMobile = 'ontouchstart' in window;
        
        // Armazena o ID do toque de movimento (para multi-toque)
        this.moveTouchId = null; 
        this.lookTouchId = null;
        this.lastLookPos = { x: 0, y: 0 };
        
        // Ajusta a sensibilidade para mobile (conforme UX finalizado)
        this.sensitivity = this.isMobile ? 
            this.settings.mobileCameraSpeed : 
            this.settings.desktopCameraSpeed;

        // Inicializa os ouvintes de eventos
        this.initListeners();
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO DOS OUVINTES DE EVENTO
    // -----------------------------------------------------------------
    initListeners() {
        if (this.isMobile) {
            // Se for mobile, inicializa os controles de toque
            this.initMobileControls();
        } else {
            // Se for desktop, inicializa o Pointer Lock (travar mouse)
            this.initPointerLock();
            // E os ouvintes de teclado
            document.addEventListener('keydown', this.onKeyDown.bind(this));
            document.addEventListener('keyup', this.onKeyUp.bind(this));
        }
    }

    // (Desktop) Configura o Pointer Lock
    initPointerLock() {
        this.domElement.addEventListener('click', () => {
            this.domElement.requestPointerLock();
        });

        // Ouve o movimento do mouse APENAS quando o mouse está travado
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === this.domElement) {
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
            } else {
                document.removeEventListener('mousemove', this.onMouseMove.bind(this));
            }
        });
    }

    // (Mobile) Configura os botões de toque
    initMobileControls() {
        // Mostra os botões de D-Pad e Ação
        document.getElementById('dpad-container').style.display = 'grid';
        document.getElementById('action-btn').style.display = 'block';

        // Ouvintes do D-Pad (touchstart = pressionar, touchend = soltar)
        this.addTouchListener('dpad-forward', 'forward');
        this.addTouchListener('dpad-backward', 'backward');
        this.addTouchListener('dpad-left', 'left');
        this.addTouchListener('dpad-right', 'right');

        // Ouvinte do Botão de Ação
        document.getElementById('action-btn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.onInteract(); // Chama a função de interação
        });
        
        // Ouvinte de Toque na Tela (para olhar ao redor)
        this.domElement.addEventListener('touchstart', this.onMobileTouchStart.bind(this));
        this.domElement.addEventListener('touchmove', this.onMobileTouchMove.bind(this));
        this.domElement.addEventListener('touchend', this.onMobileTouchEnd.bind(this));
    }

    // (Mobile) Função auxiliar para adicionar ouvintes de toque
    addTouchListener(elementId, direction) {
        const element = document.getElementById(elementId);
        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.moveState[direction] = true;
        });
        element.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.moveState[direction] = false;
        });
    }

    // -----------------------------------------------------------------
    // HANDLERS DE EVENTO (MOVIMENTO / AÇÃO)
    // -----------------------------------------------------------------

    // (Desktop) Tecla pressionada
    onKeyDown(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = true; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = true; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = true; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = true; break;
            case 'KeyE': this.onInteract(); break; // Tecla de Interação [E]
        }
    }

    // (Desktop) Tecla solta
    onKeyUp(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = false; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = false; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = false; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = false; break;
        }
    }

    // (Desktop) Movimento do mouse (Pointer Lock)
    onMouseMove(event) {
        if (document.pointerLockElement !== this.domElement) return;

        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;

        // Rotação Horizontal (Yaw) - Eixo Y
        this.cameraLook.yaw -= movementX * this.sensitivity;
        
        // Rotação Vertical (Pitch) - Eixo X
        this.cameraLook.pitch -= movementY * this.sensitivity;
        
        // Trava a rotação vertical (para não "quebrar o pescoço")
        this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
        
        // Aplica as rotações (Ordem EULER_YXZ é importante para FPS)
        this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
    }

    // (Mobile) Início do toque na tela
    onMobileTouchStart(event) {
        event.preventDefault();
        // Itera sobre os toques
        for (const touch of event.changedTouches) {
            // Se o toque for na metade direita da tela, é para "olhar"
            if (touch.clientX > window.innerWidth / 2 && this.lookTouchId === null) {
                this.lookTouchId = touch.identifier;
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;
            }
        }
    }

    // (Mobile) Movimento do toque na tela (Olhar)
    onMobileTouchMove(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se for o toque que estamos rastreando para "olhar"
            if (touch.identifier === this.lookTouchId) {
                const deltaX = touch.clientX - this.lastLookPos.x;
                const deltaY = touch.clientY - this.lastLookPos.y;

                // Salva a nova posição
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;

                // Aplica a rotação (similar ao onMouseMove)
                this.cameraLook.yaw -= deltaX * this.sensitivity;
                this.cameraLook.pitch -= deltaY * this.sensitivity;
                this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
                
                this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
            }
        }
    }

    // (Mobile) Fim do toque na tela
    onMobileTouchEnd(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se o toque que terminou era o de "olhar", para de rastrear
            if (touch.identifier === this.lookTouchId) {
                this.lookTouchId = null;
            }
        }
    }


    // -----------------------------------------------------------------
    // ATUALIZAÇÃO (LOOP PRINCIPAL) E COLISÃO
    // -----------------------------------------------------------------

    /**
     * Define os limites de colisão do mundo atual.
     * @param {number} worldId - 1 para Floresta, 2 para Corredor.
     * @param {Object} limits - O objeto de limites vindo de 'scene.js'.
     */
    setWorld(worldId, limits) {
        this.currentWorld = worldId;
        this.collisionLimits = limits;
    }
    
    /**
     * Reseta a rotação da câmera (usado na transição).
     */
    resetRotation() {
        this.cameraLook.pitch = 0;
        this.cameraLook.yaw = 0;
        this.camera.rotation.set(0, 0, 0, 'YXZ');
    }

    /**
     * Chamado a cada frame pelo 'main.js'.
     * @param {number} delta - O tempo (em segundos) desde o último frame.
     */
    update(delta) {
        // Velocidade = 1.8 m/s (conforme UX finalizado)
        const moveSpeed = this.settings.movementSpeed * delta;

        // Reseta a direção do movimento
        this.direction.z = Number(this.moveState.forward) - Number(this.moveState.backward);
        this.direction.x = Number(this.moveState.left) - Number(this.moveState.right);
        this.direction.normalize(); // Garante movimento consistente (diagonal != mais rápido)

        // Salva a posição atual para checagem de colisão
        const oldPosition = this.camera.position.clone();

        // Calcula o movimento relativo à direção que a câmera está olhando
        if (this.moveState.forward || this.moveState.backward) {
            this.camera.translateZ(-this.direction.z * moveSpeed);
        }
        if (this.moveState.left || this.moveState.right) {
            this.camera.translateX(-this.direction.x * moveSpeed);
        }

        // --- LÓGICA DE COLISÃO ---
        // Impede o jogador de sair dos limites definidos
        if (this.collisionLimits) {
            this.applyCollisions(oldPosition);
        }
        
        // Mantém a altura do jogador (impede de voar ou afundar)
        this.camera.position.y = this.settings.playerHeight;
    }

    /**
     * Verifica e aplica as colisões baseadas nos limites do mundo.
     * @param {THREE.Vector3} oldPosition - Posição antes do movimento.
     */
    applyCollisions(oldPosition) {
        const newPosition = this.camera.position;
        const limits = this.collisionLimits;

        // Lógica de Colisão simples de "caixa" (para ambos os mundos)
        // Isso nos dá a liberdade de explorar no Mundo 1
        newPosition.x = Math.max(limits.minX, Math.min(limits.maxX, newPosition.x));
        newPosition.z = Math.max(limits.minZ, Math.min(limits.maxZ, newPosition.z));
        
        // Aplica a posição corrigida
        this.camera.position.copy(newPosition);
    }
}
js/interaction.js
JavaScript
/*
    ARQUIVO: interaction.js
    DESCRIÇÃO: Gerenciador de Interação (Raycaster).
    FUNÇÃO: Esta classe é responsável por "atirar um raio" (Raycast)
    a partir do centro da tela (mira) para detectar com o que
    o jogador está olhando/interagindo.
    
    COMENTÁRIOS EM: PT-BR
*/

class InteractionHandler {

    /**
     * @param {THREE.Camera} camera - A câmera do jogador (de onde o raio sai).
     * @param {THREE.Scene} scene - A cena (onde os objetos estão).
     * @param {Function} onInteractCallback - Função em 'main.js' a ser chamada
     * quando uma interação válida ocorre.
     */
    constructor(camera, scene, onInteractCallback) {
        this.camera = camera;
        this.scene = scene;
        this.onInteractCallback = onInteractCallback;

        // O Raycaster do Three.js
        this.raycaster = new THREE.Raycaster();
        
        // Coordenadas da mira (sempre [0, 0] = centro da tela)
        this.crosshairCoords = new THREE.Vector2(0, 0);

        // Distância máxima de interação (ex: 3 metros)
        this.interactionDistance = 3.0; 

        // Armazena o objeto que está atualmente na mira
        this.currentTarget = null;
    }

    /**
     * Chamado quando o jogador pressiona [E] ou o Botão de Ação.
     * Esta é a função que efetivamente "dispara" a interação.
     */
    triggerInteraction() {
        // Verifica se há um alvo válido na mira
        if (this.currentTarget) {
            // Chama a função de callback em 'main.js'
            // e passa os dados do objeto (ex: { type: 'gothic_door' })
            this.onInteractCallback(this.currentTarget.userData);
        } else {
            // (Opcional) Tocar um som de "falha" se não houver nada
            console.log("Nenhum alvo interativo ao alcance.");
        }
    }

    /**
     * Chamado a cada frame pelo 'main.js' (ANTES do update de controles).
     * Esta função *apenas* verifica o que está na mira, mas não
     * dispara a ação.
     */
    update() {
        // 1. Atualiza o raio para sair do centro da câmera
        this.raycaster.setFromCamera(this.crosshairCoords, this.camera);

        // 2. Verifica quais objetos na cena (recursivamente) o raio atinge
        // Passamos 'this.scene.children' e 'true' para verificar os filhos
        // dos grupos (World1_Group, World2_Group).
        const intersects = this.raycaster.intersectObjects(this.scene.children, true);

        // Reseta o alvo atual
        this.currentTarget = null;

        // 3. Itera sobre os objetos atingidos
        for (const intersect of intersects) {
            
            // 4. Verifica se o objeto tem o 'userData' interativo
            // (Nós definimos isso em 'scene.js' na porta e nas placas)
            if (intersect.object.userData && intersect.object.userData.interactive === true) {
                
                // 5. Verifica se está dentro da distância permitida
                if (intersect.distance <= this.interactionDistance) {
                    
                    // Encontramos um alvo válido!
                    this.currentTarget = intersect.object;
                    
                    // (Opcional) Mudar a cor da mira para "ativa"
                    // document.getElementById('crosshair').style.color = 'red';
                    
                    // Para o loop assim que encontrar o primeiro alvo válido
                    break;
                }
            }
        }
        
        // Se o loop terminou e this.currentTarget ainda é nulo,
        // significa que não estamos olhando para nada interativo.
        if (this.currentTarget === null) {
            // (Opcional) Resetar a cor da mira para "passiva"
            // document.getElementById('crosshair').style.color = 'rgba(255, 255, 255, 0.7)';
        }
    }
}
ah uma duvida eu vou criar os cristais luminosos do 0 eu tenho q modelar eles ja nas arvores ?

ou so modelo esle

Ótima pergunta. Isso é um detalhe de workflow de game dev muito importante.

A resposta é: Não, você NÃO modela o cristal junto com a árvore.

Você deve modelar o cristal como um objeto separado e individual.

Aqui está o porquê, baseado em como o nosso código foi escrito:

Árvores são Sprites 2D: As árvores na nossa floresta (arvore.png) não são modelos 3D. Elas são "billboards" 2D, imagens planas que sempre olham para a câmera. Você não pode "anexar" um modelo 3D a uma imagem 2D dentro de um software de modelagem.

Posicionamento é feito no Código: O js/scene.js é quem decide onde cada árvore e cada cristal vai ficar. Nós criamos uma "trilha de cristais" (crystalPath) que é independente das árvores. O código coloca um cristal no Ponto A, outro no Ponto B, etc., para formar a trilha de "migalhas de pão".

O que você realmente precisa fazer (Temos 2 Opções)
Você está misturando duas técnicas: modelagem 3D e sprites 2D. O código que eu escrevi usa a técnica 2D (Sprites) porque é muito mais leve e rápido.

Opção A: O Plano Atual (Usar um Sprite 2D) - RECOMENDADO
O que fazer: Você não precisa modelar nada em 3D.

Ação: Você só precisa criar uma imagem 2D (como eu sugeri nos links do Pixabay ou Photopea) de um brilho azulado/branco com fundo transparente.

Nome do arquivo: crystal_glow.png

Como funciona: O js/scene.js vai pegar essa imagem, colocar em um THREE.SpriteMaterial (um outdoor 2D), e adicionar uma luz (THREE.PointLight) no mesmo lugar. O efeito na névoa fica excelente e é muito performático.

Opção B: O Novo Plano (Usar seu Modelo 3D)
Se você realmente quer que o cristal seja um objeto 3D que você modelou (um mesh com faces e vértices):

Modele o cristal SOZINHO (ex: no Blender).

Exporte ele como crystal.glb (ou .gltf).

Coloque esse arquivo na pasta /assets/.

AVISE-ME, pois teremos que mudar o código. Teremos que:

Adicionar um GLTFLoader no js/main.js para carregar o arquivo crystal.glb.

Mudar o js/scene.js para, em vez de criar um THREE.Sprite, clonar e adicionar o seu modelo 3D (THREE.Mesh) em cada ponto da trilha de cristais.

Minha Recomendação
Comece pela Opção A. É muito mais fácil, o código já está pronto para isso, e o resultado visual de um sprite brilhante + uma luz pontual na névoa densa (como fizemos) é 90% do efeito que você quer, com 10% do esforço.

Resumo: Não modele nada em 3D por enquanto. Apenas crie a imagem 2D crystal_glow.png (um brilho com fundo transparente) e coloque na pasta /assets/.

ta vamos fazer o seguinte retire do codigo toda parte do corredor

vamos focar na floresstas

Ok. Entendido. Vamos pivotar.

Isso é uma ótima ideia para focar. Faremos a Cena 1 (A Floresta) funcionar perfeitamente como uma "demo de jogo" independente. Removemos o corredor, a galeria e a transição.

O novo objetivo do jogo será: Começar na rodovia, explorar a floresta, seguir os cristais, encontrar a trilha de tijolos e chegar à porta gótica.

Quando você interagir com a porta, o jogo "terminará" (com uma mensagem de "Continua...").

Aqui está o código completo refatorado, focado 100% na floresta.

Ação Obrigatória: Exclua estes arquivos/pastas
Como não vamos usar o corredor, você pode (e deve) excluir o seguinte para manter o projeto limpo:

EXCLUA O ARQUIVO: data/arts.json

EXCLUA A PASTA: /img/ (e todas as 18 imagens de tatuagem dentro dela)

EXCLUA OS ARQUIVOS DE TEXTURA:

assets/wall_texture.jpg

assets/floor_texture.jpg

index.html
(Sem alterações. Os elementos de UI e transição ainda são úteis)

HTML
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sung Studios - A Caçada</title>
    
    <link rel="stylesheet" href="CSS/styles.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-text">Carregando...</div>
    </div>

    <div id="rotate-message">
        <p>Por favor, gire seu dispositivo para a posição horizontal (paisagem) para iniciar a experiência.</p>
    </div>

    <div id="transition-fade">
        <div id="game-end-message">CONTINUA...</div>
    </div>

    <div id="crosshair">+</div>

    <div id="dpad-container">
        <button id="dpad-forward" class="dpad-btn">▲</button>
        <button id="dpad-backward" class="dpad-btn">▼</button>
        <button id="dpad-left" class="dpad-btn">◄</button>
        <button id="dpad-right" class="dpad-btn">►</button>
    </div>

    <button id="action-btn">E</button>

    <div id="logo">
        <img src="assets/belial.png" alt="Sung Studios Logo">
    </div>
    <div id="copyright">© 2025 Sung</div>

    <canvas id="game-canvas"></canvas>

    <script src="js/loader.js"></script>
    <script src="js/scene.js"></script>
    <script src="js/controls.js"></script>
    <script src="js/interaction.js"></script>
    <script src="js/main.js"></script>

</body>
</html>
README.md (ATUALIZADO)
(Focado apenas na floresta)

Markdown
# Sung Studios - A Caçada (Demo da Floresta)

Este é o repositório do projeto para a demo interativa 3D "A Caçada", um jogo de exploração com tema de horror cinematográfico.

## Visão Geral

O projeto é uma experiência narrativa em primeira pessoa. O jogador é colocado em uma floresta escura e aberta (200x200m) e deve explorar para encontrar seu objetivo.

O jogador começa em uma rodovia abandonada na borda da floresta e deve seguir uma trilha de cristais luminosos para encontrar uma trilha de tijolos escondida, que o levará ao objetivo final: uma porta gótica misteriosa.

## Stack Técnica

* **HTML5**
* **CSS3**
* **JavaScript (ES6+)**
* **Three.js** (incluído via CDN)

## Como Rodar

Consulte `como_rodar.txt` para instruções sobre como iniciar um servidor local, que é **obrigatório** para carregar os assets.

---
© 2025 Sung
COMO_EDITAR.txt (ATUALIZADO)
(Removida a seção da galeria)

Plaintext
=================================================
GUIA DE MANUTENÇÃO - SUNG STUDIOS (PT-BR)
=================================================

Este arquivo explica como atualizar o conteúdo do site 3D sem precisar mexer no código principal.

-------------------------------------------------
1. COMO MUDAR AS TEXTURAS DO CENÁRIO
-------------------------------------------------

PASTA DE TEXTURAS: /assets/

* `rodovia_texture.jpg`: A textura do asfalto da estrada.
* `porta.png`: A textura da porta gótica (sua referência).
* `belial.png`: O logo no canto da tela.
* `arvore.png`: A imagem da árvore usada na floresta (formato billboard).
* `path_texture.jpg`: A textura dos tijolos da trilha escondida.
* `forest_floor.jpg`: A textura de terra molhada da floresta.
* `crystal_glow.png`: A imagem do brilho do cristal (fundo transparente).
* `rock.png`: A imagem da rocha na floresta (fundo transparente).

Basta substituir o arquivo de imagem nesta pasta pelo seu novo arquivo, MANTENDO O MESMO NOME E EXTENSÃO.
checklist.txt (ATUALIZADO)
(Removida a seção da galeria)

Plaintext
=================================================
CHECKLIST DE ASSETS DO PROJETO (PT-BR)
=================================================

Verifique se todos os assets (arquivos de mídia) necessários estão nas pastas corretas antes de testar o projeto.

### 1. Imagens de Cenário (Obrigatórias)
Local: /assets/

[ ] belial.png             (Logo "Sung" que aparece no canto)
[ ] rodovia_texture.jpg    (Textura de asfalto molhado)
[ ] porta.png              (Textura da porta gótica - IMAGEM QUE VOCÊ FORNECEU)
[ ] arvore.png             (Imagem da árvore com fundo transparente para a floresta)
[ ] path_texture.jpg       (Textura de tijolos escuros para a trilha)
[ ] forest_floor.jpg       (Textura de terra molhada para a floresta)
[ ] crystal_glow.png       (Textura de brilho para os cristais)
[ ] rock.png               (Imagem de rocha com fundo transparente)

### 2. Áudio (Opcional)
Local: /assets/audio/
(Vazio por enquanto)
CSS/styles.css (ATUALIZADO)
(Adicionado #game-end-message no final)

CSS
/*
    ARQUIVO: styles.css (conforme sua estrutura)
    DESCRIÇÃO: Folha de Estilos Principal.
    FUNÇÃO: Define todos os estilos visuais da aplicação.
    
    COMENTÁRIOS EM: PT-BR
*/

/* 1. CONFIGURAÇÃO GLOBAL E FONTES */
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400&display=swap');

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden; 
    background-color: #000000;
    color: #ffffff;
    font-family: 'Inter', sans-serif;
}

/* 2. ELEMENTOS 3D E OVERLAYS */
#game-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; 
    cursor: pointer; 
}

#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000000;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 200; 
    transition: opacity 0.5s ease-out;
}

.loading-text {
    font-family: 'Cinzel', serif;
    font-size: 1.5rem;
    color: #ffffff;
}

/* Tela de Transição (Usada para o Fim de Jogo) */
#transition-fade {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #ffffff; /* Fundo branco do fade */
    opacity: 0;
    pointer-events: none; 
    z-index: 150; 
    display: flex;
    justify-content: center;
    align-items: center;
}

/* NOVO: Mensagem de Fim de Jogo */
#game-end-message {
    font-family: 'Cinzel', serif;
    font-size: 3rem;
    color: #000000; /* Texto preto sobre o fundo branco */
    opacity: 0; /* Começa invisível */
    transition: opacity 1s ease-in;
    transition-delay: 0.5s; /* Aparece depois do fade branco */
}


/* 3. UI FIXA (MIRA, LOGO, COPYRIGHT) */
#crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    font-weight: bold;
    color: rgba(255, 255, 255, 0.7); 
    pointer-events: none; 
    z-index: 100;
    display: none; 
}

#logo {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 100;
    opacity: 0.8;
    pointer-events: none;
    display: none; 
}

#logo img {
    width: 100px; 
    height: auto;
}

#copyright {
    position: fixed;
    bottom: 10px;
    right: 10px;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.5);
    z-index: 100;
    pointer-events: none;
    display: none; 
}


/* 4. CONTROLES MOBILE (D-PAD E BOTÃO DE AÇÃO) */
#dpad-container,
#action-btn {
    display: none; 
    position: fixed;
    z-index: 110;
    user-select: none; 
    -webkit-user-select: none;
}

#dpad-container {
    bottom: 30px;
    left: 30px;
    width: 150px;
    height: 150px;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr 1fr;
    opacity: 0.5; 
}

#dpad-forward { grid-area: 1 / 2 / 2 / 3; }
#dpad-left { grid-area: 2 / 1 / 3 / 2; }
#dpad-right { grid-area: 2 / 3 / 3 / 4; }
#dpad-backward { grid-area: 3 / 2 / 4 / 3; }

.dpad-btn {
    background-color: rgba(255, 255, 255, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.5);
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
    border-radius: 8px; 
}

.dpad-btn:active {
    background-color: rgba(255, 255, 255, 0.6);
}

#action-btn {
    bottom: 40px;
    right: 40px;
    width: 80px;
    height: 80px;
    background-color: rgba(255, 255, 255, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.7);
    color: white;
    font-size: 2rem;
    font-weight: bold;
    font-family: 'Cinzel', serif;
    border-radius: 50%; 
    cursor: pointer;
    opacity: 0.6;
}

#action-btn:active {
    background-color: rgba(255, 255, 255, 0.6);
}


/* 5. RESPONSIVIDADE (MENSAGEM DE ROTAÇÃO) */
#rotate-message {
    display: none; 
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000000;
    color: #ffffff;
    z-index: 250; 
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 20px;
    font-family: 'Cinzel', serif;
    font-size: 1.2rem;
}

@media (orientation: portrait) {
    #rotate-message {
        display: flex; 
    }

    #crosshair,
    #dpad-container,
    #action-btn,
    #logo,
    #copyright,
    #loading-screen {
        display: none !important;
    }
}
js/loader.js
(Sem alterações. Este arquivo está perfeito)

JavaScript
/*
    ARQUIVO: loader.js
    DESCRIÇÃO: Gerenciador de Carregamento de Assets.
    FUNÇÃO: Este script é responsável por carregar todas as texturas (imagens)
    necessárias para o projeto ANTES que a experiência comece.
    
    COMENTÁRIOS EM: PT-BR
*/

class AssetLoader {
    // O construtor recebe as funções que devem ser chamadas
    // durante o carregamento (onProgress) e ao finalizar (onLoad).
    constructor(onProgress, onLoad) {
        // O LoadingManager monitora todos os loaders.
        this.manager = new THREE.LoadingManager();
        
        // Define as funções de callback do manager.
        this.manager.onProgress = (url, itemsLoaded, itemsTotal) => {
            // Calcula a porcentagem
            const progress = (itemsLoaded / itemsTotal) * 100;
            // Chama a função onProgress (definida em main.js)
            onProgress(progress);
            console.log(`Carregando: ${url} (${progress.toFixed(0)}%)`);
        };

        this.manager.onLoad = () => {
            // Chama a função onLoad (definida em main.js)
            onLoad();
            console.log('Todos os assets foram carregados.');
        };

        this.manager.onError = (url) => {
            console.error(`Erro ao carregar o asset: ${url}`);
        };

        // O TextureLoader é o responsável por carregar as imagens.
        // Passamos o manager para ele.
        this.textureLoader = new THREE.TextureLoader(this.manager);
    }

    /**
     * Carrega uma lista de texturas.
     * @param {Array<Object>} texturesToLoad - Um array de objetos { name, path }
     * @returns {Object} - Um objeto onde as chaves são os nomes (name) e os
     * valores são as texturas (THREE.Texture) carregadas.
     */
    loadTextures(texturesToLoad) {
        const textures = {};
        
        texturesToLoad.forEach(tex => {
            // Carrega a textura
            const texture = this.textureLoader.load(tex.path);
            
            // Configurações de repetição (wrapping) e filtro
            // Essencial para texturas de chão e parede.
            if (tex.repeat) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(tex.repeat[0], tex.repeat[1]);
            }

            // Adiciona ao nosso objeto de texturas
            textures[tex.name] = texture;
        });

        // Retorna o objeto com todas as texturas (que ainda estão carregando,
        // mas o manager vai saber quando terminarem).
        return textures;
    }
}
js/main.js (ATUALIZADO)
(Grandes mudanças: removido loadArtworkData, removidas texturas da galeria, simplificada a lógica de interação para "terminar o jogo")

JavaScript
/*
    ARQUIVO: main.js
    DESCRIÇÃO: Ponto de Entrada Principal da Aplicação (O "Maestro").
    FUNÇÃO: Este script inicializa todos os componentes da floresta (Cena 1),
    gerencia o "Game Loop" (o 'animate'), e lida com a lógica de
    interação para "terminar" a demo quando a porta é encontrada.
    
    COMENTÁRIOS EM: PT-BR
*/

// Classe principal da aplicação
class SungApp {
    
    constructor() {
        // Elementos do DOM
        this.canvas = document.getElementById('game-canvas');
        this.loadingScreen = document.getElementById('loading-screen');
        this.loadingText = document.querySelector('.loading-text');
        this.transitionFade = document.getElementById('transition-fade');
        this.gameEndMessage = document.getElementById('game-end-message'); // Mensagem de Fim
        this.uiElements = [
            document.getElementById('crosshair'),
            document.getElementById('logo'),
            document.getElementById('copyright')
        ];

        // Componentes do Three.js
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true // Suavização de serrilhado
        });
        this.clock = new THREE.Clock(); // Relógio para o 'delta time'

        // Componentes do Jogo
        this.loader = null;
        this.controls = null;
        this.interaction = null;
        this.worldFactory = null;
        
        // Grupo de Cena (Apenas Mundo 1)
        this.world1_Group = null;

        // Estado do Jogo
        this.isLoaded = false;
        this.isTransitioning = false; // Usado agora para o "fim de jogo"
        
        // Configurações (conforme UX finalizado)
        this.settings = {
            movementSpeed: 1.8,         // 1.8 m/s
            desktopCameraSpeed: 0.0008, // Sensibilidade Desktop
            mobileCameraSpeed: 0.0025,  // Sensibilidade Mobile
            playerHeight: 1.6           // Altura dos olhos do jogador
        };
        
        // Referência 'bind' para o loop de animação
        this.animate = this.animate.bind(this);
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Método principal de inicialização (não é mais 'async')
     */
    init() {
        console.log("Iniciando SungApp (Modo Floresta)...");

        try {
            // 1. Configurar o Renderizador
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            this.renderer.outputEncoding = THREE.sRGBEncoding;

            // 2. Configurar a Posição Inicial da Câmera
            // (Na borda do mapa, na rodovia, em Z=90)
            this.camera.position.set(0, this.settings.playerHeight, 90);

            // 3. Inicializar o Loader de Assets (Texturas)
            this.loader = new AssetLoader(
                (progress) => {
                    // Função 'onProgress'
                    this.loadingText.textContent = `Carregando... ${progress.toFixed(0)}%`;
                },
                () => {
                    // Função 'onLoad' (Tudo carregado)
                    this.startExperience();
                }
            );

            // 4. Definir quais texturas carregar
            // (Apenas texturas da floresta, sem o corredor)
            const sceneTextures = [
                { name: 'rodovia', path: 'assets/rodovia_texture.jpg', repeat: [3, 10] }, // (Asfalto)
                { name: 'porta', path: 'assets/porta.png' }, 
                { name: 'path', path: 'assets/path_texture.jpg', repeat: [2, 12] }, // (Tijolos)
                { name: 'arvore', path: 'assets/arvore.png' },
                { name: 'crystalGlow', path: 'assets/crystal_glow.png' },
                { name: 'rock', path: 'assets/rock.png' },
                { name: 'forest_floor', path: 'assets/forest_floor.jpg', repeat: [50, 50] } // (Terra)
            ];
            
            // Carrega as texturas da cena
            const loadedTextures = this.loader.loadTextures(sceneTextures);
            
            // 5. Inicializar a "Fábrica" de Mundos com as texturas
            this.worldFactory = new WorldSceneFactory(loadedTextures);

            // 6. Ouvinte de redimensionamento da janela
            window.addEventListener('resize', this.onWindowResize.bind(this));
        
        } catch (error) {
            console.error("Falha fatal na inicialização:", error);
            this.loadingText.textContent = "Erro ao carregar. Verifique o console.";
            this.loadingText.style.color = "red";
        }
    }
    
    /**
     * Chamado quando o Loader termina (onLoad).
     */
    startExperience() {
        console.log("Assets carregados. Iniciando a experiência.");
        this.isLoaded = true;
        
        // 1. Construir o Mundo 1 (Floresta)
        const world1Data = this.worldFactory.createWorld1(this.scene);
        this.world1_Group = world1Data.group;
        this.scene.add(this.world1_Group);

        // 2. Inicializar Controles
        this.controls = new PlayerControls(this.camera, this.canvas, this.settings);
        // Define os limites de colisão para o mundo 1
        this.controls.setWorld(1, world1Data.collisionLimits);
        
        // 3. Inicializar Interação
        this.interaction = new InteractionHandler(
            this.camera, 
            this.scene, 
            this.handleInteraction.bind(this) // Callback
        );
        
        // 4. Conectar Controles e Interação
        // Diz ao 'controls' qual função chamar quando [E] é pressionado
        this.controls.onInteract = () => {
            this.interaction.triggerInteraction();
        };

        // 5. Esconder a tela de Loading e mostrar a UI do Jogo
        this.loadingScreen.style.opacity = '0';
        setTimeout(() => {
            this.loadingScreen.style.display = 'none';
        }, 500); // 0.5s (duração da transição do CSS)

        // Mostra a UI (Mira, Logo, etc.)
        this.uiElements.forEach(el => el.style.display = 'block');
        
        // 6. Iniciar o Loop de Animação
        this.animate();
    }
    
    // -----------------------------------------------------------------
    // LOOP DE ANIMAÇÃO (GAME LOOP)
    // -----------------------------------------------------------------

    /**
     * O Loop Principal (requestAnimationFrame).
     */
    animate() {
        // Pede ao navegador para chamar 'animate' no próximo frame
        requestAnimationFrame(this.animate);

        // Se não carregou ou está em transição de fim de jogo, para
        if (!this.isLoaded || this.isTransitioning) {
            return;
        }

        // Pega o tempo delta (diferença do último frame)
        const delta = this.clock.getDelta();

        // 1. Atualiza o handler de interação (verifica o que está na mira)
        this.interaction.update();
        
        // 2. Atualiza os controles do jogador (movimento, colisão)
        this.controls.update(delta);

        // 3. Renderiza a cena 3D
        this.renderer.render(this.scene, this.camera);
    }
    
    // -----------------------------------------------------------------
    // LÓGICA DE INTERAÇÃO (FIM DE JOGO)
    // -----------------------------------------------------------------
    
    /**
     * Callback chamado pelo 'InteractionHandler' quando [E] é pressionado
     * em um alvo válido.
     * @param {Object} userData - Os dados do objeto (ex: { type: 'gothic_door' })
     */
    handleInteraction(userData) {
        console.log("Interação disparada:", userData);
        
        // Verifica se é a porta gótica
        if (userData.type === 'gothic_door') {
            this.triggerGameEnd();
        }
    }

    /**
     * Executa o "Fim de Jogo" (Fade para Branco)
     */
    triggerGameEnd() {
        if (this.isTransitioning) return; // Previne cliques duplos
        
        console.log("Fim da demo. Iniciando fade out...");
        this.isTransitioning = true; // Pausa o 'animate' loop

        // 1. Fade In Rápido (0.5s) para Branco
        this.transitionFade.style.transition = 'opacity 0.5s ease-in';
        this.transitionFade.style.opacity = '1';

        // 2. Mostra a mensagem "CONTINUA..."
        // (O delay da transição está no CSS)
        this.gameEndMessage.style.opacity = '1';

        // 3. (Opcional) Trava os controles
        // Se o PointerLock estiver ativo, destrava o mouse
        if (document.pointerLockElement) {
            document.exitPointerLock();
        }
        // Esconde a UI do jogo
        this.uiElements.forEach(el => el.style.display = 'none');
        document.getElementById('dpad-container').style.display = 'none';
        document.getElementById('action-btn').style.display = 'none';
    }

    // -----------------------------------------------------------------
    // UTILITÁRIOS
    // -----------------------------------------------------------------

    /**
     * Chamado quando a janela do navegador muda de tamanho.
     */
    onWindowResize() {
        // Atualiza as proporções da câmera
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();

        // Atualiza o tamanho do renderizador
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}

// -----------------------------------------------------------------
// PONTO DE ENTRADA
// -----------------------------------------------------------------

// Quando o DOM (HTML) estiver pronto, cria e inicializa a aplicação.
window.addEventListener('DOMContentLoaded', () => {
    // Lembrete sobre o servidor local (para o 'fetch' funcionar)
    if (window.location.protocol === 'file:') {
        console.error("ERRO: O projeto não pode ser executado localmente via 'file://'. Use um servidor local (veja como_rodar.txt).");
        document.body.innerHTML = '<div style="color: red; font-size: 20px; padding: 20px;">ERRO: O projeto não pode ser executado localmente. Por favor, use um servidor (veja o arquivo como_rodar.txt).</div>';
        return;
    }
    
    const app = new SungApp();
    app.init();
});
js/scene.js (ATUALIZADO)
(Removida toda a função createWorld2)

JavaScript
/*
    ARQUIVO: scene.js
    DESCRIÇÃO: Construtor de Cenários 3D.
    FUNÇÃO: Esta classe é uma "fábrica" de geometria. Ela contém
    apenas o método `createWorld1` para construir a cena da floresta.
    
    COMENTÁRIOS EM: PT-BR
*/

class WorldSceneFactory {

    constructor(textures) {
        // Armazena as texturas que o 'loader.js' carregou.
        this.textures = textures;
        // Altura padrão da câmera (nível dos olhos)
        this.playerHeight = 1.6;
    }

    // -----------------------------------------------------------------
    // CENA 1: A DESCOBERTA (MUNDO ABERTO / FLORESTA)
    // -----------------------------------------------------------------
    createWorld1(scene) {
        const world1Group = new THREE.Group();
        world1Group.name = "World1_Group"; // Nome para depuração

        // 1. Configuração do Clima (Névoa e Luz)
        // Cor cinza-azulado escuro, inspirada em 'clima.png' (Sleepy Hollow)
        const fogColor = 0x2c3e50; 
        scene.background = new THREE.Color(fogColor);
        // A névoa começa perto e fica densa rapidamente
        scene.fog = new THREE.Fog(fogColor, 1, 40); // Névoa densa

        // Luz ambiente fraca, para dar o tom sombrio
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // (cor, intensidade)
        world1Group.add(ambientLight);

        // Luz direcional (simulando lua/crepúsculo)
        const directionalLight = new THREE.DirectionalLight(0x505a70, 0.4);
        directionalLight.position.set(5, 10, 5);
        world1Group.add(directionalLight);

        
        // 2. Geometria do Chão (Mundo Aberto)
        
        // Chão da Floresta (Ground082S) - O MAPA INTEIRO
        const forestFloorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.forest_floor });
        const forestFloorGeometry = new THREE.PlaneGeometry(200, 200); // 200m x 200m
        const forestFloor = new THREE.Mesh(forestFloorGeometry, forestFloorMaterial);
        forestFloor.rotation.x = -Math.PI / 2;
        forestFloor.position.set(0, 0, 0); // Centralizado na origem
        world1Group.add(forestFloor);

        // Rodovia (Asphalt033) - PONTO DE INÍCIO
        const roadMaterial = new THREE.MeshBasicMaterial({ map: this.textures.rodovia });
        const roadGeometry = new THREE.PlaneGeometry(15, 60); // (largura, comprimento)
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; 
        road.position.set(0, 0.01, 70); // Na borda do mapa (Z=70 a Z=100)
        world1Group.add(road);

        // Trilha de Tijolos ESCONDIDA (Bricks075B)
        const pathMaterial = new THREE.MeshBasicMaterial({ map: this.textures.path });
        const pathGeometry = new THREE.PlaneGeometry(3, 40); // Trilha estreita (3m x 40m)
        const path = new THREE.Mesh(pathGeometry, pathMaterial);
        path.rotation.x = -Math.PI / 2;
        // Posição escondida dentro da floresta
        path.position.set(30, 0.01, -20); // Escondida em X=30, Z=-20
        world1Group.add(path);


        // 3. Floresta Densa (Billboards de Árvores)
        // Material da árvore (usa 'arvore.png')
        const treeMaterial = new THREE.SpriteMaterial({ 
            map: this.textures.tree,
            fog: true,
            color: 0xcccccc 
        });
        
        // Material do brilho do cristal
        const crystalMaterial = new THREE.SpriteMaterial({
            map: this.textures.crystalGlow,
            blending: THREE.AdditiveBlending, // Efeito de brilho
            fog: false, // Cristais brilham através da névoa
            transparent: true,
            opacity: 0.8
        });

        // Material da Rocha
        const rockMaterial = new THREE.SpriteMaterial({
            map: this.textures.rock,
            fog: true,
            color: 0xbbbbbb 
        });

        // Cria 2000 árvores para densidade
        for (let i = 0; i < 2000; i++) {
            const sprite = new THREE.Sprite(treeMaterial);
            
            const x = (Math.random() - 0.5) * 200; // X de -100 a 100
            const z = (Math.random() - 0.5) * 200; // Z de -100 a 100

            // *** LÓGICA PARA NÃO NASCER ÁRVORE NA ESTRADA OU NA TRILHA ***
            // Checa área da estrada (X -7.5 a 7.5, Z 40 a 100)
            if (x > -7.5 && x < 7.5 && z > 40 && z < 100) {
                continue; // Pula esta árvore
            }
            // Checa área da trilha (X 28.5 a 31.5, Z -40 a 0)
            if (x > 28.5 && x < 31.5 && z > -40 && z < 0) {
                continue; // Pula esta árvore
            }

            // Tamanho aleatório (árvores grandes e médias)
            const scale = Math.random() * 3 + 4; // Escala entre 4m e 7m
            sprite.scale.set(scale, scale, 1);
            sprite.position.set(x, scale / 2, z); // (x, altura, z)
            world1Group.add(sprite);
        }

        // Adiciona Rochas (100)
        for (let i = 0; i < 100; i++) {
            const rockSprite = new THREE.Sprite(rockMaterial);
            const x = (Math.random() - 0.5) * 200; 
            const z = (Math.random() - 0.5) * 200;
            
            // Checa área da estrada
            if (x > -7.5 && x < 7.5 && z > 40 && z < 100) continue; 
            // Checa área da trilha
            if (x > 28.5 && x < 31.5 && z > -40 && z < 0) continue; 

            const scale = Math.random() * 0.5 + 0.5; // Rochas pequenas (0.5m a 1m)
            rockSprite.scale.set(scale, scale, 1);
            rockSprite.position.set(x, scale / 2, z); // No chão
            world1Group.add(rockSprite);
        }

        // 4. A Pista de Cristais (As "Migalhas de Pão")
        // Coloca cristais guiando da estrada (0, 60) até a trilha (30, 0)
        const crystalPath = [
            {x: 5, z: 60},
            {x: 10, z: 55},
            {x: 15, z: 50},
            {x: 20, z: 40},
            {x: 25, z: 30},
            {x: 30, z: 20},
            {x: 30, z: 10},
            {x: 30, z: 0}, // Chegou na trilha
            {x: 30, z: -10},
            {x: 30, z: -20},
            {x: 30, z: -30} // Perto da porta
        ];

        crystalPath.forEach(pos => {
            // Luz Pontual (azulada)
            const light = new THREE.PointLight(0xadd8e6, 1.5, 8); // (cor, intensidade, distância)
            light.position.set(pos.x, 1.5, pos.z); // Posição
            world1Group.add(light);
            
            // Sprite visual do cristal
            const crystalSprite = new THREE.Sprite(crystalMaterial);
            crystalSprite.position.copy(light.position);
            crystalSprite.scale.set(1.5, 2.5, 1); 
            world1Group.add(crystalSprite);
        });


        // 5. A Porta Gótica (Objetivo)
        // Simula a "rocha" onde a porta está
        const rockFaceMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 }); 
        const rockFaceGeometry = new THREE.PlaneGeometry(8, 8); // Parede de rocha
        const rockFace = new THREE.Mesh(rockFaceGeometry, rockFaceMaterial);
        // Posicionada no final da trilha escondida
        rockFace.position.set(30, 4, -40.5); // (x, altura, z)
        world1Group.add(rockFace);
        
        // A porta em si
        const doorMaterial = new THREE.MeshBasicMaterial({ 
            map: this.textures.porta,
            transparent: true 
        });
        const doorGeometry = new THREE.PlaneGeometry(4, 5); // Tamanho da porta
        const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
        
        // Posiciona no final da trilha, em frente à rocha
        doorMesh.position.set(30, 2.5, -40); // (x, altura, z)
        
        // Adiciona o 'userData' para interação
        doorMesh.userData = { 
            interactive: true, 
            type: 'gothic_door' 
        };
        world1Group.add(doorMesh);


        // 6. Limites de Colisão (Mundo Aberto)
        // Agora, os limites são apenas as bordas do mapa (chão da floresta)
        const worldLimits = {
            minX: -98, // 2m de margem
            maxX: 98,
            minZ: -98,
            maxZ: 98
        };

        // Retorna o grupo de objetos e os limites de colisão
        return { group: world1Group, collisionLimits: worldLimits };
    }

    //
    // FUNÇÃO createWorld2() FOI REMOVIDA
    //
}
js/controls.js
(Sem alterações. Este arquivo está perfeito)

JavaScript
/*
    ARQUIVO: controls.js
    DESCRIÇÃO: Gerenciador de Controles do Jogador (Input Handler).
    FUNÇÃO: Gerencia todo o input (Teclado, Mouse, Toque) e
    a lógica de colisão.
    
    COMENTÁRIOS EM: PT-BR
*/

class PlayerControls {

    /**
     * @param {THREE.Camera} camera - A câmera do jogador.
     * @param {HTMLElement} domElement - O elemento canvas (para eventos).
     * @param {Object} settings - Configurações de velocidade e sensibilidade.
     */
    constructor(camera, domElement, settings) {
        this.camera = camera;
        this.domElement = domElement;
        this.settings = settings;

        // Referência à função de interação (definida em main.js)
        this.onInteract = () => {}; 
        
        // Estado de movimento
        this.moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        // Estado da Câmera (Mouse Look)
        this.cameraLook = {
            pitch: 0, // Rotação vertical (X)
            yaw: 0   // Rotação horizontal (Y)
        };
        
        // Propriedades de física/movimento
        this.velocity = new THREE.Vector3();
        this.direction = new THREE.Vector3();

        // Configurações do mundo atual (Cena 1 ou Cena 2)
        this.currentWorld = 1;
        this.collisionLimits = null; // Limites de colisão do mundo atual
        
        // Detecção de Mobile (baseado em 'touchstart')
        this.isMobile = 'ontouchstart' in window;
        
        // Armazena o ID do toque de movimento (para multi-toque)
        this.moveTouchId = null; 
        this.lookTouchId = null;
        this.lastLookPos = { x: 0, y: 0 };
        
        // Ajusta a sensibilidade para mobile (conforme UX finalizado)
        this.sensitivity = this.isMobile ? 
            this.settings.mobileCameraSpeed : 
            this.settings.desktopCameraSpeed;

        // Inicializa os ouvintes de eventos
        this.initListeners();
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO DOS OUVINTES DE EVENTO
    // -----------------------------------------------------------------
    initListeners() {
        if (this.isMobile) {
            // Se for mobile, inicializa os controles de toque
            this.initMobileControls();
        } else {
            // Se for desktop, inicializa o Pointer Lock (travar mouse)
            this.initPointerLock();
            // E os ouvintes de teclado
            document.addEventListener('keydown', this.onKeyDown.bind(this));
            document.addEventListener('keyup', this.onKeyUp.bind(this));
        }
    }

    // (Desktop) Configura o Pointer Lock
    initPointerLock() {
        this.domElement.addEventListener('click', () => {
            this.domElement.requestPointerLock();
        });

        // Ouve o movimento do mouse APENAS quando o mouse está travado
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === this.domElement) {
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
            } else {
                document.removeEventListener('mousemove', this.onMouseMove.bind(this));
            }
        });
    }

    // (Mobile) Configura os botões de toque
    initMobileControls() {
        // Mostra os botões de D-Pad e Ação
        document.getElementById('dpad-container').style.display = 'grid';
        document.getElementById('action-btn').style.display = 'block';

        // Ouvintes do D-Pad (touchstart = pressionar, touchend = soltar)
        this.addTouchListener('dpad-forward', 'forward');
        this.addTouchListener('dpad-backward', 'backward');
        this.addTouchListener('dpad-left', 'left');
        this.addTouchListener('dpad-right', 'right');

        // Ouvinte do Botão de Ação
        document.getElementById('action-btn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.onInteract(); // Chama a função de interação
        });
        
        // Ouvinte de Toque na Tela (para olhar ao redor)
        this.domElement.addEventListener('touchstart', this.onMobileTouchStart.bind(this));
        this.domElement.addEventListener('touchmove', this.onMobileTouchMove.bind(this));
        this.domElement.addEventListener('touchend', this.onMobileTouchEnd.bind(this));
    }

    // (Mobile) Função auxiliar para adicionar ouvintes de toque
    addTouchListener(elementId, direction) {
        const element = document.getElementById(elementId);
        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.moveState[direction] = true;
        });
        element.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.moveState[direction] = false;
        });
    }

    // -----------------------------------------------------------------
    // HANDLERS DE EVENTO (MOVIMENTO / AÇÃO)
    // -----------------------------------------------------------------

    // (Desktop) Tecla pressionada
    onKeyDown(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = true; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = true; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = true; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = true; break;
            case 'KeyE': this.onInteract(); break; // Tecla de Interação [E]
        }
    }

    // (Desktop) Tecla solta
    onKeyUp(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = false; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = false; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = false; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = false; break;
        }
    }

    // (Desktop) Movimento do mouse (Pointer Lock)
    onMouseMove(event) {
        if (document.pointerLockElement !== this.domElement) return;

        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;

        // Rotação Horizontal (Yaw) - Eixo Y
        this.cameraLook.yaw -= movementX * this.sensitivity;
        
        // Rotação Vertical (Pitch) - Eixo X
        this.cameraLook.pitch -= movementY * this.sensitivity;
        
        // Trava a rotação vertical (para não "quebrar o pescoço")
        this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
        
        // Aplica as rotações (Ordem EULER_YXZ é importante para FPS)
        this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
    }

    // (Mobile) Início do toque na tela
    onMobileTouchStart(event) {
        event.preventDefault();
        // Itera sobre os toques
        for (const touch of event.changedTouches) {
            // Se o toque for na metade direita da tela, é para "olhar"
            if (touch.clientX > window.innerWidth / 2 && this.lookTouchId === null) {
                this.lookTouchId = touch.identifier;
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;
            }
        }
    }

    // (Mobile) Movimento do toque na tela (Olhar)
    onMobileTouchMove(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se for o toque que estamos rastreando para "olhar"
            if (touch.identifier === this.lookTouchId) {
                const deltaX = touch.clientX - this.lastLookPos.x;
                const deltaY = touch.clientY - this.lastLookPos.y;

                // Salva a nova posição
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;

                // Aplica a rotação (similar ao onMouseMove)
                this.cameraLook.yaw -= deltaX * this.sensitivity;
                this.cameraLook.pitch -= deltaY * this.sensitivity;
                this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
                
                this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
            }
        }
    }

    // (Mobile) Fim do toque na tela
    onMobileTouchEnd(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se o toque que terminou era o de "olhar", para de rastrear
            if (touch.identifier === this.lookTouchId) {
                this.lookTouchId = null;
            }
        }
    }


    // -----------------------------------------------------------------
    // ATUALIZAÇÃO (LOOP PRINCIPAL) E COLISÃO
    // -----------------------------------------------------------------

    /**
     * Define os limites de colisão do mundo atual.
     * @param {number} worldId - 1 para Floresta, 2 para Corredor.
     * @param {Object} limits - O objeto de limites vindo de 'scene.js'.
     */
    setWorld(worldId, limits) {
        this.currentWorld = worldId;
        this.collisionLimits = limits;
    }
    
    /**
     * Reseta a rotação da câmera (usado na transição).
     */
    resetRotation() {
        this.cameraLook.pitch = 0;
        this.cameraLook.yaw = 0;
        this.camera.rotation.set(0, 0, 0, 'YXZ');
    }

    /**
     * Chamado a cada frame pelo 'main.js'.
     * @param {number} delta - O tempo (em segundos) desde o último frame.
     */
    update(delta) {
        // Velocidade = 1.8 m/s (conforme UX finalizado)
        const moveSpeed = this.settings.movementSpeed * delta;

        // Reseta a direção do movimento
        this.direction.z = Number(this.moveState.forward) - Number(this.moveState.backward);
        this.direction.x = Number(this.moveState.left) - Number(this.moveState.right);
        this.direction.normalize(); // Garante movimento consistente (diagonal != mais rápido)

        // Salva a posição atual para checagem de colisão
        const oldPosition = this.camera.position.clone();

        // Calcula o movimento relativo à direção que a câmera está olhando
        if (this.moveState.forward || this.moveState.backward) {
            this.camera.translateZ(-this.direction.z * moveSpeed);
        }
        if (this.moveState.left || this.moveState.right) {
            this.camera.translateX(-this.direction.x * moveSpeed);
        }

        // --- LÓGICA DE COLISÃO ---
        // Impede o jogador de sair dos limites definidos
        if (this.collisionLimits) {
            this.applyCollisions(oldPosition);
        }
        
        // Mantém a altura do jogador (impede de voar ou afundar)
        this.camera.position.y = this.settings.playerHeight;
    }

    /**
     * Verifica e aplica as colisões baseadas nos limites do mundo.
     * @param {THREE.Vector3} oldPosition - Posição antes do movimento.
     */
    applyCollisions(oldPosition) {
        const newPosition = this.camera.position;
        const limits = this.collisionLimits;

        // Lógica de Colisão simples de "caixa" (para ambos os mundos)
        // Isso nos dá a liberdade de explorar no Mundo 1
        newPosition.x = Math.max(limits.minX, Math.min(limits.maxX, newPosition.x));
        newPosition.z = Math.max(limits.minZ, Math.min(limits.maxZ, newPosition.z));
        
        // Aplica a posição corrigida
        this.camera.position.copy(newPosition);
    }
}
js/interaction.js
(Sem alterações. Este arquivo está perfeito)

JavaScript
/*
    ARQUIVO: interaction.js
    DESCRIÇÃO: Gerenciador de Interação (Raycaster).
    FUNÇÃO: Esta classe é responsável por "atirar um raio" (Raycast)
    a partir do centro da tela (mira) para detectar com o que
    o jogador está olhando/interagindo.
    
    COMENTÁRIOS EM: PT-BR
*/

class InteractionHandler {

    /**
     * @param {THREE.Camera} camera - A câmera do jogador (de onde o raio sai).
     * @param {THREE.Scene} scene - A cena (onde os objetos estão).
     * @param {Function} onInteractCallback - Função em 'main.js' a ser chamada
     * quando uma interação válida ocorre.
     */
    constructor(camera, scene, onInteractCallback) {
        this.camera = camera;
        this.scene = scene;
        this.onInteractCallback = onInteractCallback;

        // O Raycaster do Three.js
        this.raycaster = new THREE.Raycaster();
        
        // Coordenadas da mira (sempre [0, 0] = centro da tela)
        this.crosshairCoords = new THREE.Vector2(0, 0);

        // Distância máxima de interação (ex: 3 metros)
        this.interactionDistance = 3.0; 

        // Armazena o objeto que está atualmente na mira
        this.currentTarget = null;
    }

    /**
     * Chamado quando o jogador pressiona [E] ou o Botão de Ação.
     * Esta é a função que efetivamente "dispara" a interação.
     */
    triggerInteraction() {
        // Verifica se há um alvo válido na mira
        if (this.currentTarget) {
            // Chama a função de callback em 'main.js'
            // e passa os dados do objeto (ex: { type: 'gothic_door' })
            this.onInteractCallback(this.currentTarget.userData);
        } else {
            // (Opcional) Tocar um som de "falha" se não houver nada
            console.log("Nenhum alvo interativo ao alcance.");
        }
    }

    /**
     * Chamado a cada frame pelo 'main.js' (ANTES do update de controles).
     * Esta função *apenas* verifica o que está na mira, mas não
     * dispara a ação.
     */
    update() {
        // 1. Atualiza o raio para sair do centro da câmera
        this.raycaster.setFromCamera(this.crosshairCoords, this.camera);

        // 2. Verifica quais objetos na cena (recursivamente) o raio atinge
        // Passamos 'this.scene.children' e 'true' para verificar os filhos
        // dos grupos (World1_Group).
        const intersects = this.raycaster.intersectObjects(this.scene.children, true);

        // Reseta o alvo atual
        this.currentTarget = null;

        // 3. Itera sobre os objetos atingidos
        for (const intersect of intersects) {
            
            // 4. Verifica se o objeto tem o 'userData' interativo
            // (Nós definimos isso em 'scene.js' na porta)
            if (intersect.object.userData && intersect.object.userData.interactive === true) {
                
                // 5. Verifica se está dentro da distância permitida
                if (intersect.distance <= this.interactionDistance) {
                    
                    // Encontramos um alvo válido!
                    this.currentTarget = intersect.object;
                    
                    // (Opcional) Mudar a cor da mira para "ativa"
                    // document.getElementById('crosshair').style.color = 'red';
                    
                    // Para o loop assim que encontrar o primeiro alvo válido
                    break;
                }
            }
        }
        
        // Se o loop terminou e this.currentTarget ainda é nulo,
        // significa que não estamos olhando para nada interativo.
        if (this.currentTarget === null) {
            // (Opcional) Resetar a cor da mira para "passiva"
            // document.getElementById('crosshair').style.color = 'rgba(255, 255, 255, 0.7)';
        }
    }
}
ta mais uma alteracao vamos fazer uma pasta so pra floresta e uma geral (dos js ) e uma pro corredor (nao se esqueca de add os comentarios

maque onde eu devo

colocar as texturas e etc

Certo. Esta é uma excelente ideia de organização. Vamos refatorar o projeto inteiro para essa nova estrutura.

A nova estrutura de JavaScript será:

/js/geral/: Para os scripts principais que controlam o app (main, loader, controls, interaction).

/js/floresta/: Para o script que constrói a Cena 1 (A Floresta).

/js/corredor/: Para o script que constrói a Cena 2 (O Corredor).

Isto vai deixar o projeto muito mais limpo e fácil de manter. Também vou marcar claramente em MAIÚSCULAS nos arquivos README.md e checklist.txt exatamente onde cada textura deve ir.

Aqui está o código completo do zero, com a nova estrutura e todos os comentários.

Nova Estrutura de Pastas (Visão Geral)
/
│
├── index.html
├── README.md
├── COMO_EDITAR.txt
├── como_rodar.txt
├── checklist.txt
│
├── assets/
│   ├── (COLOQUE AS TEXTURAS DO CENÁRIO AQUI)
│   │   ├── belial.png, rodovia_texture.jpg, porta.png, arvore.png, ...
│   └── audio/
│
├── CSS/
│   └── styles.css
│
├── data/
│   └── arts.json
│
├── img/
│   ├── (COLOQUE AS 18 IMAGENS DE TATUAGEM AQUI)
│   │   ├── tattoo_01.png, tattoo_02.png, ...
│
└── js/
    ├── geral/
    │   ├── main.js
    │   ├── controls.js
    │   ├── interaction.js
    │   └── loader.js
    │
    ├── floresta/
    │   └── CenaFloresta.js
    │
    └── corredor/
        └── CenaCorredor.js
index.html
(Note que os caminhos <script src="..."> foram atualizados para a nova estrutura)

HTML
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sung Studios - 3D Portfolio</title>
    
    <link rel="stylesheet" href="CSS/styles.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-text">Carregando...</div>
    </div>

    <div id="rotate-message">
        <p>Por favor, gire seu dispositivo para a posição horizontal (paisagem) para iniciar a experiência.</p>
    </div>

    <div id="transition-fade"></div>

    <div id="crosshair">+</div>

    <div id="dpad-container">
        <button id="dpad-forward" class="dpad-btn">▲</button>
        <button id="dpad-backward" class="dpad-btn">▼</button>
        <button id="dpad-left" class="dpad-btn">◄</button>
        <button id="dpad-right" class="dpad-btn">►</button>
    </div>

    <button id="action-btn">E</button>

    <div id="logo">
        <img src="assets/belial.png" alt="Sung Studios Logo">
    </div>
    
    <div id="copyright">© 2025 Sung</div>

    <canvas id="game-canvas"></canvas>

    <script src="js/geral/loader.js"></script>
    <script src="js/geral/controls.js"></script>
    <script src="js/geral/interaction.js"></script>
    
    <script src="js/floresta/CenaFloresta.js"></script>
    <script src="js/corredor/CenaCorredor.js"></script>
    
    <script src="js/geral/main.js"></script>

</body>
</html>
README.md (ATUALIZADO)
(Com a nova estrutura de arquivos marcada)

Markdown
# Sung Studios - Portfólio 3D Gótico

Este é o repositório do projeto para o site interativo 3D "Sung Studios", um portfólio de tatuagem com tema de horror cinematográfico.

## Visão Geral

O projeto é uma experiência narrativa em primeira pessoa que guia o usuário por duas cenas distintas:
1.  **A Descoberta:** Uma floresta escura e aberta (200x200m) para explorar. O jogador começa em uma rodovia e deve seguir uma trilha de cristais luminosos para encontrar uma trilha de tijolos escondida, que leva à porta gótica.
2.  **A Galeria:** Um corredor linear e sombrio onde as 18 artes do portfólio estão em exibição.

A experiência é construída com uma estética de horror sutil, inspirada em *Sleepy Hollow* de Tim Burton.

## Stack Técnica

* **HTML5**
* **CSS3**
* **JavaScript (ES6+)**
* **Three.js** (incluído via CDN)

## Estrutura de Arquivos (IMPORTANTE)

/ │ ├── index.html (HTML Principal) ├── README.md (Este arquivo) ├── COMO_EDITAR.txt (Instruções de edição PT-BR) ├── como_rodar.txt (Instruções de servidor local) ├── checklist.txt (LISTA DE TEXTURAS OBRIGATÓRIAS) │ ├── assets/ │ ├── (COLOQUE AS TEXTURAS DO CENÁRIO AQUI) │ │ ├── belial.png, rodovia_texture.jpg, porta.png, arvore.png, ... │ └── audio/ │ ├── CSS/ │ └── styles.css │ ├── data/ │ └── arts.json │ ├── img/ │ ├── (COLOQUE AS 18 IMAGENS DE TATUAGEM AQUI) │ │ ├── tattoo_01.png, tattoo_02.png, ... │ └── js/ ├── geral/ │ ├── main.js (O "Maestro" que controla tudo) │ ├── controls.js (Controla o movimento do jogador) │ ├── interaction.js (Controla a mira e interação "E") │ └── loader.js (Carrega as texturas) │ ├── floresta/ │ └── CenaFloresta.js (Script que constrói a Cena 1 - Floresta) │ └── corredor/ └── CenaCorredor.js (Script que constrói a Cena 2 - Corredor)


## Como Rodar

Consulte `como_rodar.txt` para instruções sobre como iniciar um servidor local, que é **obrigatório** para carregar os assets.

---
© 2025 Sung
checklist.txt (ATUALIZADO)
(Marca claramente onde colocar cada textura)

Plaintext
=================================================
CHECKLIST DE ASSETS DO PROJETO (PT-BR)
=================================================

Verifique se todos os assets (arquivos de mídia) necessários estão nas pastas corretas antes de testar o projeto. O CÓDIGO NÃO FUNCIONARÁ SEM ELES.

### 1. Imagens de Cenário (Obrigatórias)
### >> COLOQUE TODOS ESTES ARQUIVOS DENTRO DA PASTA: /assets/

[ ] belial.png             (Logo "Sung" que aparece no canto)
[ ] rodovia_texture.jpg    (Textura de asfalto molhado)
[ ] porta.png              (Textura da porta gótica - IMAGEM QUE VOCÊ FORNECEU)
[ ] arvore.png             (Imagem da árvore com fundo transparente para a floresta)
[ ] path_texture.jpg       (Textura de tijolos escuros para a trilha)
[ ] forest_floor.jpg       (Textura de terra molhada para a floresta)
[ ] crystal_glow.png       (Textura de brilho para os cristais)
[ ] rock.png               (Imagem de rocha com fundo transparente)
[ ] wall_texture.jpg       (TextURA DA PAREDE da galeria/corredor)
[ ] floor_texture.jpg      (TextURA DO CHÃO da galeria/corredor)

### 2. Imagens da Galeria (Obrigatórias)
### >> COLOQUE TODOS ESTES ARQUIVOS DENTRO DA PASTA: /img/

[ ] tattoo_01.png
[ ] tattoo_02.png
[ ] tattoo_03.png
[ ] tattoo_04.png
[ ] tattoo_05.png
[ ] tattoo_06.png
[ ] tattoo_07.png
[ ] tattoo_08.png
[ ] tattoo_09.png
[ ] tattoo_10.png
[ ] tattoo_11.png
[ ] tattoo_12.png
[ ] tattoo_13.png
[ ] tattoo_14.png
[ ] tattoo_15.png
[ ] tattoo_16.png
[ ] tattoo_17.png
[ ] tattoo_18.png
(Total de 18 imagens de tatuagem)
COMO_EDITAR.txt (ATUALIZADO)
(Com os dois mundos de volta)

Plaintext
=================================================
GUIA DE MANUTENÇÃO - SUNG STUDIOS (PT-BR)
=================================================

Este arquivo explica como atualizar o conteúdo do site 3D sem precisar mexer no código principal.

-------------------------------------------------
1. COMO ADICIONAR OU MUDAR AS TATUAGENS (OBRAS DE ARTE)
-------------------------------------------------

Toda a galeria no "Mundo 2" (O Corredor) é gerada automaticamente a partir de um único arquivo.

ARQUIVO PARA EDITAR: /data/arts.json

PASSO 1: ADICIONE SUAS IMAGENS
1.  Pegue seus 18 arquivos de imagem (.png ou .jpg).
2.  Renomeie-os para nomes simples (ex: 'tattoo_01.png', 'tattoo_02.png', etc.).
3.  COLOQUE TODOS OS 18 ARQUIVOS DENTRO DA PASTA: /img/

PASSO 2: ATUALIZE O ARQUIVO 'arts.json'
1.  Abra o arquivo /data/arts.json em um editor de texto.
2.  Você verá uma lista (array) `[ ... ]` de objetos `{ ... }`.

Exemplo de um objeto:
{
    "id": 1,
    "image": "img/tattoo_01.png",            // <-- MUDE ESTE CAMINHO
    "title": "Nome da Arte 1",                  // <-- MUDE O TÍTULO
    "description": "Descrição da sua arte aqui."  // <-- MUDE A DESCRIÇÃO
},

3.  Para cada uma das 18 obras, atualize o caminho, título e descrição.
4.  **IMPORTANTE**: O formato JSON exige aspas duplas ("") em todas as chaves (como "id") e valores de texto. O último item da lista NÃO deve ter uma vírgula no final.

5.  Salve o arquivo. O site será atualizado automaticamente.

-------------------------------------------------
2. COMO MUDAR TEXTURAS DO CENÁRIO (AVANÇADO)
-------------------------------------------------

PASTA DE TEXTURAS: /assets/

* `rodovia_texture.jpg`: A textura do asfalto da estrada.
* `porta.png`: A textura da porta gótica.
* `belial.png`: O logo no canto da tela.
* `arvore.png`: A imagem da árvore usada na floresta (billboard).
* `path_texture.jpg`: A textura dos tijolos da trilha escondida.
* `forest_floor.jpg`: A textura de terra molhada da floresta.
* `crystal_glow.png`: O brilho do cristal.
* `rock.png`: A rocha na floresta.
* `wall_texture.jpg`: A textura das paredes do corredor.
* `floor_texture.jpg`: A textura do chão do corredor.

Basta substituir o arquivo de imagem nesta pasta pelo seu novo arquivo, MANTENDO O MESMO NOME E EXTENSÃO.
como_rodar.txt
(Sem alterações, mas essencial)

Plaintext
=================================================
COMO RODAR O PROJETO (PT-BR)
=================================================

Este projeto **NÃO FUNCIONA** se você apenas abrir o arquivo `index.html` diretamente no navegador (ex: `file:///C:/.../index.html`).

Isso acontece por causa das políticas de segurança (CORS) dos navegadores, que bloqueiam o carregamento de texturas e arquivos de dados (como o `arts.json`) dessa maneira.

Você **PRECISA** de um servidor local.

-------------------------------------------------
COMO RODAR (MÉTODO FÁCIL - VS CODE)
-------------------------------------------------

1.  Abra a pasta do projeto no Visual Studio Code (VS Code).
2.  Vá até a aba "Extensions" (Extensões) na barra lateral.
3.  Procure por "Live Server" (feito por Ritwick Dey).
4.  Instale a extensão.
5.  Depois de instalado, volte para a lista de arquivos.
6.  Clique com o botão direito no arquivo `index.html`.
7.  Selecione "Open with Live Server" (Abrir com Live Server).

Isso iniciará um servidor local (ex: `http://127.0.0.1:5500`) e o projeto funcionará.
CSS/styles.css
(Sem alterações)

CSS
/*
    ARQUIVO: CSS/styles.css
    DESCRIÇÃO: Folha de Estilos Principal.
    FUNÇÃO: Define todos os estilos visuais da aplicação.
    
    COMENTÁRIOS EM: PT-BR
*/

/* 1. CONFIGURAÇÃO GLOBAL E FONTES */
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400&display=swap');

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden; 
    background-color: #000000;
    color: #ffffff;
    font-family: 'Inter', sans-serif;
}

/* 2. ELEMENTOS 3D E OVERLAYS */
#game-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; 
    cursor: pointer; 
}

#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000000;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 200; 
    transition: opacity 0.5s ease-out;
}

.loading-text {
    font-family: 'Cinzel', serif;
    font-size: 1.5rem;
    color: #ffffff;
}

/* Tela de Transição (Usada para a mudança de cena) */
#transition-fade {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #ffffff; /* Fundo branco do fade */
    opacity: 0;
    pointer-events: none; 
    z-index: 150; 
    display: flex;
    justify-content: center;
    align-items: center;
}


/* 3. UI FIXA (MIRA, LOGO, COPYRIGHT) */
#crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    font-weight: bold;
    color: rgba(255, 255, 255, 0.7); 
    pointer-events: none; 
    z-index: 100;
    display: none; 
}

#logo {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 100;
    opacity: 0.8;
    pointer-events: none;
    display: none; 
}

#logo img {
    width: 100px; 
    height: auto;
}

#copyright {
    position: fixed;
    bottom: 10px;
    right: 10px;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.5);
    z-index: 100;
    pointer-events: none;
    display: none; 
}


/* 4. CONTROLES MOBILE (D-PAD E BOTÃO DE AÇÃO) */
#dpad-container,
#action-btn {
    display: none; 
    position: fixed;
    z-index: 110;
    user-select: none; 
    -webkit-user-select: none;
}

#dpad-container {
    bottom: 30px;
    left: 30px;
    width: 150px;
    height: 150px;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr 1fr;
    opacity: 0.5; 
}

#dpad-forward { grid-area: 1 / 2 / 2 / 3; }
#dpad-left { grid-area: 2 / 1 / 3 / 2; }
#dpad-right { grid-area: 2 / 3 / 3 / 4; }
#dpad-backward { grid-area: 3 / 2 / 4 / 3; }

.dpad-btn {
    background-color: rgba(255, 255, 255, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.5);
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
    border-radius: 8px; 
}

.dpad-btn:active {
    background-color: rgba(255, 255, 255, 0.6);
}

#action-btn {
    bottom: 40px;
    right: 40px;
    width: 80px;
    height: 80px;
    background-color: rgba(255, 255, 255, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.7);
    color: white;
    font-size: 2rem;
    font-weight: bold;
    font-family: 'Cinzel', serif;
    border-radius: 50%; 
    cursor: pointer;
    opacity: 0.6;
}

#action-btn:active {
    background-color: rgba(255, 255, 255, 0.6);
}


/* 5. RESPONSIVIDADE (MENSAGEM DE ROTAÇÃO) */
#rotate-message {
    display: none; 
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000000;
    color: #ffffff;
    z-index: 250; 
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 20px;
    font-family: 'Cinzel', serif;
    font-size: 1.2rem;
}

@media (orientation: portrait) {
    #rotate-message {
        display: flex; 
    }

    #crosshair,
    #dpad-container,
    #action-btn,
    #logo,
    #copyright,
    #loading-screen {
        display: none !important;
    }
}
data/arts.json
(Este arquivo está de volta)

JSON
[
    {
        "id": 1,
        "image": "img/tattoo_01.png",
        "title": "Título da Arte 1",
        "description": "Descrição detalhada da obra de arte número 1."
    },
    {
        "id": 2,
        "image": "img/tattoo_02.png",
        "title": "Título da Arte 2",
        "description": "Descrição detalhada da obra de arte número 2."
    },
    {
        "id": 3,
        "image": "img/tattoo_03.png",
        "title": "Título da Arte 3",
        "description": "Descrição detalhada da obra de arte número 3."
    },
    {
        "id": 4,
        "image": "img/tattoo_04.png",
        "title": "Título da Arte 4",
        "description": "Descrição detalhada da obra de arte número 4."
    },
    {
        "id": 5,
        "image": "img/tattoo_05.png",
        "title": "Título da Arte 5",
        "description": "Descrição detalhada da obra de arte número 5."
    },
    {
        "id": 6,
        "image": "img/tattoo_06.png",
        "title": "Título da Arte 6",
        "description": "Descrição detalhada da obra de arte número 6."
    },
    {
        "id": 7,
        "image": "img/tattoo_07.png",
        "title": "Título da Arte 7",
        "description": "Descrição detalhada da obra de arte número 7."
    },
    {
        "id": 8,
        "image": "img/tattoo_08.png",
        "title": "Título da Arte 8",
        "description": "Descrição detalhada da obra de arte número 8."
    },
    {
        "id": 9,
        "image": "img/tattoo_09.png",
        "title": "Título da Arte 9",
        "description": "Descrição detalhada da obra de arte número 9."
    },
    {
        "id": 10,
        "image": "img/tattoo_10.png",
        "title": "Título da Arte 10",
        "description": "Descrição detalhada da obra de arte número 10."
    },
    {
        "id": 11,
        "image": "img/tattoo_11.png",
        "title": "Título da Arte 11",
        "description": "Descrição detalhada da obra de arte número 11."
    },
    {
        "id": 12,
        "image": "img/tattoo_12.png",
        "title": "Título da Arte 12",
        "description": "Descrição detalhada da obra de arte número 12."
    },
    {
        "id": 13,
        "image": "img/tattoo_13.png",
        "title": "Título da Arte 13",
        "description": "Descrição detalhada da obra de arte número 13."
    },
    {
        "id": 14,
        "image": "img/tattoo_14.png",
        "title": "Título da Arte 14",
        "description": "Descrição detalhada da obra de arte número 14."
    },
    {
        "id": 15,
        "image": "img/tattoo_15.png",
        "title": "Título da Arte 15",
        "description": "Descrição detalhada da obra de arte número 15."
    },
    {
        "id": 16,
        "image": "img/tattoo_16.png",
        "title": "Título da Arte 16",
        "description": "Descrição detalhada da obra de arte número 16."
    },
    {
        "id": 17,
        "image": "img/tattoo_17.png",
        "title": "Título da Arte 17",
        "description": "Descrição detalhada da obra de arte número 17."
    },
    {
        "id": 18,
        "image": "img/tattoo_18.png",
        "title": "Título da Arte 18",
        "description": "Descrição detalhada da obra de arte número 18."
    }
]
js/geral/loader.js (NOVO LOCAL)
JavaScript
/*
    ARQUIVO: js/geral/loader.js
    DESCRIÇÃO: Gerenciador de Carregamento de Assets.
    FUNÇÃO: Este script é responsável por carregar todas as texturas (imagens)
    necessárias para o projeto ANTES que a experiência comece.
    
    COMENTÁRIOS EM: PT-BR
*/

class AssetLoader {
    // O construtor recebe as funções que devem ser chamadas
    // durante o carregamento (onProgress) e ao finalizar (onLoad).
    constructor(onProgress, onLoad) {
        // O LoadingManager monitora todos os loaders.
        this.manager = new THREE.LoadingManager();
        
        // Define as funções de callback do manager.
        this.manager.onProgress = (url, itemsLoaded, itemsTotal) => {
            // Calcula a porcentagem
            const progress = (itemsLoaded / itemsTotal) * 100;
            // Chama a função onProgress (definida em main.js)
            onProgress(progress);
            console.log(`Carregando: ${url} (${progress.toFixed(0)}%)`);
        };

        this.manager.onLoad = () => {
            // Chama a função onLoad (definida em main.js)
            onLoad();
            console.log('Todos os assets foram carregados.');
        };

        this.manager.onError = (url) => {
            console.error(`Erro ao carregar o asset: ${url}`);
        };

        // O TextureLoader é o responsável por carregar as imagens.
        // Passamos o manager para ele.
        this.textureLoader = new THREE.TextureLoader(this.manager);
    }

    /**
     * Carrega uma lista de texturas.
     * @param {Array<Object>} texturesToLoad - Um array de objetos { name, path }
     * @returns {Object} - Um objeto onde as chaves são os nomes (name) e os
     * valores são as texturas (THREE.Texture) carregadas.
     */
    loadTextures(texturesToLoad) {
        const textures = {};
        
        texturesToLoad.forEach(tex => {
            // Carrega a textura
            const texture = this.textureLoader.load(tex.path);
            
            // Configurações de repetição (wrapping) e filtro
            // Essencial para texturas de chão e parede.
            if (tex.repeat) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(tex.repeat[0], tex.repeat[1]);
            }

            // Adiciona ao nosso objeto de texturas
            textures[tex.name] = texture;
        });

        // Retorna o objeto com todas as texturas (que ainda estão carregando,
        // mas o manager vai saber quando terminarem).
        return textures;
    }
}
js/geral/controls.js (NOVO LOCAL)
JavaScript
/*
    ARQUIVO: js/geral/controls.js
    DESCRIÇÃO: Gerenciador de Controles do Jogador (Input Handler).
    FUNÇÃO: Gerencia todo o input (Teclado, Mouse, Toque) e
    a lógica de colisão do jogador em AMBAS as cenas.
    
    COMENTÁRIOS EM: PT-BR
*/

class PlayerControls {

    /**
     * @param {THREE.Camera} camera - A câmera do jogador.
     * @param {HTMLElement} domElement - O elemento canvas (para eventos).
     * @param {Object} settings - Configurações de velocidade e sensibilidade.
     */
    constructor(camera, domElement, settings) {
        this.camera = camera;
        this.domElement = domElement;
        this.settings = settings;

        // Referência à função de interação (definida em main.js)
        this.onInteract = () => {}; 
        
        // Estado de movimento
        this.moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        // Estado da Câmera (Mouse Look)
        this.cameraLook = {
            pitch: 0, // Rotação vertical (X)
            yaw: 0   // Rotação horizontal (Y)
        };
        
        // Propriedades de física/movimento
        this.velocity = new THREE.Vector3();
        this.direction = new THREE.Vector3();

        // Configurações do mundo atual (Cena 1 ou Cena 2)
        this.currentWorld = 1;
        this.collisionLimits = null; // Limites de colisão do mundo atual
        
        // Detecção de Mobile (baseado em 'touchstart')
        this.isMobile = 'ontouchstart' in window;
        
        // Armazena o ID do toque de movimento (para multi-toque)
        this.moveTouchId = null; 
        this.lookTouchId = null;
        this.lastLookPos = { x: 0, y: 0 };
        
        // Ajusta a sensibilidade para mobile (conforme UX finalizado)
        this.sensitivity = this.isMobile ? 
            this.settings.mobileCameraSpeed : 
            this.settings.desktopCameraSpeed;

        // Inicializa os ouvintes de eventos
        this.initListeners();
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO DOS OUVINTES DE EVENTO
    // -----------------------------------------------------------------
    initListeners() {
        if (this.isMobile) {
            // Se for mobile, inicializa os controles de toque
            this.initMobileControls();
        } else {
            // Se for desktop, inicializa o Pointer Lock (travar mouse)
            this.initPointerLock();
            // E os ouvintes de teclado
            document.addEventListener('keydown', this.onKeyDown.bind(this));
            document.addEventListener('keyup', this.onKeyUp.bind(this));
        }
    }

    // (Desktop) Configura o Pointer Lock
    initPointerLock() {
        this.domElement.addEventListener('click', () => {
            this.domElement.requestPointerLock();
        });

        // Ouve o movimento do mouse APENAS quando o mouse está travado
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === this.domElement) {
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
            } else {
                document.removeEventListener('mousemove', this.onMouseMove.bind(this));
            }
        });
    }

    // (Mobile) Configura os botões de toque
    initMobileControls() {
        // Mostra os botões de D-Pad e Ação
        document.getElementById('dpad-container').style.display = 'grid';
        document.getElementById('action-btn').style.display = 'block';

        // Ouvintes do D-Pad (touchstart = pressionar, touchend = soltar)
        this.addTouchListener('dpad-forward', 'forward');
        this.addTouchListener('dpad-backward', 'backward');
        this.addTouchListener('dpad-left', 'left');
        this.addTouchListener('dpad-right', 'right');

        // Ouvinte do Botão de Ação
        document.getElementById('action-btn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.onInteract(); // Chama a função de interação
        });
        
        // Ouvinte de Toque na Tela (para olhar ao redor)
        this.domElement.addEventListener('touchstart', this.onMobileTouchStart.bind(this));
        this.domElement.addEventListener('touchmove', this.onMobileTouchMove.bind(this));
        this.domElement.addEventListener('touchend', this.onMobileTouchEnd.bind(this));
    }

    // (Mobile) Função auxiliar para adicionar ouvintes de toque
    addTouchListener(elementId, direction) {
        const element = document.getElementById(elementId);
        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.moveState[direction] = true;
        });
        element.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.moveState[direction] = false;
        });
    }

    // -----------------------------------------------------------------
    // HANDLERS DE EVENTO (MOVIMENTO / AÇÃO)
    // -----------------------------------------------------------------

    // (Desktop) Tecla pressionada
    onKeyDown(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = true; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = true; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = true; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = true; break;
            case 'KeyE': this.onInteract(); break; // Tecla de Interação [E]
        }
    }

    // (Desktop) Tecla solta
    onKeyUp(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = false; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = false; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = false; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = false; break;
        }
    }

    // (Desktop) Movimento do mouse (Pointer Lock)
    onMouseMove(event) {
        if (document.pointerLockElement !== this.domElement) return;

        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;

        // Rotação Horizontal (Yaw) - Eixo Y
        this.cameraLook.yaw -= movementX * this.sensitivity;
        
        // Rotação Vertical (Pitch) - Eixo X
        this.cameraLook.pitch -= movementY * this.sensitivity;
        
        // Trava a rotação vertical (para não "quebrar o pescoço")
        this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
        
        // Aplica as rotações (Ordem EULER_YXZ é importante para FPS)
        this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
    }

    // (Mobile) Início do toque na tela
    onMobileTouchStart(event) {
        event.preventDefault();
        // Itera sobre os toques
        for (const touch of event.changedTouches) {
            // Se o toque for na metade direita da tela, é para "olhar"
            if (touch.clientX > window.innerWidth / 2 && this.lookTouchId === null) {
                this.lookTouchId = touch.identifier;
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;
            }
        }
    }

    // (Mobile) Movimento do toque na tela (Olhar)
    onMobileTouchMove(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se for o toque que estamos rastreando para "olhar"
            if (touch.identifier === this.lookTouchId) {
                const deltaX = touch.clientX - this.lastLookPos.x;
                const deltaY = touch.clientY - this.lastLookPos.y;

                // Salva a nova posição
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;

                // Aplica a rotação (similar ao onMouseMove)
                this.cameraLook.yaw -= deltaX * this.sensitivity;
                this.cameraLook.pitch -= deltaY * this.sensitivity;
                this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
                
                this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
            }
        }
    }

    // (Mobile) Fim do toque na tela
    onMobileTouchEnd(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se o toque que terminou era o de "olhar", para de rastrear
            if (touch.identifier === this.lookTouchId) {
                this.lookTouchId = null;
            }
        }
    }


    // -----------------------------------------------------------------
    // ATUALIZAÇÃO (LOOP PRINCIPAL) E COLISÃO
    // -----------------------------------------------------------------

    /**
     * Define os limites de colisão do mundo atual.
     * @param {number} worldId - 1 para Floresta, 2 para Corredor.
     * @param {Object} limits - O objeto de limites vindo de 'scene.js'.
     */
    setWorld(worldId, limits) {
        this.currentWorld = worldId;
        this.collisionLimits = limits;
    }
    
    /**
     * Reseta a rotação da câmera (usado na transição).
     */
    resetRotation() {
        this.cameraLook.pitch = 0;
        this.cameraLook.yaw = 0;
        this.camera.rotation.set(0, 0, 0, 'YXZ');
    }

    /**
     * Chamado a cada frame pelo 'main.js'.
     * @param {number} delta - O tempo (em segundos) desde o último frame.
     */
    update(delta) {
        // Velocidade = 1.8 m/s (conforme UX finalizado)
        const moveSpeed = this.settings.movementSpeed * delta;

        // Reseta a direção do movimento
        this.direction.z = Number(this.moveState.forward) - Number(this.moveState.backward);
        this.direction.x = Number(this.moveState.left) - Number(this.moveState.right);
        this.direction.normalize(); // Garante movimento consistente (diagonal != mais rápido)

        // Salva a posição atual para checagem de colisão
        const oldPosition = this.camera.position.clone();

        // Calcula o movimento relativo à direção que a câmera está olhando
        if (this.moveState.forward || this.moveState.backward) {
            this.camera.translateZ(-this.direction.z * moveSpeed);
        }
        if (this.moveState.left || this.moveState.right) {
            this.camera.translateX(-this.direction.x * moveSpeed);
        }

        // --- LÓGICA DE COLISÃO ---
        // Impede o jogador de sair dos limites definidos
        if (this.collisionLimits) {
            this.applyCollisions(oldPosition);
        }
        
        // Mantém a altura do jogador (impede de voar ou afundar)
        this.camera.position.y = this.settings.playerHeight;
    }

    /**
     * Verifica e aplica as colisões baseadas nos limites do mundo.
     * @param {THREE.Vector3} oldPosition - Posição antes do movimento.
     */
    applyCollisions(oldPosition) {
        const newPosition = this.camera.position;
        const limits = this.collisionLimits;

        // Lógica de Colisão simples de "caixa" (para ambos os mundos)
        // Isso nos dá a liberdade de explorar no Mundo 1
        newPosition.x = Math.max(limits.minX, Math.min(limits.maxX, newPosition.x));
        newPosition.z = Math.max(limits.minZ, Math.min(limits.maxZ, newPosition.z));
        
        // Aplica a posição corrigida
        this.camera.position.copy(newPosition);
    }
}
js/geral/interaction.js (NOVO LOCAL)
JavaScript
/*
    ARQUIVO: js/geral/interaction.js
    DESCRIÇÃO: Gerenciador de Interação (Raycaster).
    FUNÇÃO: Esta classe é responsável por "atirar um raio" (Raycast)
    a partir do centro da tela (mira) para detectar com o que
    o jogador está olhando/interagindo em AMBAS as cenas.
    
    COMENTÁRIOS EM: PT-BR
*/

class InteractionHandler {

    /**
     * @param {THREE.Camera} camera - A câmera do jogador (de onde o raio sai).
     * @param {THREE.Scene} scene - A cena (onde os objetos estão).
     * @param {Function} onInteractCallback - Função em 'main.js' a ser chamada
     * quando uma interação válida ocorre.
     */
    constructor(camera, scene, onInteractCallback) {
        this.camera = camera;
        this.scene = scene;
        this.onInteractCallback = onInteractCallback;

        // O Raycaster do Three.js
        this.raycaster = new THREE.Raycaster();
        
        // Coordenadas da mira (sempre [0, 0] = centro da tela)
        this.crosshairCoords = new THREE.Vector2(0, 0);

        // Distância máxima de interação (ex: 3 metros)
        this.interactionDistance = 3.0; 

        // Armazena o objeto que está atualmente na mira
        this.currentTarget = null;
    }

    /**
     * Chamado quando o jogador pressiona [E] ou o Botão de Ação.
     * Esta é a função que efetivamente "dispara" a interação.
     */
    triggerInteraction() {
        // Verifica se há um alvo válido na mira
        if (this.currentTarget) {
            // Chama a função de callback em 'main.js'
            // e passa os dados do objeto (ex: { type: 'gothic_door' })
            this.onInteractCallback(this.currentTarget.userData);
        } else {
            // (Opcional) Tocar um som de "falha" se não houver nada
            console.log("Nenhum alvo interativo ao alcance.");
        }
    }

    /**
     * Chamado a cada frame pelo 'main.js' (ANTES do update de controles).
     * Esta função *apenas* verifica o que está na mira, mas não
     * dispara a ação.
     */
    update() {
        // 1. Atualiza o raio para sair do centro da câmera
        this.raycaster.setFromCamera(this.crosshairCoords, this.camera);

        // 2. Verifica quais objetos na cena (recursivamente) o raio atinge
        // Passamos 'this.scene.children' e 'true' para verificar os filhos
        // dos grupos (World1_Group, World2_Group).
        const intersects = this.raycaster.intersectObjects(this.scene.children, true);

        // Reseta o alvo atual
        this.currentTarget = null;

        // 3. Itera sobre os objetos atingidos
        for (const intersect of intersects) {
            
            // 4. Verifica se o objeto tem o 'userData' interativo
            // (Nós definimos isso em 'CenaFloresta.js' e 'CenaCorredor.js')
            if (intersect.object.userData && intersect.object.userData.interactive === true) {
                
                // 5. Verifica se está dentro da distância permitida
                if (intersect.distance <= this.interactionDistance) {
                    
                    // Encontramos um alvo válido!
                    this.currentTarget = intersect.object;
                    
                    // (Opcional) Mudar a cor da mira para "ativa"
                    // document.getElementById('crosshair').style.color = 'red';
                    
                    // Para o loop assim que encontrar o primeiro alvo válido
                    break;
                }
            }
        }
        
        // Se o loop terminou e this.currentTarget ainda é nulo,
        // significa que não estamos olhando para nada interativo.
        if (this.currentTarget === null) {
            // (Opcional) Resetar a cor da mira para "passiva"
            // document.getElementById('crosshair').style.color = 'rgba(255, 255, 255, 0.7)';
        }
    }
}
js/geral/main.js (NOVO LOCAL E REATORADO)
(Este é o "Maestro". Ele agora importa e usa os construtores de cena separados)

JavaScript
/*
    ARQUIVO: js/geral/main.js
    DESCRIÇÃO: Ponto de Entrada Principal da Aplicação (O "Maestro").
    FUNÇÃO: Este script inicializa todos os componentes (Cena, Câmera,
    Renderizador, Controles) e gerencia o "Game Loop" (o 'animate').
    Ele coordena o carregamento de assets (JSON e texturas), 
    a transição de cenas e conecta os controles à lógica de interação.
    
    COMENTÁRIOS EM: PT-BR
*/

// Classe principal da aplicação
class SungApp {
    
    constructor() {
        // Elementos do DOM
        this.canvas = document.getElementById('game-canvas');
        this.loadingScreen = document.getElementById('loading-screen');
        this.loadingText = document.querySelector('.loading-text');
        this.transitionFade = document.getElementById('transition-fade');
        this.uiElements = [
            document.getElementById('crosshair'),
            document.getElementById('logo'),
            document.getElementById('copyright')
        ];

        // Componentes do Three.js
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true // Suavização de serrilhado
        });
        this.clock = new THREE.Clock(); // Relógio para o 'delta time'

        // Componentes do Jogo
        this.loader = null;
        this.controls = null;
        this.interaction = null;
        
        // *** NOVO: Construtores de Cena Separados ***
        this.forestBuilder = null;   // (Virá de CenaFloresta.js)
        this.corridorBuilder = null; // (Virá de CenaCorredor.js)
        
        // Dados (carregados do JSON)
        this.artworkData = [];

        // Grupos de Cena (para fácil adição/remoção)
        this.world1_Group = null;
        this.world2_Group = null;

        // Estado do Jogo
        this.isLoaded = false;
        this.isTransitioning = false;
        this.currentWorldId = 1; // Começa no Mundo 1
        
        // Configurações (conforme UX finalizado)
        this.settings = {
            movementSpeed: 1.8,         // 1.8 m/s
            desktopCameraSpeed: 0.0008, // Sensibilidade Desktop
            mobileCameraSpeed: 0.0025,  // Sensibilidade Mobile
            playerHeight: 1.6           // Altura dos olhos do jogador
        };
        
        // Referência 'bind' para o loop de animação
        this.animate = this.animate.bind(this);
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Método principal de inicialização (agora é assíncrono).
     */
    async init() {
        console.log("Iniciando SungApp...");

        try {
            // 1. Carregar os dados das artes primeiro (de data/arts.json)
            await this.loadArtworkData();
            console.log("Dados de arte (arts.json) carregados.");

            // 2. Configurar o Renderizador
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            this.renderer.outputEncoding = THREE.sRGBEncoding;

            // 3. Configurar a Posição Inicial da Câmera
            // (Na borda do mapa, na rodovia, em Z=90)
            this.camera.position.set(0, this.settings.playerHeight, 90);

            // 4. Inicializar o Loader de Assets (Texturas)
            this.loader = new AssetLoader(
                (progress) => {
                    // Função 'onProgress'
                    this.loadingText.textContent = `Carregando... ${progress.toFixed(0)}%`;
                },
                () => {
                    // Função 'onLoad' (Tudo carregado)
                    this.startExperience();
                }
            );

            // 5. Definir quais texturas carregar
            // (Caminhos para 'assets/', sem 'images/')
            const sceneTextures = [
                // Texturas da Floresta
                { name: 'rodovia', path: 'assets/rodovia_texture.jpg', repeat: [3, 10] },
                { name: 'porta', path: 'assets/porta.png' }, 
                { name: 'path', path: 'assets/path_texture.jpg', repeat: [2, 12] },
                { name: 'arvore', path: 'assets/arvore.png' },
                { name: 'crystalGlow', path: 'assets/crystal_glow.png' },
                { name: 'rock', path: 'assets/rock.png' },
                { name: 'forest_floor', path: 'assets/forest_floor.jpg', repeat: [50, 50] },
                
                // Texturas do Corredor
                { name: 'wall', path: 'assets/wall_texture.jpg', repeat: [20, 2] },
                { name: 'floor', path: 'assets/floor_texture.jpg', repeat: [2, 20] }
            ];
            
            // Adiciona as 18 artes (carregadas do JSON) à lista de carregamento
            const artworkTextures = this.artworkData.map(art => ({
                name: `art_${art.id}`, // ex: 'art_1'
                path: art.image // ex: 'img/tattoo_01.png'
            }));
            
            // Carrega TUDO
            const allTexturesToLoad = [...sceneTextures, ...artworkTextures];
            const loadedTextures = this.loader.loadTextures(allTexturesToLoad);
            
            // 6. Inicializar os "Construtores" de Mundo com as texturas
            // (Usa as classes importadas de /floresta/ e /corredor/)
            this.forestBuilder = new ForestSceneBuilder(loadedTextures);
            this.corridorBuilder = new CorridorSceneBuilder(loadedTextures);

            // 7. Ouvinte de redimensionamento da janela
            window.addEventListener('resize', this.onWindowResize.bind(this));
        
        } catch (error) {
            console.error("Falha fatal na inicialização:", error);
            this.loadingText.textContent = "Erro ao carregar. Verifique o console.";
            this.loadingText.style.color = "red";
        }
    }
    
    /**
     * Carrega os dados do arquivo /data/arts.json
     * (Precisa de um servidor local - ver como_rodar.txt)
     */
    async loadArtworkData() {
        try {
            // Usa 'fetch' para buscar o arquivo JSON
            const response = await fetch('data/arts.json');
            if (!response.ok) {
                // Se o arquivo não for encontrado (404) ou der erro, falha
                throw new Error(`Erro HTTP! Status: ${response.status}`);
            }
            this.artworkData = await response.json();
            
            // Validação
            if (this.artworkData.length !== 18) {
                console.warn(`Aviso: 'arts.json' contém ${this.artworkData.length} artes. O corredor foi projetado para 18.`);
            }
            
        } catch (error) {
            console.error("Não foi possível carregar 'data/arts.json':", error);
            // Re-lança o erro para o 'init' principal tratar
            throw error; 
        }
    }

    /**
     * Chamado quando o Loader termina (onLoad).
     */
    startExperience() {
        console.log("Assets carregados. Iniciando a experiência.");
        this.isLoaded = true;
        
        // 1. Construir o Mundo 1 (Floresta)
        // Usa o construtor da floresta
        const world1Data = this.forestBuilder.createWorld1(this.scene);
        this.world1_Group = world1Data.group;
        this.scene.add(this.world1_Group);

        // 2. Inicializar Controles
        this.controls = new PlayerControls(this.camera, this.canvas, this.settings);
        // Define os limites de colisão para o mundo 1
        this.controls.setWorld(1, world1Data.collisionLimits);
        
        // 3. Inicializar Interação
        this.interaction = new InteractionHandler(
            this.camera, 
            this.scene, 
            this.handleInteraction.bind(this) // Callback
        );
        
        // 4. Conectar Controles e Interação
        // Diz ao 'controls' qual função chamar quando [E] é pressionado
        this.controls.onInteract = () => {
            this.interaction.triggerInteraction();
        };

        // 5. Esconder a tela de Loading e mostrar a UI do Jogo
        this.loadingScreen.style.opacity = '0';
        setTimeout(() => {
            this.loadingScreen.style.display = 'none';
        }, 500); // 0.5s (duração da transição do CSS)

        // Mostra a UI (Mira, Logo, etc.)
        this.uiElements.forEach(el => el.style.display = 'block');
        
        // 6. Iniciar o Loop de Animação
        this.animate();
    }
    
    // -----------------------------------------------------------------
    // LOOP DE ANIMAÇÃO (GAME LOOP)
    // -----------------------------------------------------------------

    /**
     * O Loop Principal (requestAnimationFrame).
     */
    animate() {
        // Pede ao navegador para chamar 'animate' no próximo frame
        requestAnimationFrame(this.animate);

        // Se não carregou ou está em transição, não faz nada
        if (!this.isLoaded || this.isTransitioning) {
            return;
        }

        // Pega o tempo delta (diferença do último frame)
        const delta = this.clock.getDelta();

        // 1. Atualiza o handler de interação (verifica o que está na mira)
        this.interaction.update();
        
        // 2. Atualiza os controles do jogador (movimento, colisão)
        this.controls.update(delta);

        // 3. Renderiza a cena 3D
        this.renderer.render(this.scene, this.camera);
    }
    
    // -----------------------------------------------------------------
    // LÓGICA DE TRANSIÇÃO E INTERAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Callback chamado pelo 'InteractionHandler' quando [E] é pressionado
     * em um alvo válido.
     * @param {Object} userData - Os dados do objeto (ex: { type: 'gothic_door' })
     */
    handleInteraction(userData) {
        console.log("Interação disparada:", userData);
        
        // Verifica se é a porta gótica E se estamos no mundo 1
        if (userData.type === 'gothic_door' && this.currentWorldId === 1) {
            this.triggerSceneTransition();
        }
        
        // Lógica para mostrar info da arte no Mundo 2
        if (userData.type === 'artwork' && this.currentWorldId === 2) {
            console.log(`Clicou na Arte: ${userData.title}`);
            // (Ação Futura): Abrir um modal com `userData.title` e `userData.description`
            alert(`Arte: ${userData.title}\nDescrição: ${userData.description}`);
        }
    }

    /**
     * Executa o "Theater Effect" (Transição da Cena 1 para a Cena 2).
     */
    triggerSceneTransition() {
        if (this.isTransitioning) return; // Previne transições duplas
        
        console.log("Iniciando transição de cena...");
        this.isTransitioning = true; // Pausa o 'animate' loop

        // 1. Fade In Rápido (0.5s) para Branco
        this.transitionFade.style.transition = 'opacity 0.5s ease-in';
        this.transitionFade.style.opacity = '1';

        // 2. Atraso de 500ms (enquanto a tela está branca)
        setTimeout(() => {
            // --- O TELEPORTE (acontece instantaneamente) ---
            
            // a. Remove a geometria do Mundo 1
            this.scene.remove(this.world1_Group);
            
            // b. Constrói e adiciona a geometria do Mundo 2
            // *** USA O CONSTRUTOR DO CORREDOR ***
            const world2Data = this.corridorBuilder.createWorld2(this.scene, this.artworkData);
            this.world2_Group = world2Data.group;
            this.scene.add(this.world2_Group);

            // c. Teleporta o Jogador (Z=10, conforme requisito)
            this.camera.position.set(0, this.settings.playerHeight, 10);
            
            // d. Reseta a Rotação da Câmera (olhar reto)
            this.controls.resetRotation();

            // e. Atualiza os controles para os limites de colisão do Mundo 2
            this.controls.setWorld(2, world2Data.collisionLimits);
            this.currentWorldId = 2;
            
            // --- FIM DO TELEPORTE ---

            // 3. Fade Out Lento (1.5s) do Branco (olhos se ajustando)
            this.transitionFade.style.transition = 'opacity 1.5s ease-out';
            this.transitionFade.style.opacity = '0';
            
            // 4. Atraso de 1500ms (espera o fade out terminar)
            setTimeout(() => {
                this.isTransitioning = false; // Retoma o 'animate' loop
                console.log("Transição completa. Mundo 2 carregado.");
            }, 1500);

        }, 500); // Fim do setTimeout do Fade In
    }

    // -----------------------------------------------------------------
    // UTILITÁRIOS
    // -----------------------------------------------------------------

    /**
     * Chamado quando a janela do navegador muda de tamanho.
     */
    onWindowResize() {
        // Atualiza as proporções da câmera
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();

        // Atualiza o tamanho do renderizador
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}

// -----------------------------------------------------------------
// PONTO DE ENTRADA
// -----------------------------------------------------------------

// Quando o DOM (HTML) estiver pronto, cria e inicializa a aplicação.
window.addEventListener('DOMContentLoaded', () => {
    // Lembrete sobre o servidor local (para o 'fetch' funcionar)
    if (window.location.protocol === 'file:') {
        console.error("ERRO: O projeto não pode ser executado localmente via 'file://'. Use um servidor local (veja como_rodar.txt).");
        document.body.innerHTML = '<div style="color: red; font-size: 20px; padding: 20px;">ERRO: O projeto não pode ser executado localmente. Por favor, use um servidor (veja o arquivo como_rodar.txt).</div>';
        return;
    }
    
    const app = new SungApp();
    app.init();
});
js/floresta/CenaFloresta.js (NOVO ARQUIVO)
(Este é o antigo createWorld1 em seu próprio arquivo)

JavaScript
/*
    ARQUIVO: js/floresta/CenaFloresta.js
    DESCRIÇÃO: Construtor de Cenário 3D - MUNDO 1 (FLORESTA).
    FUNÇÃO: Esta classe é uma "fábrica" de geometria. Ela contém
    apenas o método `createWorld1` para construir a cena da floresta.
    
    COMENTÁRIOS EM: PT-BR
*/

class ForestSceneBuilder {

    constructor(textures) {
        // Armazena as texturas que o 'loader.js' carregou.
        this.textures = textures;
        // Altura padrão da câmera (nível dos olhos)
        this.playerHeight = 1.6;
    }

    // -----------------------------------------------------------------
    // CENA 1: A DESCOBERTA (MUNDO ABERTO / FLORESTA)
    // -----------------------------------------------------------------
    createWorld1(scene) {
        const world1Group = new THREE.Group();
        world1Group.name = "World1_Group"; // Nome para depuração

        // 1. Configuração do Clima (Névoa e Luz)
        // Cor cinza-azulado escuro, inspirada em 'clima.png' (Sleepy Hollow)
        const fogColor = 0x2c3e50; 
        scene.background = new THREE.Color(fogColor);
        // A névoa começa perto e fica densa rapidamente
        scene.fog = new THREE.Fog(fogColor, 1, 40); // Névoa densa

        // Luz ambiente fraca, para dar o tom sombrio
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // (cor, intensidade)
        world1Group.add(ambientLight);

        // Luz direcional (simulando lua/crepúsculo)
        const directionalLight = new THREE.DirectionalLight(0x505a70, 0.4);
        directionalLight.position.set(5, 10, 5);
        world1Group.add(directionalLight);

        
        // 2. Geometria do Chão (Mundo Aberto)
        
        // Chão da Floresta (Ground082S) - O MAPA INTEIRO
        const forestFloorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.forest_floor });
        const forestFloorGeometry = new THREE.PlaneGeometry(200, 200); // 200m x 200m
        const forestFloor = new THREE.Mesh(forestFloorGeometry, forestFloorMaterial);
        forestFloor.rotation.x = -Math.PI / 2;
        forestFloor.position.set(0, 0, 0); // Centralizado na origem
        world1Group.add(forestFloor);

        // Rodovia (Asphalt033) - PONTO DE INÍCIO
        const roadMaterial = new THREE.MeshBasicMaterial({ map: this.textures.rodovia });
        const roadGeometry = new THREE.PlaneGeometry(15, 60); // (largura, comprimento)
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; 
        road.position.set(0, 0.01, 70); // Na borda do mapa (Z=70 a Z=100)
        world1Group.add(road);

        // Trilha de Tijolos ESCONDIDA (Bricks075B)
        const pathMaterial = new THREE.MeshBasicMaterial({ map: this.textures.path });
        const pathGeometry = new THREE.PlaneGeometry(3, 40); // Trilha estreita (3m x 40m)
        const path = new THREE.Mesh(pathGeometry, pathMaterial);
        path.rotation.x = -Math.PI / 2;
        // Posição escondida dentro da floresta
        path.position.set(30, 0.01, -20); // Escondida em X=30, Z=-20
        world1Group.add(path);


        // 3. Floresta Densa (Billboards de Árvores)
        // Material da árvore (usa 'arvore.png')
        const treeMaterial = new THREE.SpriteMaterial({ 
            map: this.textures.tree,
            fog: true,
            color: 0xcccccc 
        });
        
        // Material do brilho do cristal
        const crystalMaterial = new THREE.SpriteMaterial({
            map: this.textures.crystalGlow,
            blending: THREE.AdditiveBlending, // Efeito de brilho
            fog: false, // Cristais brilham através da névoa
            transparent: true,
            opacity: 0.8
        });

        // Material da Rocha
        const rockMaterial = new THREE.SpriteMaterial({
            map: this.textures.rock,
            fog: true,
            color: 0xbbbbbb 
        });

        // Cria 2000 árvores para densidade
        for (let i = 0; i < 2000; i++) {
            const sprite = new THREE.Sprite(treeMaterial);
            
            const x = (Math.random() - 0.5) * 200; // X de -100 a 100
            const z = (Math.random() - 0.5) * 200; // Z de -100 a 100

            // *** LÓGICA PARA NÃO NASCER ÁRVORE NA ESTRADA OU NA TRILHA ***
            // Checa área da estrada (X -7.5 a 7.5, Z 40 a 100)
            if (x > -7.5 && x < 7.5 && z > 40 && z < 100) {
                continue; // Pula esta árvore
            }
            // Checa área da trilha (X 28.5 a 31.5, Z -40 a 0)
            if (x > 28.5 && x < 31.5 && z > -40 && z < 0) {
                continue; // Pula esta árvore
            }

            // Tamanho aleatório (árvores grandes e médias)
            const scale = Math.random() * 3 + 4; // Escala entre 4m e 7m
            sprite.scale.set(scale, scale, 1);
            sprite.position.set(x, scale / 2, z); // (x, altura, z)
            world1Group.add(sprite);
        }

        // Adiciona Rochas (100)
        for (let i = 0; i < 100; i++) {
            const rockSprite = new THREE.Sprite(rockMaterial);
            const x = (Math.random() - 0.5) * 200; 
            const z = (Math.random() - 0.5) * 200;
            
            // Checa área da estrada
            if (x > -7.5 && x < 7.5 && z > 40 && z < 100) continue; 
            // Checa área da trilha
            if (x > 28.5 && x < 31.5 && z > -40 && z < 0) continue; 

            const scale = Math.random() * 0.5 + 0.5; // Rochas pequenas (0.5m a 1m)
            rockSprite.scale.set(scale, scale, 1);
            rockSprite.position.set(x, scale / 2, z); // No chão
            world1Group.add(rockSprite);
        }

        // 4. A Pista de Cristais (As "Migalhas de Pão")
        // Coloca cristais guiando da estrada (0, 60) até a trilha (30, 0)
        const crystalPath = [
            {x: 5, z: 60},
            {x: 10, z: 55},
            {x: 15, z: 50},
            {x: 20, z: 40},
            {x: 25, z: 30},
            {x: 30, z: 20},
            {x: 30, z: 10},
            {x: 30, z: 0}, // Chegou na trilha
            {x: 30, z: -10},
            {x: 30, z: -20},
            {x: 30, z: -30} // Perto da porta
        ];

        crystalPath.forEach(pos => {
            // Luz Pontual (azulada)
            const light = new THREE.PointLight(0xadd8e6, 1.5, 8); // (cor, intensidade, distância)
            light.position.set(pos.x, 1.5, pos.z); // Posição
            world1Group.add(light);
            
            // Sprite visual do cristal
            const crystalSprite = new THREE.Sprite(crystalMaterial);
            crystalSprite.position.copy(light.position);
            crystalSprite.scale.set(1.5, 2.5, 1); 
            world1Group.add(crystalSprite);
        });


        // 5. A Porta Gótica (Objetivo)
        // Simula a "rocha" onde a porta está
        const rockFaceMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 }); 
        const rockFaceGeometry = new THREE.PlaneGeometry(8, 8); // Parede de rocha
        const rockFace = new THREE.Mesh(rockFaceGeometry, rockFaceMaterial);
        // Posicionada no final da trilha escondida
        rockFace.position.set(30, 4, -40.5); // (x, altura, z)
        world1Group.add(rockFace);
        
        // A porta em si
        const doorMaterial = new THREE.MeshBasicMaterial({ 
            map: this.textures.porta,
            transparent: true 
        });
        const doorGeometry = new THREE.PlaneGeometry(4, 5); // Tamanho da porta
        const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
        
        // Posiciona no final da trilha, em frente à rocha
        doorMesh.position.set(30, 2.5, -40); // (x, altura, z)
        
        // Adiciona o 'userData' para interação
        doorMesh.userData = { 
            interactive: true, 
            type: 'gothic_door' 
        };
        world1Group.add(doorMesh);


        // 6. Limites de Colisão (Mundo Aberto)
        // Agora, os limites são apenas as bordas do mapa (chão da floresta)
        const worldLimits = {
            minX: -98, // 2m de margem
            maxX: 98,
            minZ: -98,
            maxZ: 98
        };

        // Retorna o grupo de objetos e os limites de colisão
        return { group: world1Group, collisionLimits: worldLimits };
    }
}
js/corredor/CenaCorredor.js (NOVO ARQUIVO)
(Este é o antigo createWorld2 em seu próprio arquivo)

JavaScript
/*
    ARQUIVO: js/corredor/CenaCorredor.js
    DESCRIÇÃO: Construtor de Cenário 3D - MUNDO 2 (CORREDOR).
    FUNÇÃO: Esta classe é uma "fábrica" de geometria. Ela contém
    apenas o método `createWorld2` para construir a cena da galeria.
    
    COMENTÁRIOS EM: PT-BR
*/

class CorridorSceneBuilder {

    constructor(textures) {
        // Armazena as texturas que o 'loader.js' carregou.
        this.textures = textures;
        // Altura padrão da câmera (nível dos olhos)
        this.playerHeight = 1.6;
    }

    // -----------------------------------------------------------------
    // CENA 2: A GALERIA (CORREDOR)
    // -----------------------------------------------------------------
    createWorld2(scene, artworkData) { // Recebe os dados do JSON
        const world2Group = new THREE.Group();
        world2Group.name = "World2_Group";

        // 1. Limpa a Névoa e Luz da Cena 1
        scene.fog = null; // Remove a névoa
        scene.background = new THREE.Color(0x000000); // Fundo preto

        // Luz ambiente muito escura (soturna)
        const ambientLight = new THREE.AmbientLight(0x101010, 1.0); // (cor, intensidade)
        world2Group.add(ambientLight);

        // Luz "falsa" no teto (HemisphereLight)
        const hemiLight = new THREE.HemisphereLight(0x404040, 0x080808, 0.5);
        world2Group.add(hemiLight);

        // 2. Geometria do Corredor
        const corridorLength = 80;
        const corridorWidth = 5;
        const corridorHeight = 4;

        // Chão (Usa 'floor_texture.jpg')
        const floorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.floor });
        const floorGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, 0, corridorLength / 2); 
        world2Group.add(floor);

        // Teto
        const ceilMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 }); // Teto escuro
        const ceilGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
        const ceil = new THREE.Mesh(ceilGeometry, ceilMaterial);
        ceil.rotation.x = Math.PI / 2;
        ceil.position.set(0, corridorHeight, corridorLength / 2);
        world2Group.add(ceil);

        // Parede Esquerda (Usa 'wall_texture.jpg')
        const wallMaterial = new THREE.MeshBasicMaterial({ map: this.textures.wall });
        const wallGeometry = new THREE.PlaneGeometry(corridorLength, corridorHeight);
        const wallLeft = new THREE.Mesh(wallGeometry, wallMaterial);
        wallLeft.rotation.y = Math.PI / 2;
        wallLeft.position.set(-corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallLeft);

        // Parede Direita (Usa 'wall_texture.jpg')
        const wallRight = new THREE.Mesh(wallGeometry, wallMaterial);
        wallRight.rotation.y = -Math.PI / 2;
        wallRight.position.set(corridorWidth / 2, corridorHeight / 2, corridorLength / 2);
        world2Group.add(wallRight);

        // Parede do Fundo (Fechando o corredor)
        const endWallGeom = new THREE.PlaneGeometry(corridorWidth, corridorHeight);
        const endWall = new THREE.Mesh(endWallGeom, wallMaterial);
        endWall.position.set(0, corridorHeight / 2, corridorLength);
        world2Group.add(endWall);

        // 3. Criação das Obras de Arte (Quadros)
        const spacing = corridorLength / 9;
        const frameSize = 2.0; 
        const frameHeight = this.playerHeight + 0.2; 

        // Itera sobre os dados do JSON (artworkData)
        artworkData.forEach((artwork, index) => {
            const artTexture = this.textures[`art_${artwork.id}`];
            // Checagem de segurança caso a textura da arte falhe
            if (!artTexture) {
                console.error(`Textura da arte não encontrada: art_${artwork.id}`);
                return; // Pula esta arte
            }
            
            const artMaterial = new THREE.MeshBasicMaterial({ map: artTexture });

            const artGeometry = new THREE.PlaneGeometry(frameSize, frameSize);
            const artMesh = new THREE.Mesh(artGeometry, artMaterial);
            
            // Placa de interação (hitbox)
            const plaqueGeometry = new THREE.PlaneGeometry(frameSize + 1, frameSize + 1);
            const plaqueMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const plaqueMesh = new THREE.Mesh(plaqueGeometry, plaqueMaterial);
            
            plaqueMesh.userData = {
                interactive: true,
                type: 'artwork',
                id: artwork.id,
                title: artwork.title,
                description: artwork.description
            };

            const zPos = 10 + (index % 9) * (spacing * 0.9);

            if (index < 9) {
                // Lado Esquerdo
                artMesh.position.set((-corridorWidth / 2) + 0.05, frameHeight, zPos);
                artMesh.rotation.y = Math.PI / 2; 
                plaqueMesh.position.set((-corridorWidth / 2) + 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = Math.PI / 2;
            } else {
                // Lado Direito
                artMesh.position.set((corridorWidth / 2) - 0.05, frameHeight, zPos);
                artMesh.rotation.y = -Math.PI / 2; 
                plaqueMesh.position.set((corridorWidth / 2) - 0.1, frameHeight, zPos);
                plaqueMesh.rotation.y = -Math.PI / 2;
            }
            world2Group.add(artMesh);
            world2Group.add(plaqueMesh); 
        });

        // 4. Limites de Colisão (Corredor)
        const collisionLimits = {
            minX: -corridorWidth / 2 + 0.5, 
            maxX: corridorWidth / 2 - 0.5,
            minZ: 0.5, 
            maxZ: corridorLength - 0.5 
        };
        
        // Retorna o grupo e os limites
        return { group: world2Group, collisionLimits: collisionLimits };
    }
}
ta vc triou a parte da 2 e 3 cena (clarao e corredor )?

Não, eu NÃO tirei.

No código que eu acabei de te mandar (o refatorado com as novas pastas), eu coloquei de volta as duas cenas, mas agora elas estão organizadas:

A "Clareira" (Floresta): Está no arquivo js/floresta/CenaFloresta.js

O "Corredor" (Galeria): Está no arquivo js/corredor/CenaCorredor.js

Eu fiz isso porque você disse "vamos refazer todo o codigo", então eu entendi que você queria o projeto inteiro (com as duas partes) na nova estrutura de pastas.

A minha pergunta para você é: Você quer que eu mantenha assim (Floresta + Corredor) ou você quer que eu remova o corredor de novo, deixando só a floresta?

nao nao vamos focar em fazer so a clareira e a cena continua quando a pessoa interage com a porta

e olhando aq os direitos autorai sao da D'Artagnan ai studios feito pela equipe sung

Entendido. Foco total na floresta.

Este é o melhor plano. Simplifica tudo e nos permite polir a primeira cena (a "demo do jogo") perfeitamente.

O que vamos fazer:

Remover todo o código do "Corredor" (a pasta js/corredor/, o data/arts.json, a pasta img/).

Modificar o js/geral/main.js para que ele carregue apenas a floresta.

Adicionar a lógica de "Continua..." quando o jogador interagir com a porta.

Atualizar o copyright em index.html para o novo texto.

Aqui está o código completo, do zero, com esta nova estrutura focada.

Nova Estrutura de Pastas (Focada na Floresta)
/
│
├── index.html               (HTML Principal)
├── README.md                (Atualizado)
├── COMO_EDITAR.txt          (Atualizado)
├── como_rodar.txt           (Sem mudanças)
├── checklist.txt            (Atualizado)
│
├── assets/
│   ├── (COLOQUE AS TEXTURAS DA FLORESTA AQUI)
│   │   ├── belial.png, rodovia_texture.jpg, porta.png, arvore.png, ...
│   └── audio/
│
├── CSS/
│   └── styles.css
│
├── js/
│   ├── geral/
│   │   ├── main.js          (O "Maestro" - MODIFICADO)
│   │   ├── controls.js      (Sem mudanças)
│   │   ├── interaction.js   (Sem mudanças)
│   │   └── loader.js        (Sem mudanças)
│   │
│   └── floresta/
│       └── CenaFloresta.js  (Sem mudanças)
│
│
└── (PASTAS data/, img/ e js/corredor/ FORAM REMOVIDAS)
index.html (ATUALIZADO)
(Título, copyright e scripts foram atualizados. Adicionei a mensagem "CONTINUA...")

HTML
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sung Studios - A Caçada</title> <link rel="stylesheet" href="CSS/styles.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-text">Carregando...</div>
    </div>

    <div id="rotate-message">
        <p>Por favor, gire seu dispositivo para a posição horizontal (paisagem) para iniciar a experiência.</p>
    </div>

    <div id="transition-fade">
        <div id="game-end-message">CONTINUA...</div>
    </div>

    <div id="crosshair">+</div>

    <div id="dpad-container">
        <button id="dpad-forward" class="dpad-btn">▲</button>
        <button id="dpad-backward" class="dpad-btn">▼</button>
        <button id="dpad-left" class="dpad-btn">◄</button>
        <button id="dpad-right" class="dpad-btn">►</button>
    </div>

    <button id="action-btn">E</button>

    <div id="logo">
        <img src="assets/belial.png" alt="Sung Studios Logo">
    </div>
    
    <div id="copyright">© 2025 D'Artagnan AI Studios - Feito pela Equipe Sung</div>

    <canvas id="game-canvas"></canvas>

    <script src="js/geral/loader.js"></script>
    <script src="js/geral/controls.js"></script>
    <script src="js/geral/interaction.js"></script>
    
    <script src="js/floresta/CenaFloresta.js"></script>
    
    <script src="js/geral/main.js"></script>

</body>
</html>
README.md (ATUALIZADO)
(Simplificado para focar apenas na floresta)

Markdown
# Sung Studios - A Caçada (Demo da Floresta)

Este é o repositório do projeto para a demo interativa 3D "A Caçada", um jogo de exploração com tema de horror cinematográfico.

## Visão Geral

O projeto é uma experiência narrativa em primeira pessoa. O jogador é colocado em uma floresta escura e aberta (200x200m) e deve explorar para encontrar seu objetivo.

O jogador começa em uma rodovia abandonada na borda da floresta e deve seguir uma trilha de cristais luminosos para encontrar uma trilha de tijolos escondida, que o levará ao objetivo final: uma porta gótica misteriosa.

Ao interagir com a porta, a demo termina com a mensagem "Continua...".

## Stack Técnica

* **HTML5**
* **CSS3**
* **JavaScript (ES6+)**
* **Three.js** (incluído via CDN)

## Estrutura de Arquivos (Simplificada)

/ │ ├── index.html ├── README.md ├── COMO_EDITAR.txt ├── como_rodar.txt ├── checklist.txt │ ├── assets/ │ ├── (COLOQUE AS TEXTURAS DA FLORESTA AQUI) │ │ ├── belial.png, rodovia_texture.jpg, porta.png, ... │ └── audio/ │ ├── CSS/ │ └── styles.css │ └── js/ ├── geral/ │ ├── main.js │ ├── controls.js │ ├── interaction.js │ └── loader.js │ └── floresta/ └── CenaFloresta.js


## Como Rodar

Consulte `como_rodar.txt` para instruções sobre como iniciar um servidor local (é **obrigatório**).

---
© 2025 D'Artagnan AI Studios - Feito pela Equipe Sung
checklist.txt (ATUALIZADO)
(Removemos as texturas do corredor wall_texture e floor_texture)

Plaintext
=================================================
CHECKLIST DE ASSETS DO PROJETO (PT-BR)
=================================================

Verifique se todos os assets (arquivos de mídia) necessários estão nas pastas corretas antes de testar o projeto. O CÓDIGO NÃO FUNCIONARÁ SEM ELES.

### 1. Imagens de Cenário (Obrigatórias)
### >> COLOQUE TODOS ESTES ARQUIVOS DENTRO DA PASTA: /assets/

[ ] belial.png             (Logo "Sung" que aparece no canto)
[ ] rodovia_texture.jpg    (Textura de asfalto molhado)
[ ] porta.png              (Textura da porta gótica - IMAGEM QUE VOCÊ FORNECEU)
[ ] arvore.png             (Imagem da árvore com fundo transparente para a floresta)
[ ] path_texture.jpg       (Textura de tijolos escuros para a trilha)
[ ] forest_floor.jpg       (Textura de terra molhada para a floresta)
[ ] crystal_glow.png       (Textura de brilho para os cristais)
[ ] rock.png               (Imagem de rocha com fundo transparente)


### 2. Áudio (Opcional)
Local: /assets/audio/
(Vazio por enquanto)
COMO_EDITAR.txt (ATUALIZADO)
(Simplificado, sem menção à galeria)

Plaintext
=================================================
GUIA DE MANUTENÇÃO - SUNG STUDIOS (PT-BR)
=================================================

Este arquivo explica como atualizar o conteúdo do site 3D sem precisar mexer no código principal.

-------------------------------------------------
1. COMO MUDAR AS TEXTURAS DO CENÁRIO
-------------------------------------------------

Toda a aparência da floresta depende dos arquivos de imagem na pasta /assets/.

PASTA DE TEXTURAS: /assets/

* `rodovia_texture.jpg`: A textura do asfalto da estrada.
* `porta.png`: A textura da porta gótica.
* `belial.png`: O logo no canto da tela.
* `arvore.png`: A imagem da árvore usada na floresta (billboard).
* `path_texture.jpg`: A textura dos tijolos da trilha escondida.
* `forest_floor.jpg`: A textura de terra molhada da floresta.
* `crystal_glow.png`: O brilho do cristal.
* `rock.png`: A rocha na floresta.

Basta substituir o arquivo de imagem nesta pasta pelo seu novo arquivo, MANTENDO O MESMO NOME E EXTENSÃO.
como_rodar.txt
(Sem alterações. Coloque este arquivo na raiz do projeto)

Plaintext
=================================================
COMO RODAR O PROJETO (PT-BR)
=================================================

Este projeto **NÃO FUNCIONA** se você apenas abrir o arquivo `index.html` diretamente no navegador (ex: `file:///C:/.../index.html`).

Isso acontece por causa das políticas de segurança (CORS) dos navegadores, que bloqueiam o carregamento de texturas e arquivos de dados (como o `arts.json`) dessa maneira.

Você **PRECISA** de um servidor local.

-------------------------------------------------
COMO RODAR (MÉTODO FÁCIL - VS CODE)
-------------------------------------------------

1.  Abra a pasta do projeto no Visual Studio Code (VS Code).
2.  Vá até a aba "Extensions" (Extensões) na barra lateral.
3.  Procure por "Live Server" (feito por Ritwick Dey).
4.  Instale a extensão.
5.  Depois de instalado, volte para a lista de arquivos.
6.  Clique com o botão direito no arquivo `index.html`.
7.  Selecione "Open with Live Server" (Abrir com Live Server).

Isso iniciará um servidor local (ex: `http://127.0.0.1:5500`) e o projeto funcionará.
CSS/styles.css (ATUALIZADO)
(Adicionei a mensagem #game-end-message no final)

CSS
/*
    ARQUIVO: CSS/styles.css
    DESCRIÇÃO: Folha de Estilos Principal.
    FUNÇÃO: Define todos os estilos visuais da aplicação.
    
    COMENTÁRIOS EM: PT-BR
*/

/* 1. CONFIGURAÇÃO GLOBAL E FONTES */
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400&display=swap');

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden; 
    background-color: #000000;
    color: #ffffff;
    font-family: 'Inter', sans-serif;
}

/* 2. ELEMENTOS 3D E OVERLAYS */
#game-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; 
    cursor: pointer; 
}

#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000000;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 200; 
    transition: opacity 0.5s ease-out;
}

.loading-text {
    font-family: 'Cinzel', serif;
    font-size: 1.5rem;
    color: #ffffff;
}

/* Tela de Transição (Usada para o Fim de Jogo) */
#transition-fade {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #ffffff; /* Fundo branco do fade */
    opacity: 0;
    pointer-events: none; 
    z-index: 150; 
    display: flex;
    justify-content: center;
    align-items: center;
}

/* NOVO: Mensagem de Fim de Jogo "Continua..." */
#game-end-message {
    font-family: 'Cinzel', serif;
    font-size: 3rem;
    color: #000000; /* Texto preto sobre o fundo branco */
    opacity: 0; /* Começa invisível */
    transition: opacity 1s ease-in;
    transition-delay: 0.5s; /* Aparece 0.5s depois do fade branco */
}


/* 3. UI FIXA (MIRA, LOGO, COPYRIGHT) */
#crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    font-weight: bold;
    color: rgba(255, 255, 255, 0.7); 
    pointer-events: none; 
    z-index: 100;
    display: none; 
}

#logo {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 100;
    opacity: 0.8;
    pointer-events: none;
    display: none; 
}

#logo img {
    width: 100px; 
    height: auto;
}

#copyright {
    position: fixed;
    bottom: 10px;
    right: 10px;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.5);
    z-index: 100;
    pointer-events: none;
    display: none; 
}


/* 4. CONTROLES MOBILE (D-PAD E BOTÃO DE AÇÃO) */
#dpad-container,
#action-btn {
    display: none; 
    position: fixed;
    z-index: 110;
    user-select: none; 
    -webkit-user-select: none;
}

#dpad-container {
    bottom: 30px;
    left: 30px;
    width: 150px;
    height: 150px;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr 1fr;
    opacity: 0.5; 
}

#dpad-forward { grid-area: 1 / 2 / 2 / 3; }
#dpad-left { grid-area: 2 / 1 / 3 / 2; }
#dpad-right { grid-area: 2 / 3 / 3 / 4; }
#dpad-backward { grid-area: 3 / 2 / 4 / 3; }

.dpad-btn {
    background-color: rgba(255, 255, 255, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.5);
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
    border-radius: 8px; 
}

.dpad-btn:active {
    background-color: rgba(255, 255, 255, 0.6);
}

#action-btn {
    bottom: 40px;
    right: 40px;
    width: 80px;
    height: 80px;
    background-color: rgba(255, 255, 255, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.7);
    color: white;
    font-size: 2rem;
    font-weight: bold;
    font-family: 'Cinzel', serif;
    border-radius: 50%; 
    cursor: pointer;
    opacity: 0.6;
}

#action-btn:active {
    background-color: rgba(255, 255, 255, 0.6);
}


/* 5. RESPONSIVIDADE (MENSAGEM DE ROTAÇÃO) */
#rotate-message {
    display: none; 
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000000;
    color: #ffffff;
    z-index: 250; 
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 20px;
    font-family: 'Cinzel', serif;
    font-size: 1.2rem;
}

@media (orientation: portrait) {
    #rotate-message {
        display: flex; 
    }

    #crosshair,
    #dpad-container,
    #action-btn,
    #logo,
    #copyright,
    #loading-screen {
        display: none !important;
    }
}
js/geral/loader.js
(Sem alterações. Coloque em js/geral/)

JavaScript
/*
    ARQUIVO: js/geral/loader.js
    DESCRIÇÃO: Gerenciador de Carregamento de Assets.
    FUNÇÃO: Este script é responsável por carregar todas as texturas (imagens)
    necessárias para o projeto ANTES que a experiência comece.
    
    COMENTÁRIOS EM: PT-BR
*/

class AssetLoader {
    // O construtor recebe as funções que devem ser chamadas
    // durante o carregamento (onProgress) e ao finalizar (onLoad).
    constructor(onProgress, onLoad) {
        // O LoadingManager monitora todos os loaders.
        this.manager = new THREE.LoadingManager();
        
        // Define as funções de callback do manager.
        this.manager.onProgress = (url, itemsLoaded, itemsTotal) => {
            // Calcula a porcentagem
            const progress = (itemsLoaded / itemsTotal) * 100;
            // Chama a função onProgress (definida em main.js)
            onProgress(progress);
            console.log(`Carregando: ${url} (${progress.toFixed(0)}%)`);
        };

        this.manager.onLoad = () => {
            // Chama a função onLoad (definida em main.js)
            onLoad();
            console.log('Todos os assets foram carregados.');
        };

        this.manager.onError = (url) => {
            console.error(`Erro ao carregar o asset: ${url}`);
        };

        // O TextureLoader é o responsável por carregar as imagens.
        // Passamos o manager para ele.
        this.textureLoader = new THREE.TextureLoader(this.manager);
    }

    /**
     * Carrega uma lista de texturas.
     * @param {Array<Object>} texturesToLoad - Um array de objetos { name, path }
     * @returns {Object} - Um objeto onde as chaves são os nomes (name) e os
     * valores são as texturas (THREE.Texture) carregadas.
     */
    loadTextures(texturesToLoad) {
        const textures = {};
        
        texturesToLoad.forEach(tex => {
            // Carrega a textura
            const texture = this.textureLoader.load(tex.path);
            
            // Configurações de repetição (wrapping) e filtro
            // Essencial para texturas de chão e parede.
            if (tex.repeat) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(tex.repeat[0], tex.repeat[1]);
            }

            // Adiciona ao nosso objeto de texturas
            textures[tex.name] = texture;
        });

        // Retorna o objeto com todas as texturas (que ainda estão carregando,
        *mas o manager vai saber quando terminarem).
        return textures;
    }
}
js/geral/controls.js
(Sem alterações. Coloque em js/geral/)

JavaScript
/*
    ARQUIVO: js/geral/controls.js
    DESCRIÇÃO: Gerenciador de Controles do Jogador (Input Handler).
    FUNÇÃO: Gerencia todo o input (Teclado, Mouse, Toque) e
    a lógica de colisão do jogador.
    
    COMENTÁRIOS EM: PT-BR
*/

class PlayerControls {

    /**
     * @param {THREE.Camera} camera - A câmera do jogador.
     * @param {HTMLElement} domElement - O elemento canvas (para eventos).
     * @param {Object} settings - Configurações de velocidade e sensibilidade.
     */
    constructor(camera, domElement, settings) {
        this.camera = camera;
        this.domElement = domElement;
        this.settings = settings;

        // Referência à função de interação (definida em main.js)
        this.onInteract = () => {}; 
        
        // Estado de movimento
        this.moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        // Estado da Câmera (Mouse Look)
        this.cameraLook = {
            pitch: 0, // Rotação vertical (X)
            yaw: 0   // Rotação horizontal (Y)
        };
        
        // Propriedades de física/movimento
        this.velocity = new THREE.Vector3();
        this.direction = new THREE.Vector3();

        // Configurações do mundo atual (Sempre 1, neste caso)
        this.currentWorld = 1;
        this.collisionLimits = null; // Limites de colisão do mundo atual
        
        // Detecção de Mobile (baseado em 'touchstart')
        this.isMobile = 'ontouchstart' in window;
        
        // Armazena o ID do toque de movimento (para multi-toque)
        this.moveTouchId = null; 
        this.lookTouchId = null;
        this.lastLookPos = { x: 0, y: 0 };
        
        // Ajusta a sensibilidade para mobile (conforme UX finalizado)
        this.sensitivity = this.isMobile ? 
            this.settings.mobileCameraSpeed : 
            this.settings.desktopCameraSpeed;

        // Inicializa os ouvintes de eventos
        this.initListeners();
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO DOS OUVINTES DE EVENTO
    // -----------------------------------------------------------------
    initListeners() {
        if (this.isMobile) {
            // Se for mobile, inicializa os controles de toque
            this.initMobileControls();
        } else {
            // Se for desktop, inicializa o Pointer Lock (travar mouse)
            this.initPointerLock();
            // E os ouvintes de teclado
            document.addEventListener('keydown', this.onKeyDown.bind(this));
            document.addEventListener('keyup', this.onKeyUp.bind(this));
        }
    }

    // (Desktop) Configura o Pointer Lock
    initPointerLock() {
        this.domElement.addEventListener('click', () => {
            this.domElement.requestPointerLock();
        });

        // Ouve o movimento do mouse APENAS quando o mouse está travado
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === this.domElement) {
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
            } else {
                document.removeEventListener('mousemove', this.onMouseMove.bind(this));
            }
        });
    }

    // (Mobile) Configura os botões de toque
    initMobileControls() {
        // Mostra os botões de D-Pad e Ação
        document.getElementById('dpad-container').style.display = 'grid';
        document.getElementById('action-btn').style.display = 'block';

        // Ouvintes do D-Pad (touchstart = pressionar, touchend = soltar)
        this.addTouchListener('dpad-forward', 'forward');
        this.addTouchListener('dpad-backward', 'backward');
        this.addTouchListener('dpad-left', 'left');
        this.addTouchListener('dpad-right', 'right');

        // Ouvinte do Botão de Ação
        document.getElementById('action-btn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.onInteract(); // Chama a função de interação
        });
        
        // Ouvinte de Toque na Tela (para olhar ao redor)
        this.domElement.addEventListener('touchstart', this.onMobileTouchStart.bind(this));
        this.domElement.addEventListener('touchmove', this.onMobileTouchMove.bind(this));
        this.domElement.addEventListener('touchend', this.onMobileTouchEnd.bind(this));
    }

    // (Mobile) Função auxiliar para adicionar ouvintes de toque
    addTouchListener(elementId, direction) {
        const element = document.getElementById(elementId);
        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.moveState[direction] = true;
        });
        element.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.moveState[direction] = false;
        });
    }

    // -----------------------------------------------------------------
    // HANDLERS DE EVENTO (MOVIMENTO / AÇÃO)
    // -----------------------------------------------------------------

    // (Desktop) Tecla pressionada
    onKeyDown(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = true; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = true; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = true; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = true; break;
            case 'KeyE': this.onInteract(); break; // Tecla de Interação [E]
        }
    }

    // (Desktop) Tecla solta
    onKeyUp(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.moveState.forward = false; break;
            case 'ArrowLeft':
            case 'KeyA': this.moveState.left = false; break;
            case 'ArrowDown':
            case 'KeyS': this.moveState.backward = false; break;
            case 'ArrowRight':
            case 'KeyD': this.moveState.right = false; break;
        }
    }

    // (Desktop) Movimento do mouse (Pointer Lock)
    onMouseMove(event) {
        if (document.pointerLockElement !== this.domElement) return;

        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;

        // Rotação Horizontal (Yaw) - Eixo Y
        this.cameraLook.yaw -= movementX * this.sensitivity;
        
        // Rotação Vertical (Pitch) - Eixo X
        this.cameraLook.pitch -= movementY * this.sensitivity;
        
        // Trava a rotação vertical (para não "quebrar o pescoço")
        this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
        
        // Aplica as rotações (Ordem EULER_YXZ é importante para FPS)
        this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
    }

    // (Mobile) Início do toque na tela
    onMobileTouchStart(event) {
        event.preventDefault();
        // Itera sobre os toques
        for (const touch of event.changedTouches) {
            // Se o toque for na metade direita da tela, é para "olhar"
            if (touch.clientX > window.innerWidth / 2 && this.lookTouchId === null) {
                this.lookTouchId = touch.identifier;
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;
            }
        }
    }

    // (Mobile) Movimento do toque na tela (Olhar)
    onMobileTouchMove(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se for o toque que estamos rastreando para "olhar"
            if (touch.identifier === this.lookTouchId) {
                const deltaX = touch.clientX - this.lastLookPos.x;
                const deltaY = touch.clientY - this.lastLookPos.y;

                // Salva a nova posição
                this.lastLookPos.x = touch.clientX;
                this.lastLookPos.y = touch.clientY;

                // Aplica a rotação (similar ao onMouseMove)
                this.cameraLook.yaw -= deltaX * this.sensitivity;
                this.cameraLook.pitch -= deltaY * this.sensitivity;
                this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));
                
                this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');
            }
        }
    }

    // (Mobile) Fim do toque na tela
    onMobileTouchEnd(event) {
        event.preventDefault();
        for (const touch of event.changedTouches) {
            // Se o toque que terminou era o de "olhar", para de rastrear
            if (touch.identifier === this.lookTouchId) {
                this.lookTouchId = null;
            }
        }
    }


    // -----------------------------------------------------------------
    // ATUALIZAÇÃO (LOOP PRINCIPAL) E COLISÃO
    // -----------------------------------------------------------------

    /**
     * Define os limites de colisão do mundo atual.
     * @param {number} worldId - 1 para Floresta.
     * @param {Object} limits - O objeto de limites vindo de 'scene.js'.
     */
    setWorld(worldId, limits) {
        this.currentWorld = worldId;
        this.collisionLimits = limits;
    }
    
    /**
     * Reseta a rotação da câmera (usado na transição).
     */
    resetRotation() {
        this.cameraLook.pitch = 0;
        this.cameraLook.yaw = 0;
        this.camera.rotation.set(0, 0, 0, 'YXZ');
    }

    /**
     * Chamado a cada frame pelo 'main.js'.
     * @param {number} delta - O tempo (em segundos) desde o último frame.
     */
    update(delta) {
        // Velocidade = 1.8 m/s (conforme UX finalizado)
        const moveSpeed = this.settings.movementSpeed * delta;

        // Reseta a direção do movimento
        this.direction.z = Number(this.moveState.forward) - Number(this.moveState.backward);
        this.direction.x = Number(this.moveState.left) - Number(this.moveState.right);
        this.direction.normalize(); // Garante movimento consistente (diagonal != mais rápido)

        // Salva a posição atual para checagem de colisão
        const oldPosition = this.camera.position.clone();

        // Calcula o movimento relativo à direção que a câmera está olhando
        if (this.moveState.forward || this.moveState.backward) {
            this.camera.translateZ(-this.direction.z * moveSpeed);
        }
        if (this.moveState.left || this.moveState.right) {
            this.camera.translateX(-this.direction.x * moveSpeed);
        }

        // --- LÓGICA DE COLISÃO ---
        // Impede o jogador de sair dos limites definidos
        if (this.collisionLimits) {
            this.applyCollisions(oldPosition);
        }
        
        // Mantém a altura do jogador (impede de voar ou afundar)
        this.camera.position.y = this.settings.playerHeight;
    }

    /**
     * Verifica e aplica as colisões baseadas nos limites do mundo.
     * @param {THREE.Vector3} oldPosition - Posição antes do movimento.
     */
    applyCollisions(oldPosition) {
        const newPosition = this.camera.position;
        const limits = this.collisionLimits;

        // Lógica de Colisão simples de "caixa" (para o mundo da floresta)
        newPosition.x = Math.max(limits.minX, Math.min(limits.maxX, newPosition.x));
        newPosition.z = Math.max(limits.minZ, Math.min(limits.maxZ, newPosition.z));
        
        // Aplica a posição corrigida
        this.camera.position.copy(newPosition);
    }
}
js/geral/interaction.js
(Sem alterações. Coloque em js/geral/)

JavaScript
/*
    ARQUIVO: js/geral/interaction.js
    DESCRIÇÃO: Gerenciador de Interação (Raycaster).
    FUNÇÃO: Esta classe é responsável por "atirar um raio" (Raycast)
    a partir do centro da tela (mira) para detectar com o que
    o jogador está olhando/interagindo.
    
    COMENTÁRIOS EM: PT-BR
*/

class InteractionHandler {

    /**
     * @param {THREE.Camera} camera - A câmera do jogador (de onde o raio sai).
     * @param {THREE.Scene} scene - A cena (onde os objetos estão).
     *S @param {Function} onInteractCallback - Função em 'main.js' a ser chamada
     * quando uma interação válida ocorre.
     */
    constructor(camera, scene, onInteractCallback) {
        this.camera = camera;
        this.scene = scene;
        this.onInteractCallback = onInteractCallback;

        // O Raycaster do Three.js
        this.raycaster = new THREE.Raycaster();
        
        // Coordenadas da mira (sempre [0, 0] = centro da tela)
        this.crosshairCoords = new THREE.Vector2(0, 0);

        // Distância máxima de interação (ex: 3 metros)
        this.interactionDistance = 3.0; 

        // Armazena o objeto que está atualmente na mira
        this.currentTarget = null;
    }

    /**
     * Chamado quando o jogador pressiona [E] ou o Botão de Ação.
     * Esta é a função que efetivamente "dispara" a interação.
     */
    triggerInteraction() {
        // Verifica se há um alvo válido na mira
        if (this.currentTarget) {
            // Chama a função de callback em 'main.js'
            // e passa os dados do objeto (ex: { type: 'gothic_door' })
            this.onInteractCallback(this.currentTarget.userData);
        } else {
            // (Opcional) Tocar um som de "falha" se não houver nada
            console.log("Nenhum alvo interativo ao alcance.");
        }
    }

    /**
     * Chamado a cada frame pelo 'main.js' (ANTES do update de controles).
     * Esta função *apenas* verifica o que está na mira, mas não
     * dispara a ação.
     */
    update() {
        // 1. Atualiza o raio para sair do centro da câmera
        this.raycaster.setFromCamera(this.crosshairCoords, this.camera);

        // 2. Verifica quais objetos na cena (recursivamente) o raio atinge
        // Passamos 'this.scene.children' e 'true' para verificar os filhos
        // dos grupos (World1_Group).
        const intersects = this.raycaster.intersectObjects(this.scene.children, true);

        // Reseta o alvo atual
        this.currentTarget = null;

        // 3. Itera sobre os objetos atingidos
        for (const intersect of intersects) {
            
            // 4. Verifica se o objeto tem o 'userData' interativo
            // (Nós definimos isso em 'CenaFloresta.js')
            if (intersect.object.userData && intersect.object.userData.interactive === true) {
                
                // 5. Verifica se está dentro da distância permitida
                if (intersect.distance <= this.interactionDistance) {
                    
                    // Encontramos um alvo válido!
                    this.currentTarget = intersect.object;
                    
                    // (Opcional) Mudar a cor da mira para "ativa"
                    // document.getElementById('crosshair').style.color = 'red';
                    
                    // Para o loop assim que encontrar o primeiro alvo válido
                    break;
                }
            }
        }
        
        // Se o loop terminou e this.currentTarget ainda é nulo,
        // significa que não estamos olhando para nada interativo.
        if (this.currentTarget === null) {
            // (Opcional) Resetar a cor da mira para "passiva"
            // document.getElementById('crosshair').style.color = 'rgba(255, 255, 255, 0.7)';
        }
    }
}
js/geral/main.js (ATUALIZADO)
(Este é o arquivo mais modificado. Ele não carrega mais o arts.json nem as texturas do corredor, e chama triggerGameEnd na interação com a porta)

JavaScript
/*
    ARQUIVO: js/geral/main.js
    DESCRIÇÃO: Ponto de Entrada Principal da Aplicação (O "Maestro").
    FUNÇÃO: Este script inicializa todos os componentes da floresta (Cena 1),
    gerencia o "Game Loop" (o 'animate'), e lida com a lógica de
    interação para "terminar" a demo quando a porta é encontrada.
    
    COMENTÁRIOS EM: PT-BR
*/

// Classe principal da aplicação
class SungApp {
    
    constructor() {
        // Elementos do DOM
        this.canvas = document.getElementById('game-canvas');
        this.loadingScreen = document.getElementById('loading-screen');
        this.loadingText = document.querySelector('.loading-text');
        this.transitionFade = document.getElementById('transition-fade');
        this.gameEndMessage = document.getElementById('game-end-message'); // Mensagem de Fim
        this.uiElements = [
            document.getElementById('crosshair'),
            document.getElementById('logo'),
            document.getElementById('copyright')
        ];

        // Componentes do Three.js
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true // Suavização de serrilhado
        });
        this.clock = new THREE.Clock(); // Relógio para o 'delta time'

        // Componentes do Jogo
        this.loader = null;
        this.controls = null;
        this.interaction = null;
        
        // Construtor de Cena
        this.forestBuilder = null;   // (Virá de CenaFloresta.js)
        
        // Grupo de Cena (Apenas Mundo 1)
        this.world1_Group = null;

        // Estado do Jogo
        this.isLoaded = false;
        this.isTransitioning = false; // Usado agora para o "fim de jogo"
        
        // Configurações (conforme UX finalizado)
        this.settings = {
            movementSpeed: 1.8,         // 1.8 m/s
            desktopCameraSpeed: 0.0008, // Sensibilidade Desktop
            mobileCameraSpeed: 0.0025,  // Sensibilidade Mobile
            playerHeight: 1.6           // Altura dos olhos do jogador
        };
        
        // Referência 'bind' para o loop de animação
        this.animate = this.animate.bind(this);
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Método principal de inicialização
     */
    init() {
        console.log("Iniciando SungApp (Modo Floresta)...");

        try {
            // 1. Configurar o Renderizador
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            this.renderer.outputEncoding = THREE.sRGBEncoding;

            // 2. Configurar a Posição Inicial da Câmera
            // (Na borda do mapa, na rodovia, em Z=90)
            this.camera.position.set(0, this.settings.playerHeight, 90);

            // 3. Inicializar o Loader de Assets (Texturas)
            this.loader = new AssetLoader(
                (progress) => {
                    // Função 'onProgress'
                    this.loadingText.textContent = `Carregando... ${progress.toFixed(0)}%`;
                },
                () => {
                    // Função 'onLoad' (Tudo carregado)
                    this.startExperience();
                }
            );

            // 4. Definir quais texturas carregar
            // (Apenas texturas da floresta, sem o corredor)
            const sceneTextures = [
                { name: 'rodovia', path: 'assets/rodovia_texture.jpg', repeat: [3, 10] },
                { name: 'porta', path: 'assets/porta.png' }, 
                { name: 'path', path: 'assets/path_texture.jpg', repeat: [2, 12] },
                { name: 'arvore', path: 'assets/arvore.png' },
                { name: 'crystalGlow', path: 'assets/crystal_glow.png' },
                { name: 'rock', path: 'assets/rock.png' },
                { name: 'forest_floor', path: 'assets/forest_floor.jpg', repeat: [50, 50] }
            ];
            
            // Carrega as texturas da cena
            const loadedTextures = this.loader.loadTextures(sceneTextures);
            
            // 5. Inicializar a "Fábrica" de Mundos com as texturas
            // (Usa a classe de js/floresta/CenaFloresta.js)
            this.forestBuilder = new ForestSceneBuilder(loadedTextures);

            // 6. Ouvinte de redimensionamento da janela
            window.addEventListener('resize', this.onWindowResize.bind(this));
        
        } catch (error) {
            console.error("Falha fatal na inicialização:", error);
            this.loadingText.textContent = "Erro ao carregar. Verifique o console.";
            this.loadingText.style.color = "red";
        }
    }
    
    /**
     * Chamado quando o Loader termina (onLoad).
     */
    startExperience() {
        console.log("Assets carregados. Iniciando a experiência.");
        this.isLoaded = true;
        
        // 1. Construir o Mundo 1 (Floresta)
        const world1Data = this.forestBuilder.createWorld1(this.scene);
        this.world1_Group = world1Data.group;
        this.scene.add(this.world1_Group);

        // 2. Inicializar Controles
        this.controls = new PlayerControls(this.camera, this.canvas, this.settings);
        // Define os limites de colisão para o mundo 1
        this.controls.setWorld(1, world1Data.collisionLimits);
        
        // 3. Inicializar Interação
        this.interaction = new InteractionHandler(
            this.camera, 
            this.scene, 
            this.handleInteraction.bind(this) // Callback
        );
        
        // 4. Conectar Controles e Interação
        // Diz ao 'controls' qual função chamar quando [E] é pressionado
        this.controls.onInteract = () => {
            this.interaction.triggerInteraction();
        };

        // 5. Esconder a tela de Loading e mostrar a UI do Jogo
        this.loadingScreen.style.opacity = '0';
        setTimeout(() => {
            this.loadingScreen.style.display = 'none';
        }, 500); // 0.5s (duração da transição do CSS)

        // Mostra a UI (Mira, Logo, etc.)
        this.uiElements.forEach(el => el.style.display = 'block');
        
        // 6. Iniciar o Loop de Animação
        this.animate();
    }
    
    // -----------------------------------------------------------------
    // LOOP DE ANIMAÇÃO (GAME LOOP)
    // -----------------------------------------------------------------

    /**
     * O Loop Principal (requestAnimationFrame).
     */
    animate() {
        // Pede ao navegador para chamar 'animate' no próximo frame
        requestAnimationFrame(this.animate);

        // Se não carregou ou está em transição de fim de jogo, para
        if (!this.isLoaded || this.isTransitioning) {
            return;
        }

        // Pega o tempo delta (diferença do último frame)
        const delta = this.clock.getDelta();

        // 1. Atualiza o handler de interação (verifica o que está na mira)
        this.interaction.update();
        
        // 2. Atualiza os controles do jogador (movimento, colisão)
        this.controls.update(delta);

        // 3. Renderiza a cena 3D
        this.renderer.render(this.scene, this.camera);
    }
    
    // -----------------------------------------------------------------
    // LÓGICA DE INTERAÇÃO (FIM DE JOGO)
    // -----------------------------------------------------------------
    
    /**
     * Callback chamado pelo 'InteractionHandler' quando [E] é pressionado
     * em um alvo válido.
     * @param {Object} userData - Os dados do objeto (ex: { type: 'gothic_door' })
     */
    handleInteraction(userData) {
        console.log("Interação disparada:", userData);
        
        // Verifica se é a porta gótica
        if (userData.type === 'gothic_door') {
            this.triggerGameEnd();
        }
    }

    /**
     * Executa o "Fim de Jogo" (Fade para Branco e mensagem)
     */
    triggerGameEnd() {
        if (this.isTransitioning) return; // Previne cliques duplos
        
        console.log("Fim da demo. Iniciando fade out...");
        this.isTransitioning = true; // Pausa o 'animate' loop

        // 1. Fade In Rápido (0.5s) para Branco
        this.transitionFade.style.transition = 'opacity 0.5s ease-in';
        this.transitionFade.style.opacity = '1';

        // 2. Mostra a mensagem "CONTINUA..."
        // (O delay da transição está no CSS)
        this.gameEndMessage.style.opacity = '1';

        // 3. Trava os controles
        // Se o PointerLock estiver ativo, destrava o mouse
        if (document.pointerLockElement) {
            document.exitPointerLock();
        }
        // Esconde a UI do jogo
        this.uiElements.forEach(el => el.style.display = 'none');
        document.getElementById('dpad-container').style.display = 'none';
        document.getElementById('action-btn').style.display = 'none';
    }

    // -----------------------------------------------------------------
    // UTILITÁRIOS
    // -----------------------------------------------------------------

    /**
     * Chamado quando a janela do navegador muda de tamanho.
     */
    onWindowResize() {
        // Atualiza as proporções da câmera
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();

        // Atualiza o tamanho do renderizador
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}

// -----------------------------------------------------------------
// PONTO DE ENTRADA
// -----------------------------------------------------------------

// Quando o DOM (HTML) estiver pronto, cria e inicializa a aplicação.
window.addEventListener('DOMContentLoaded', () => {
    // Lembrete sobre o servidor local (para o 'fetch' funcionar)
    if (window.location.protocol === 'file:') {
        console.error("ERRO: O projeto não pode ser executado localmente via 'file://'. Use um servidor local (veja como_rodar.txt).");
        document.body.innerHTML = '<div style="color: red; font-size: 20px; padding: 20px;">ERRO: O projeto não pode ser executado localmente. Por favor, use um servidor (veja o arquivo como_rodar.txt).</div>';
        return;
    }
    
    const app = new SungApp();
    app.init();
});
js/floresta/CenaFloresta.js
(Sem alterações. Coloque em js/floresta/)

JavaScript
/*
    ARQUIVO: js/floresta/CenaFloresta.js
    DESCRIÇÃO: Construtor de Cenário 3D - MUNDO 1 (FLORESTA).
    FUNÇÃO: Esta classe é uma "fábrica" de geometria. Ela contém
    apenas o método `createWorld1` para construir a cena da floresta.
    
    COMENTÁRIOS EM: PT-BR
*/

class ForestSceneBuilder {

    constructor(textures) {
        // Armazena as texturas que o 'loader.js' carregou.
        this.textures = textures;
        // Altura padrão da câmera (nível dos olhos)
        this.playerHeight = 1.6;
    }

    // -----------------------------------------------------------------
    // CENA 1: A DESCOBERTA (MUNDO ABERTO / FLORESTA)
    // -----------------------------------------------------------------
    createWorld1(scene) {
        const world1Group = new THREE.Group();
        world1Group.name = "World1_Group"; // Nome para depuração

        // 1. Configuração do Clima (Névoa e Luz)
        // Cor cinza-azulado escuro, inspirada em 'clima.png' (Sleepy Hollow)
        const fogColor = 0x2c3e50; 
        scene.background = new THREE.Color(fogColor);
        // A névoa começa perto e fica densa rapidamente
        scene.fog = new THREE.Fog(fogColor, 1, 40); // Névoa densa

        // Luz ambiente fraca, para dar o tom sombrio
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // (cor, intensidade)
        world1Group.add(ambientLight);

        // Luz direcional (simulando lua/crepúsculo)
        const directionalLight = new THREE.DirectionalLight(0x505a70, 0.4);
        directionalLight.position.set(5, 10, 5);
        world1Group.add(directionalLight);

        
        // 2. Geometria do Chão (Mundo Aberto)
        
        // Chão da Floresta (Ground082S) - O MAPA INTEIRO
        const forestFloorMaterial = new THREE.MeshBasicMaterial({ map: this.textures.forest_floor });
        const forestFloorGeometry = new THREE.PlaneGeometry(200, 200); // 200m x 200m
        const forestFloor = new THREE.Mesh(forestFloorGeometry, forestFloorMaterial);
        forestFloor.rotation.x = -Math.PI / 2;
        forestFloor.position.set(0, 0, 0); // Centralizado na origem
        world1Group.add(forestFloor);

        // Rodovia (Asphalt033) - PONTO DE INÍCIO
        const roadMaterial = new THREE.MeshBasicMaterial({ map: this.textures.rodovia });
        const roadGeometry = new THREE.PlaneGeometry(15, 60); // (largura, comprimento)
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; 
        road.position.set(0, 0.01, 70); // Na borda do mapa (Z=70 a Z=100)
        world1Group.add(road);

        // Trilha de Tijolos ESCONDIDA (Bricks075B)
        const pathMaterial = new THREE.MeshBasicMaterial({ map: this.textures.path });
        const pathGeometry = new THREE.PlaneGeometry(3, 40); // Trilha estreita (3m x 40m)
        const path = new THREE.Mesh(pathGeometry, pathMaterial);
        path.rotation.x = -Math.PI / 2;
        // Posição escondida dentro da floresta
        path.position.set(30, 0.01, -20); // Escondida em X=30, Z=-20
        world1Group.add(path);


        // 3. Floresta Densa (Billboards de Árvores)
        // Material da árvore (usa 'arvore.png')
        const treeMaterial = new THREE.SpriteMaterial({ 
            map: this.textures.tree,
            fog: true,
            color: 0xcccccc 
        });
        
        // Material do brilho do cristal
        const crystalMaterial = new THREE.SpriteMaterial({
            map: this.textures.crystalGlow,
            blending: THREE.AdditiveBlending, // Efeito de brilho
            fog: false, // Cristais brilham através da névoa
            transparent: true,
            opacity: 0.8
        });

        // Material da Rocha
        const rockMaterial = new THREE.SpriteMaterial({
            map: this.textures.rock,
            fog: true,
            color: 0xbbbbbb 
        });

        // Cria 2000 árvores para densidade
        for (let i = 0; i < 2000; i++) {
            const sprite = new THREE.Sprite(treeMaterial);
            
            const x = (Math.random() - 0.5) * 200; // X de -100 a 100
            const z = (Math.random() - 0.5) * 200; // Z de -100 a 100

            // *** LÓGICA PARA NÃO NASCER ÁRVORE NA ESTRADA OU NA TRILHA ***
            // Checa área da estrada (X -7.5 a 7.5, Z 40 a 100)
            if (x > -7.5 && x < 7.5 && z > 40 && z < 100) {
                continue; // Pula esta árvore
            }
            // Checa área da trilha (X 28.5 a 31.5, Z -40 a 0)
            if (x > 28.5 && x < 31.5 && z > -40 && z < 0) {
                continue; // Pula esta árvore
            }

            // Tamanho aleatório (árvores grandes e médias)
            const scale = Math.random() * 3 + 4; // Escala entre 4m e 7m
            sprite.scale.set(scale, scale, 1);
            sprite.position.set(x, scale / 2, z); // (x, altura, z)
            world1Group.add(sprite);
        }

        // Adiciona Rochas (100)
        for (let i = 0; i < 100; i++) {
            const rockSprite = new THREE.Sprite(rockMaterial);
            const x = (Math.random() - 0.5) * 200; 
            const z = (Math.random() - 0.5) * 200;
            
            // Checa área da estrada
            if (x > -7.5 && x < 7.5 && z > 40 && z < 100) continue; 
            // Checa área da trilha
            if (x > 28.5 && x < 31.5 && z > -40 && z < 0) continue; 

            const scale = Math.random() * 0.5 + 0.5; // Rochas pequenas (0.5m a 1m)
            rockSprite.scale.set(scale, scale, 1);
            rockSprite.position.set(x, scale / 2, z); // No chão
            world1Group.add(rockSprite);
        }

        // 4. A Pista de Cristais (As "Migalhas de Pão")
        // Coloca cristais guiando da estrada (0, 60) até a trilha (30, 0)
        const crystalPath = [
            {x: 5, z: 60},
            {x: 10, z: 55},
            {x: 15, z: 50},
            {x: 20, z: 40},
            {x: 25, z: 30},
            {x: 30, z: 20},
            {x: 30, z: 10},
            {x: 30, z: 0}, // Chegou na trilha
            {x: 30, z: -10},
            {x: 30, z: -20},
            {x: 30, z: -30} // Perto da porta
        ];

        crystalPath.forEach(pos => {
            // Luz Pontual (azulada)
            const light = new THREE.PointLight(0xadd8e6, 1.5, 8); // (cor, intensidade, distância)
            light.position.set(pos.x, 1.5, pos.z); // Posição
            world1Group.add(light);
            
            // Sprite visual do cristal
            const crystalSprite = new THREE.Sprite(crystalMaterial);
            crystalSprite.position.copy(light.position);
            crystalSprite.scale.set(1.5, 2.5, 1); 
            world1Group.add(crystalSprite);
        });


        // 5. A Porta Gótica (Objetivo)
        // Simula a "rocha" onde a porta está
        const rockFaceMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 }); 
        const rockFaceGeometry = new THREE.PlaneGeometry(8, 8); // Parede de rocha
        const rockFace = new THREE.Mesh(rockFaceGeometry, rockFaceMaterial);
        // Posicionada no final da trilha escondida
        rockFace.position.set(30, 4, -40.5); // (x, altura, z)
        world1Group.add(rockFace);
        
        // A porta em si
        const doorMaterial = new THREE.MeshBasicMaterial({ 
            map: this.textures.porta,
            transparent: true 
        });
        const doorGeometry = new THREE.PlaneGeometry(4, 5); // Tamanho da porta
        const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
        
        // Posiciona no final da trilha, em frente à rocha
        doorMesh.position.set(30, 2.5, -40); // (x, altura, z)
        
        // Adiciona o 'userData' para interação
        doorMesh.userData = { 
            interactive: true, 
            type: 'gothic_door' 
        };
        world1Group.add(doorMesh);


        // 6. Limites de Colisão (Mundo Aberto)
        // Agora, os limites são apenas as bordas do mapa (chão da floresta)
        const worldLimits = {
            minX: -98, // 2m de margem
            maxX: 98,
            minZ: -98,
            maxZ: 98
        };

        // Retorna o grupo de objetos e os limites de colisão
        return { group: world1Group, collisionLimits: worldLimits };
    }
}
esses sao as minhas pastas com as textures baixadas

o terra 2 e o q fica perto do asphalt e terra1 e o fica mais dentro da clareira

pode fazer uma floresta bem grande dai nos vemos onde fica melho pra colocr a porta eu tenho q baixar as texturas das arvores ne ?

e esses sao os meus codigos

html

<!DOCTYPE html>

<html lang="pt-br">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <title>Sung Studios - A Caçada</title> <link rel="stylesheet" href="CSS/styles.css">



    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

</head>

<body>



    <div id="loading-screen">

        <div class="loading-text">Carregando...</div>

    </div>



    <div id="rotate-message">

        <p>Por favor, gire seu dispositivo para a posição horizontal (paisagem) para iniciar a experiência.</p>

    </div>



    <div id="transition-fade">

        <div id="game-end-message">CONTINUA...</div>

    </div>



    <div id="crosshair">+</div>



    <div id="dpad-container">

        <button id="dpad-forward" class="dpad-btn">▲</button>

        <button id="dpad-backward" class="dpad-btn">▼</button>

        <button id="dpad-left" class="dpad-btn">◄</button>

        <button id="dpad-right" class="dpad-btn">►</button>

    </div>



    <button id="action-btn">E</button>



    <div id="logo">

        <img src="assets/belial.png" alt="Sung Studios Logo">

    </div>

    

    <div id="copyright">© 2025 D'Artagnan AI Studios - Feito pela Equipe Sung</div>



    <canvas id="game-canvas"></canvas>

<script src="js/geral/controls.js"></script>

<script src="js/geral/interaction.js"></script>

<script src="js/geral/loader.js"></script>

<script src="js/geral/main.js"></script>



</body>

</html>

css

/*

    ARQUIVO: CSS/styles.css

    DESCRIÇÃO: Folha de Estilos Principal.

    FUNÇÃO: Define todos os estilos visuais da aplicação.

    

    COMENTÁRIOS EM: PT-BR

*/



/* 1. CONFIGURAÇÃO GLOBAL E FONTES */

@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400&display=swap');



* {

    margin: 0;

    padding: 0;

    box-sizing: border-box;

}



html, body {

    width: 100%;

    height: 100%;

    overflow: hidden; 

    background-color: #000000;

    color: #ffffff;

    font-family: 'Inter', sans-serif;

}



/* 2. ELEMENTOS 3D E OVERLAYS */

#game-canvas {

    position: fixed;

    top: 0;

    left: 0;

    width: 100%;

    height: 100%;

    z-index: 1; 

    cursor: pointer; 

}



#loading-screen {

    position: fixed;

    top: 0;

    left: 0;

    width: 100%;

    height: 100%;

    background-color: #000000;

    display: flex;

    justify-content: center;

    align-items: center;

    z-index: 200; 

    transition: opacity 0.5s ease-out;

}



.loading-text {

    font-family: 'Cinzel', serif;

    font-size: 1.5rem;

    color: #ffffff;

}



/* Tela de Transição (Usada para o Fim de Jogo) */

#transition-fade {

    position: fixed;

    top: 0;

    left: 0;

    width: 100%;

    height: 100%;

    background-color: #ffffff; /* Fundo branco do fade */

    opacity: 0;

    pointer-events: none; 

    z-index: 150; 

    display: flex;

    justify-content: center;

    align-items: center;

}



/* NOVO: Mensagem de Fim de Jogo "Continua..." */

#game-end-message {

    font-family: 'Cinzel', serif;

    font-size: 3rem;

    color: #000000; /* Texto preto sobre o fundo branco */

    opacity: 0; /* Começa invisível */

    transition: opacity 1s ease-in;

    transition-delay: 0.5s; /* Aparece 0.5s depois do fade branco */

}





/* 3. UI FIXA (MIRA, LOGO, COPYRIGHT) */

#crosshair {

    position: fixed;

    top: 50%;

    left: 50%;

    transform: translate(-50%, -50%);

    font-size: 24px;

    font-weight: bold;

    color: rgba(255, 255, 255, 0.7); 

    pointer-events: none; 

    z-index: 100;

    display: none; 

}



#logo {

    position: fixed;

    top: 20px;

    left: 20px;

    z-index: 100;

    opacity: 0.8;

    pointer-events: none;

    display: none; 

}



#logo img {

    width: 100px; 

    height: auto;

}



#copyright {

    position: fixed;

    bottom: 10px;

    right: 10px;

    font-size: 12px;

    color: rgba(255, 255, 255, 0.5);

    z-index: 100;

    pointer-events: none;

    display: none; 

}





/* 4. CONTROLES MOBILE (D-PAD E BOTÃO DE AÇÃO) */

#dpad-container,

#action-btn {

    display: none; 

    position: fixed;

    z-index: 110;

    user-select: none; 

    -webkit-user-select: none;

}



#dpad-container {

    bottom: 30px;

    left: 30px;

    width: 150px;

    height: 150px;

    display: grid;

    grid-template-columns: 1fr 1fr 1fr;

    grid-template-rows: 1fr 1fr 1fr;

    opacity: 0.5; 

}



#dpad-forward { grid-area: 1 / 2 / 2 / 3; }

#dpad-left { grid-area: 2 / 1 / 3 / 2; }

#dpad-right { grid-area: 2 / 3 / 3 / 4; }

#dpad-backward { grid-area: 3 / 2 / 4 / 3; }



.dpad-btn {

    background-color: rgba(255, 255, 255, 0.3);

    border: 1px solid rgba(255, 255, 255, 0.5);

    color: white;

    font-size: 1.5rem;

    cursor: pointer;

    border-radius: 8px; 

}



.dpad-btn:active {

    background-color: rgba(255, 255, 255, 0.6);

}



#action-btn {

    bottom: 40px;

    right: 40px;

    width: 80px;

    height: 80px;

    background-color: rgba(255, 255, 255, 0.3);

    border: 2px solid rgba(255, 255, 255, 0.7);

    color: white;

    font-size: 2rem;

    font-weight: bold;

    font-family: 'Cinzel', serif;

    border-radius: 50%; 

    cursor: pointer;

    opacity: 0.6;

}



#action-btn:active {

    background-color: rgba(255, 255, 255, 0.6);

}





/* 5. RESPONSIVIDADE (MENSAGEM DE ROTAÇÃO) */

#rotate-message {

    display: none; 

    position: fixed;

    top: 0;

    left: 0;

    width: 100%;

    height: 100%;

    background-color: #000000;

    color: #ffffff;

    z-index: 250; 

    justify-content: center;

    align-items: center;

    text-align: center;

    padding: 20px;

    font-family: 'Cinzel', serif;

    font-size: 1.2rem;

}



@media (orientation: portrait) {

    #rotate-message {

        display: flex; 

    }



    #crosshair,

    #dpad-container,

    #action-btn,

    #logo,

    #copyright,

    #loading-screen {

        display: none !important;

    }

}

cena floresta js

/*

    ARQUIVO: js/floresta/CenaFloresta.js

    DESCRIÇÃO: Construtor de Cenário 3D - MUNDO 1 (FLORESTA).

    FUNÇÃO: Esta classe é uma "fábrica" de geometria. Ela contém

    apenas o método `createWorld1` para construir a cena da floresta.

    

    COMENTÁRIOS EM: PT-BR

*/



class ForestSceneBuilder {

  constructor(textures) {

    // Armazena as texturas que o 'loader.js' carregou.

    this.textures = textures;

    // Altura padrão da câmera (nível dos olhos)

    this.playerHeight = 1.6;

  }



  // -----------------------------------------------------------------

  // CENA 1: A DESCOBERTA (MUNDO ABERTO / FLORESTA)

  // -----------------------------------------------------------------

  createWorld1(scene) {

    const world1Group = new THREE.Group();

    world1Group.name = "World1_Group"; // Nome para depuração



    // 1. Configuração do Clima (Névoa e Luz)

    // Cor cinza-azulado escuro, inspirada em 'clima.png' (Sleepy Hollow)

    const fogColor = 0x2c3e50;

    scene.background = new THREE.Color(fogColor);

    // A névoa começa perto e fica densa rapidamente

    scene.fog = new THREE.Fog(fogColor, 1, 40); // Névoa densa



    // Luz ambiente fraca, para dar o tom sombrio

    const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // (cor, intensidade)

    world1Group.add(ambientLight);



    // Luz direcional (simulando lua/crepúsculo)

    const directionalLight = new THREE.DirectionalLight(0x505a70, 0.4);

    directionalLight.position.set(5, 10, 5);

    world1Group.add(directionalLight);



    // 2. Geometria do Chão (Mundo Aberto)



    // Chão da Floresta (Ground082S) - O MAPA INTEIRO

    const forestFloorMaterial = new THREE.MeshBasicMaterial({

      map: this.textures.forest_floor,

    });

    const forestFloorGeometry = new THREE.PlaneGeometry(200, 200); // 200m x 200m

    const forestFloor = new THREE.Mesh(

      forestFloorGeometry,

      forestFloorMaterial

    );

    forestFloor.rotation.x = -Math.PI / 2;

    forestFloor.position.set(0, 0, 0); // Centralizado na origem

    world1Group.add(forestFloor);



    // Rodovia (Asphalt033) - PONTO DE INÍCIO

    const roadMaterial = new THREE.MeshBasicMaterial({

      map: this.textures.rodovia,

    });

    const roadGeometry = new THREE.PlaneGeometry(15, 60); // (largura, comprimento)

    const road = new THREE.Mesh(roadGeometry, roadMaterial);

    road.rotation.x = -Math.PI / 2;

    road.position.set(0, 0.01, 70); // Na borda do mapa (Z=70 a Z=100)

    world1Group.add(road);



    // Trilha de Tijolos ESCONDIDA (Bricks075B)

    const pathMaterial = new THREE.MeshBasicMaterial({

      map: this.textures.path,

    });

    const pathGeometry = new THREE.PlaneGeometry(3, 40); // Trilha estreita (3m x 40m)

    const path = new THREE.Mesh(pathGeometry, pathMaterial);

    path.rotation.x = -Math.PI / 2;

    // Posição escondida dentro da floresta

    path.position.set(30, 0.01, -20); // Escondida em X=30, Z=-20

    world1Group.add(path);



    // 3. Floresta Densa (Billboards de Árvores)

    // Material da árvore (usa 'arvore.png')

    const treeMaterial = new THREE.SpriteMaterial({

      map: this.textures.tree,

      fog: true,

      color: 0xcccccc,

    });



    // Material do brilho do cristal

    const crystalMaterial = new THREE.SpriteMaterial({

      map: this.textures.crystalGlow,

      blending: THREE.AdditiveBlending, // Efeito de brilho

      fog: false, // Cristais brilham através da névoa

      transparent: true,

      opacity: 0.8,

    });



    // Material da Rocha

    const rockMaterial = new THREE.SpriteMaterial({

      map: this.textures.rock,

      fog: true,

      color: 0xbbbbbb,

    });



    // Cria 2000 árvores para densidade

    for (let i = 0; i < 2000; i++) {

      const sprite = new THREE.Sprite(treeMaterial);



      const x = (Math.random() - 0.5) * 200; // X de -100 a 100

      const z = (Math.random() - 0.5) * 200; // Z de -100 a 100



      // *** LÓGICA PARA NÃO NASCER ÁRVORE NA ESTRADA OU NA TRILHA ***

      // Checa área da estrada (X -7.5 a 7.5, Z 40 a 100)

      if (x > -7.5 && x < 7.5 && z > 40 && z < 100) {

        continue; // Pula esta árvore

      }

      // Checa área da trilha (X 28.5 a 31.5, Z -40 a 0)

      if (x > 28.5 && x < 31.5 && z > -40 && z < 0) {

        continue; // Pula esta árvore

      }



      // Tamanho aleatório (árvores grandes e médias)

      const scale = Math.random() * 3 + 4; // Escala entre 4m e 7m

      sprite.scale.set(scale, scale, 1);

      sprite.position.set(x, scale / 2, z); // (x, altura, z)

      world1Group.add(sprite);

    }



    // Adiciona Rochas (100)

    for (let i = 0; i < 100; i++) {

      const rockSprite = new THREE.Sprite(rockMaterial);

      const x = (Math.random() - 0.5) * 200;

      const z = (Math.random() - 0.5) * 200;



      // Checa área da estrada

      if (x > -7.5 && x < 7.5 && z > 40 && z < 100) continue;

      // Checa área da trilha

      if (x > 28.5 && x < 31.5 && z > -40 && z < 0) continue;



      const scale = Math.random() * 0.5 + 0.5; // Rochas pequenas (0.5m a 1m)

      rockSprite.scale.set(scale, scale, 1);

      rockSprite.position.set(x, scale / 2, z); // No chão

      world1Group.add(rockSprite);

    }



    // 4. A Pista de Cristais (As "Migalhas de Pão")

    // Coloca cristais guiando da estrada (0, 60) até a trilha (30, 0)

    const crystalPath = [

      { x: 5, z: 60 },

      { x: 10, z: 55 },

      { x: 15, z: 50 },

      { x: 20, z: 40 },

      { x: 25, z: 30 },

      { x: 30, z: 20 },

      { x: 30, z: 10 },

      { x: 30, z: 0 }, // Chegou na trilha

      { x: 30, z: -10 },

      { x: 30, z: -20 },

      { x: 30, z: -30 }, // Perto da porta

    ];



    crystalPath.forEach((pos) => {

      // Luz Pontual (azulada)

      const light = new THREE.PointLight(0xadd8e6, 1.5, 8); // (cor, intensidade, distância)

      light.position.set(pos.x, 1.5, pos.z); // Posição

      world1Group.add(light);



      // Sprite visual do cristal

      const crystalSprite = new THREE.Sprite(crystalMaterial);

      crystalSprite.position.copy(light.position);

      crystalSprite.scale.set(1.5, 2.5, 1);

      world1Group.add(crystalSprite);

    });



    // 5. A Porta Gótica (Objetivo)

    // Simula a "rocha" onde a porta está

    const rockFaceMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });

    const rockFaceGeometry = new THREE.PlaneGeometry(8, 8); // Parede de rocha

    const rockFace = new THREE.Mesh(rockFaceGeometry, rockFaceMaterial);

    // Posicionada no final da trilha escondida

    rockFace.position.set(30, 4, -40.5); // (x, altura, z)

    world1Group.add(rockFace);



    // A porta em si

    const doorMaterial = new THREE.MeshBasicMaterial({

      map: this.textures.porta,

      transparent: true,

    });

    const doorGeometry = new THREE.PlaneGeometry(4, 5); // Tamanho da porta

    const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);



    // Posiciona no final da trilha, em frente à rocha

    doorMesh.position.set(30, 2.5, -40); // (x, altura, z)



    // Adiciona o 'userData' para interação

    doorMesh.userData = {

      interactive: true,

      type: "gothic_door",

    };

    world1Group.add(doorMesh);



    // 6. Limites de Colisão (Mundo Aberto)

    // Agora, os limites são apenas as bordas do mapa (chão da floresta)

    const worldLimits = {

      minX: -98, // 2m de margem

      maxX: 98,

      minZ: -98,

      maxZ: 98,

    };



    // Retorna o grupo de objetos e os limites de colisão

    return { group: world1Group, collisionLimits: worldLimits };

  }

}

controls js /geral

/*

    ARQUIVO: js/geral/controls.js

    DESCRIÇÃO: Gerenciador de Controles do Jogador (Input Handler).

    FUNÇÃO: Gerencia todo o input (Teclado, Mouse, Toque) e

    a lógica de colisão do jogador.

    

    COMENTÁRIOS EM: PT-BR

*/



class PlayerControls {



    /**

     * @param {THREE.Camera} camera - A câmera do jogador.

     * @param {HTMLElement} domElement - O elemento canvas (para eventos).

     * @param {Object} settings - Configurações de velocidade e sensibilidade.

     */

    constructor(camera, domElement, settings) {

        this.camera = camera;

        this.domElement = domElement;

        this.settings = settings;



        // Referência à função de interação (definida em main.js)

        this.onInteract = () => {}; 

        

        // Estado de movimento

        this.moveState = {

            forward: false,

            backward: false,

            left: false,

            right: false

        };



        // Estado da Câmera (Mouse Look)

        this.cameraLook = {

            pitch: 0, // Rotação vertical (X)

            yaw: 0   // Rotação horizontal (Y)

        };

        

        // Propriedades de física/movimento

        this.velocity = new THREE.Vector3();

        this.direction = new THREE.Vector3();



        // Configurações do mundo atual (Sempre 1, neste caso)

        this.currentWorld = 1;

        this.collisionLimits = null; // Limites de colisão do mundo atual

        

        // Detecção de Mobile (baseado em 'touchstart')

        this.isMobile = 'ontouchstart' in window;

        

        // Armazena o ID do toque de movimento (para multi-toque)

        this.moveTouchId = null; 

        this.lookTouchId = null;

        this.lastLookPos = { x: 0, y: 0 };

        

        // Ajusta a sensibilidade para mobile (conforme UX finalizado)

        this.sensitivity = this.isMobile ? 

            this.settings.mobileCameraSpeed : 

            this.settings.desktopCameraSpeed;



        // Inicializa os ouvintes de eventos

        this.initListeners();

    }



    // -----------------------------------------------------------------

    // INICIALIZAÇÃO DOS OUVINTES DE EVENTO

    // -----------------------------------------------------------------

    initListeners() {

        if (this.isMobile) {

            // Se for mobile, inicializa os controles de toque

            this.initMobileControls();

        } else {

            // Se for desktop, inicializa o Pointer Lock (travar mouse)

            this.initPointerLock();

            // E os ouvintes de teclado

            document.addEventListener('keydown', this.onKeyDown.bind(this));

            document.addEventListener('keyup', this.onKeyUp.bind(this));

        }

    }



    // (Desktop) Configura o Pointer Lock

    initPointerLock() {

        this.domElement.addEventListener('click', () => {

            this.domElement.requestPointerLock();

        });



        // Ouve o movimento do mouse APENAS quando o mouse está travado

        document.addEventListener('pointerlockchange', () => {

            if (document.pointerLockElement === this.domElement) {

                document.addEventListener('mousemove', this.onMouseMove.bind(this));

            } else {

                document.removeEventListener('mousemove', this.onMouseMove.bind(this));

            }

        });

    }



    // (Mobile) Configura os botões de toque

    initMobileControls() {

        // Mostra os botões de D-Pad e Ação

        document.getElementById('dpad-container').style.display = 'grid';

        document.getElementById('action-btn').style.display = 'block';



        // Ouvintes do D-Pad (touchstart = pressionar, touchend = soltar)

        this.addTouchListener('dpad-forward', 'forward');

        this.addTouchListener('dpad-backward', 'backward');

        this.addTouchListener('dpad-left', 'left');

        this.addTouchListener('dpad-right', 'right');



        // Ouvinte do Botão de Ação

        document.getElementById('action-btn').addEventListener('touchstart', (e) => {

            e.preventDefault();

            this.onInteract(); // Chama a função de interação

        });

        

        // Ouvinte de Toque na Tela (para olhar ao redor)

        this.domElement.addEventListener('touchstart', this.onMobileTouchStart.bind(this));

        this.domElement.addEventListener('touchmove', this.onMobileTouchMove.bind(this));

        this.domElement.addEventListener('touchend', this.onMobileTouchEnd.bind(this));

    }



    // (Mobile) Função auxiliar para adicionar ouvintes de toque

    addTouchListener(elementId, direction) {

        const element = document.getElementById(elementId);

        element.addEventListener('touchstart', (e) => {

            e.preventDefault();

            this.moveState[direction] = true;

        });

        element.addEventListener('touchend', (e) => {

            e.preventDefault();

            this.moveState[direction] = false;

        });

    }



    // -----------------------------------------------------------------

    // HANDLERS DE EVENTO (MOVIMENTO / AÇÃO)

    // -----------------------------------------------------------------



    // (Desktop) Tecla pressionada

    onKeyDown(event) {

        switch (event.code) {

            case 'ArrowUp':

            case 'KeyW': this.moveState.forward = true; break;

            case 'ArrowLeft':

            case 'KeyA': this.moveState.left = true; break;

            case 'ArrowDown':

            case 'KeyS': this.moveState.backward = true; break;

            case 'ArrowRight':

            case 'KeyD': this.moveState.right = true; break;

            case 'KeyE': this.onInteract(); break; // Tecla de Interação [E]

        }

    }



    // (Desktop) Tecla solta

    onKeyUp(event) {

        switch (event.code) {

            case 'ArrowUp':

            case 'KeyW': this.moveState.forward = false; break;

            case 'ArrowLeft':

            case 'KeyA': this.moveState.left = false; break;

            case 'ArrowDown':

            case 'KeyS': this.moveState.backward = false; break;

            case 'ArrowRight':

            case 'KeyD': this.moveState.right = false; break;

        }

    }



    // (Desktop) Movimento do mouse (Pointer Lock)

    onMouseMove(event) {

        if (document.pointerLockElement !== this.domElement) return;



        const movementX = event.movementX || 0;

        const movementY = event.movementY || 0;



        // Rotação Horizontal (Yaw) - Eixo Y

        this.cameraLook.yaw -= movementX * this.sensitivity;

        

        // Rotação Vertical (Pitch) - Eixo X

        this.cameraLook.pitch -= movementY * this.sensitivity;

        

        // Trava a rotação vertical (para não "quebrar o pescoço")

        this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));

        

        // Aplica as rotações (Ordem EULER_YXZ é importante para FPS)

        this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');

    }



    // (Mobile) Início do toque na tela

    onMobileTouchStart(event) {

        event.preventDefault();

        // Itera sobre os toques

        for (const touch of event.changedTouches) {

            // Se o toque for na metade direita da tela, é para "olhar"

            if (touch.clientX > window.innerWidth / 2 && this.lookTouchId === null) {

                this.lookTouchId = touch.identifier;

                this.lastLookPos.x = touch.clientX;

                this.lastLookPos.y = touch.clientY;

            }

        }

    }



    // (Mobile) Movimento do toque na tela (Olhar)

    onMobileTouchMove(event) {

        event.preventDefault();

        for (const touch of event.changedTouches) {

            // Se for o toque que estamos rastreando para "olhar"

            if (touch.identifier === this.lookTouchId) {

                const deltaX = touch.clientX - this.lastLookPos.x;

                const deltaY = touch.clientY - this.lastLookPos.y;



                // Salva a nova posição

                this.lastLookPos.x = touch.clientX;

                this.lastLookPos.y = touch.clientY;



                // Aplica a rotação (similar ao onMouseMove)

                this.cameraLook.yaw -= deltaX * this.sensitivity;

                this.cameraLook.pitch -= deltaY * this.sensitivity;

                this.cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraLook.pitch));

                

                this.camera.rotation.set(this.cameraLook.pitch, this.cameraLook.yaw, 0, 'YXZ');

            }

        }

    }



    // (Mobile) Fim do toque na tela

    onMobileTouchEnd(event) {

        event.preventDefault();

        for (const touch of event.changedTouches) {

            // Se o toque que terminou era o de "olhar", para de rastrear

            if (touch.identifier === this.lookTouchId) {

                this.lookTouchId = null;

            }

        }

    }





    // -----------------------------------------------------------------

    // ATUALIZAÇÃO (LOOP PRINCIPAL) E COLISÃO

    // -----------------------------------------------------------------



    /**

     * Define os limites de colisão do mundo atual.

     * @param {number} worldId - 1 para Floresta.

     * @param {Object} limits - O objeto de limites vindo de 'scene.js'.

     */

    setWorld(worldId, limits) {

        this.currentWorld = worldId;

        this.collisionLimits = limits;

    }

    

    /**

     * Reseta a rotação da câmera (usado na transição).

     */

    resetRotation() {

        this.cameraLook.pitch = 0;

        this.cameraLook.yaw = 0;

        this.camera.rotation.set(0, 0, 0, 'YXZ');

    }



    /**

     * Chamado a cada frame pelo 'main.js'.

     * @param {number} delta - O tempo (em segundos) desde o último frame.

     */

    update(delta) {

        // Velocidade = 1.8 m/s (conforme UX finalizado)

        const moveSpeed = this.settings.movementSpeed * delta;



        // Reseta a direção do movimento

        this.direction.z = Number(this.moveState.forward) - Number(this.moveState.backward);

        this.direction.x = Number(this.moveState.left) - Number(this.moveState.right);

        this.direction.normalize(); // Garante movimento consistente (diagonal != mais rápido)



        // Salva a posição atual para checagem de colisão

        const oldPosition = this.camera.position.clone();



        // Calcula o movimento relativo à direção que a câmera está olhando

        if (this.moveState.forward || this.moveState.backward) {

            this.camera.translateZ(-this.direction.z * moveSpeed);

        }

        if (this.moveState.left || this.moveState.right) {

            this.camera.translateX(-this.direction.x * moveSpeed);

        }



        // --- LÓGICA DE COLISÃO ---

        // Impede o jogador de sair dos limites definidos

        if (this.collisionLimits) {

            this.applyCollisions(oldPosition);

        }

        

        // Mantém a altura do jogador (impede de voar ou afundar)

        this.camera.position.y = this.settings.playerHeight;

    }



    /**

     * Verifica e aplica as colisões baseadas nos limites do mundo.

     * @param {THREE.Vector3} oldPosition - Posição antes do movimento.

     */

    applyCollisions(oldPosition) {

        const newPosition = this.camera.position;

        const limits = this.collisionLimits;



        // Lógica de Colisão simples de "caixa" (para o mundo da floresta)

        newPosition.x = Math.max(limits.minX, Math.min(limits.maxX, newPosition.x));

        newPosition.z = Math.max(limits.minZ, Math.min(limits.maxZ, newPosition.z));

        

        // Aplica a posição corrigida

        this.camera.position.copy(newPosition);

    }

}

interactions.js/geral

/*

    ARQUIVO: js/geral/interaction.js

    DESCRIÇÃO: Gerenciador de Interação (Raycaster).

    FUNÇÃO: Esta classe é responsável por "atirar um raio" (Raycast)

    a partir do centro da tela (mira) para detectar com o que

    o jogador está olhando/interagindo.

    

    COMENTÁRIOS EM: PT-BR

*/



class InteractionHandler {



    /**

     * @param {THREE.Camera} camera - A câmera do jogador (de onde o raio sai).

     * @param {THREE.Scene} scene - A cena (onde os objetos estão).

     *S @param {Function} onInteractCallback - Função em 'main.js' a ser chamada

     * quando uma interação válida ocorre.

     */

    constructor(camera, scene, onInteractCallback) {

        this.camera = camera;

        this.scene = scene;

        this.onInteractCallback = onInteractCallback;



        // O Raycaster do Three.js

        this.raycaster = new THREE.Raycaster();

        

        // Coordenadas da mira (sempre [0, 0] = centro da tela)

        this.crosshairCoords = new THREE.Vector2(0, 0);



        // Distância máxima de interação (ex: 3 metros)

        this.interactionDistance = 3.0; 



        // Armazena o objeto que está atualmente na mira

        this.currentTarget = null;

    }



    /**

     * Chamado quando o jogador pressiona [E] ou o Botão de Ação.

     * Esta é a função que efetivamente "dispara" a interação.

     */

    triggerInteraction() {

        // Verifica se há um alvo válido na mira

        if (this.currentTarget) {

            // Chama a função de callback em 'main.js'

            // e passa os dados do objeto (ex: { type: 'gothic_door' })

            this.onInteractCallback(this.currentTarget.userData);

        } else {

            // (Opcional) Tocar um som de "falha" se não houver nada

            console.log("Nenhum alvo interativo ao alcance.");

        }

    }



    /**

     * Chamado a cada frame pelo 'main.js' (ANTES do update de controles).

     * Esta função *apenas* verifica o que está na mira, mas não

     * dispara a ação.

     */

    update() {

        // 1. Atualiza o raio para sair do centro da câmera

        this.raycaster.setFromCamera(this.crosshairCoords, this.camera);



        // 2. Verifica quais objetos na cena (recursivamente) o raio atinge

        // Passamos 'this.scene.children' e 'true' para verificar os filhos

        // dos grupos (World1_Group).

        const intersects = this.raycaster.intersectObjects(this.scene.children, true);



        // Reseta o alvo atual

        this.currentTarget = null;



        // 3. Itera sobre os objetos atingidos

        for (const intersect of intersects) {

            

            // 4. Verifica se o objeto tem o 'userData' interativo

            // (Nós definimos isso em 'CenaFloresta.js')

            if (intersect.object.userData && intersect.object.userData.interactive === true) {

                

                // 5. Verifica se está dentro da distância permitida

                if (intersect.distance <= this.interactionDistance) {

                    

                    // Encontramos um alvo válido!

                    this.currentTarget = intersect.object;

                    

                    // (Opcional) Mudar a cor da mira para "ativa"

                    // document.getElementById('crosshair').style.color = 'red';

                    

                    // Para o loop assim que encontrar o primeiro alvo válido

                    break;

                }

            }

        }

        

        // Se o loop terminou e this.currentTarget ainda é nulo,

        // significa que não estamos olhando para nada interativo.

        if (this.currentTarget === null) {

            // (Opcional) Resetar a cor da mira para "passiva"

            // document.getElementById('crosshair').style.color = 'rgba(255, 255, 255, 0.7)';

        }

    }

}

loader.js/geral

/*

    ARQUIVO: js/geral/loader.js

    DESCRIÇÃO: Gerenciador de Carregamento de Assets.

    FUNÇÃO: Este script é responsável por carregar todas as texturas (imagens)

    necessárias para o projeto ANTES que a experiência comece.

    

    COMENTÁRIOS EM: PT-BR

*/



class AssetLoader {

  // O construtor recebe as funções que devem ser chamadas

  // durante o carregamento (onProgress) e ao finalizar (onLoad).

  constructor(onProgress, onLoad) {

    // O LoadingManager monitora todos os loaders.

    this.manager = new THREE.LoadingManager();



    // Define as funções de callback do manager.

    this.manager.onProgress = (url, itemsLoaded, itemsTotal) => {

      // Calcula a porcentagem

      const progress = (itemsLoaded / itemsTotal) * 100;

      // Chama a função onProgress (definida em main.js)

      onProgress(progress);

      console.log(`Carregando: ${url} (${progress.toFixed(0)}%)`);

    };



    this.manager.onLoad = () => {

      // Chama a função onLoad (definida em main.js)

      onLoad();

      console.log("Todos os assets foram carregados.");

    };



    this.manager.onError = (url) => {

      console.error(`Erro ao carregar o asset: ${url}`);

    };



    // O TextureLoader é o responsável por carregar as imagens.

    // Passamos o manager para ele.

    this.textureLoader = new THREE.TextureLoader(this.manager);

  }



  /**

   * Carrega uma lista de texturas.

   * @param {Array<Object>} texturesToLoad - Um array de objetos { name, path }

   * @returns {Object} - Um objeto onde as chaves são os nomes (name) e os

   * valores são as texturas (THREE.Texture) carregadas.

   */

  loadTextures(texturesToLoad) {

    const textures = {};



    texturesToLoad.forEach((tex) => {

      // Carrega a textura

      const texture = this.textureLoader.load(tex.path);



      // Configurações de repetição (wrapping) e filtro

      // Essencial para texturas de chão e parede.

      if (tex.repeat) {

        texture.wrapS = THREE.RepeatWrapping;

        texture.wrapT = THREE.RepeatWrapping;

        texture.repeat.set(tex.repeat[0], tex.repeat[1]);

      }



      // Adiciona ao nosso objeto de texturas

      textures[tex.name] = texture;

    });



    // Retorna o objeto com todas as texturas (que ainda estão carregando,*mas o manager vai saber quando terminarem).

    return textures;

  }

}

main.js/geral

/*

    ARQUIVO: js/geral/main.js

    DESCRIÇÃO: Ponto de Entrada Principal da Aplicação (O "Maestro").

    FUNÇÃO: Este script inicializa todos os componentes da floresta (Cena 1),

    gerencia o "Game Loop" (o 'animate'), e lida com a lógica de

    interação para "terminar" a demo quando a porta é encontrada.

    

    COMENTÁRIOS EM: PT-BR

*/



// Classe principal da aplicação

class SungApp {

    

    constructor() {

        // Elementos do DOM

        this.canvas = document.getElementById('game-canvas');

        this.loadingScreen = document.getElementById('loading-screen');

        this.loadingText = document.querySelector('.loading-text');

        this.transitionFade = document.getElementById('transition-fade');

        this.gameEndMessage = document.getElementById('game-end-message'); // Mensagem de Fim

        this.uiElements = [

            document.getElementById('crosshair'),

            document.getElementById('logo'),

            document.getElementById('copyright')

        ];



        // Componentes do Three.js

        this.scene = new THREE.Scene();

        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        this.renderer = new THREE.WebGLRenderer({ 

            canvas: this.canvas,

            antialias: true // Suavização de serrilhado

        });

        this.clock = new THREE.Clock(); // Relógio para o 'delta time'



        // Componentes do Jogo

        this.loader = null;

        this.controls = null;

        this.interaction = null;

        

        // Construtor de Cena

        this.forestBuilder = null;   // (Virá de CenaFloresta.js)

        

        // Grupo de Cena (Apenas Mundo 1)

        this.world1_Group = null;



        // Estado do Jogo

        this.isLoaded = false;

        this.isTransitioning = false; // Usado agora para o "fim de jogo"

        

        // Configurações (conforme UX finalizado)

        this.settings = {

            movementSpeed: 1.8,         // 1.8 m/s

            desktopCameraSpeed: 0.0008, // Sensibilidade Desktop

            mobileCameraSpeed: 0.0025,  // Sensibilidade Mobile

            playerHeight: 1.6           // Altura dos olhos do jogador

        };

        

        // Referência 'bind' para o loop de animação

        this.animate = this.animate.bind(this);

    }



    // -----------------------------------------------------------------

    // INICIALIZAÇÃO

    // -----------------------------------------------------------------

    

    /**

     * Método principal de inicialização

     */

    init() {

        console.log("Iniciando SungApp (Modo Floresta)...");



        try {

            // 1. Configurar o Renderizador

            this.renderer.setSize(window.innerWidth, window.innerHeight);

            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 

            this.renderer.outputEncoding = THREE.sRGBEncoding;



            // 2. Configurar a Posição Inicial da Câmera

            // (Na borda do mapa, na rodovia, em Z=90)

            this.camera.position.set(0, this.settings.playerHeight, 90);



            // 3. Inicializar o Loader de Assets (Texturas)

            this.loader = new AssetLoader(

                (progress) => {

                    // Função 'onProgress'

                    this.loadingText.textContent = `Carregando... ${progress.toFixed(0)}%`;

                },

                () => {

                    // Função 'onLoad' (Tudo carregado)

                    this.startExperience();

                }

            );



            // 4. Definir quais texturas carregar

            // (Apenas texturas da floresta, sem o corredor)

            const sceneTextures = [

                { name: 'rodovia', path: 'assets/rodovia_texture.jpg', repeat: [3, 10] },

                { name: 'porta', path: 'assets/porta.png' }, 

                { name: 'path', path: 'assets/path_texture.jpg', repeat: [2, 12] },

                { name: 'arvore', path: 'assets/arvore.png' },

                { name: 'crystalGlow', path: 'assets/crystal_glow.png' },

                { name: 'rock', path: 'assets/rock.png' },

                { name: 'forest_floor', path: 'assets/forest_floor.jpg', repeat: [50, 50] }

            ];

            

            // Carrega as texturas da cena

            const loadedTextures = this.loader.loadTextures(sceneTextures);

            

            // 5. Inicializar a "Fábrica" de Mundos com as texturas

            // (Usa a classe de js/floresta/CenaFloresta.js)

            this.forestBuilder = new ForestSceneBuilder(loadedTextures);



            // 6. Ouvinte de redimensionamento da janela

            window.addEventListener('resize', this.onWindowResize.bind(this));

        

        } catch (error) {

            console.error("Falha fatal na inicialização:", error);

            this.loadingText.textContent = "Erro ao carregar. Verifique o console.";

            this.loadingText.style.color = "red";

        }

    }

    

    /**

     * Chamado quando o Loader termina (onLoad).

     */

    startExperience() {

        console.log("Assets carregados. Iniciando a experiência.");

        this.isLoaded = true;

        

        // 1. Construir o Mundo 1 (Floresta)

        const world1Data = this.forestBuilder.createWorld1(this.scene);

        this.world1_Group = world1Data.group;

        this.scene.add(this.world1_Group);



        // 2. Inicializar Controles

        this.controls = new PlayerControls(this.camera, this.canvas, this.settings);

        // Define os limites de colisão para o mundo 1

        this.controls.setWorld(1, world1Data.collisionLimits);

        

        // 3. Inicializar Interação

        this.interaction = new InteractionHandler(

            this.camera, 

            this.scene, 

            this.handleInteraction.bind(this) // Callback

        );

        

        // 4. Conectar Controles e Interação

        // Diz ao 'controls' qual função chamar quando [E] é pressionado

        this.controls.onInteract = () => {

            this.interaction.triggerInteraction();

        };



        // 5. Esconder a tela de Loading e mostrar a UI do Jogo

        this.loadingScreen.style.opacity = '0';

        setTimeout(() => {

            this.loadingScreen.style.display = 'none';

        }, 500); // 0.5s (duração da transição do CSS)



        // Mostra a UI (Mira, Logo, etc.)

        this.uiElements.forEach(el => el.style.display = 'block');

        

        // 6. Iniciar o Loop de Animação

        this.animate();

    }

    

    // -----------------------------------------------------------------

    // LOOP DE ANIMAÇÃO (GAME LOOP)

    // -----------------------------------------------------------------



    /**

     * O Loop Principal (requestAnimationFrame).

     */

    animate() {

        // Pede ao navegador para chamar 'animate' no próximo frame

        requestAnimationFrame(this.animate);



        // Se não carregou ou está em transição de fim de jogo, para

        if (!this.isLoaded || this.isTransitioning) {

            return;

        }



        // Pega o tempo delta (diferença do último frame)

        const delta = this.clock.getDelta();



        // 1. Atualiza o handler de interação (verifica o que está na mira)

        this.interaction.update();

        

        // 2. Atualiza os controles do jogador (movimento, colisão)

        this.controls.update(delta);



        // 3. Renderiza a cena 3D

        this.renderer.render(this.scene, this.camera);

    }

    

    // -----------------------------------------------------------------

    // LÓGICA DE INTERAÇÃO (FIM DE JOGO)

    // -----------------------------------------------------------------

    

    /**

     * Callback chamado pelo 'InteractionHandler' quando [E] é pressionado

     * em um alvo válido.

     * @param {Object} userData - Os dados do objeto (ex: { type: 'gothic_door' })

     */

    handleInteraction(userData) {

        console.log("Interação disparada:", userData);

        

        // Verifica se é a porta gótica

        if (userData.type === 'gothic_door') {

            this.triggerGameEnd();

        }

    }



    /**

     * Executa o "Fim de Jogo" (Fade para Branco e mensagem)

     */

    triggerGameEnd() {

        if (this.isTransitioning) return; // Previne cliques duplos

        

        console.log("Fim da demo. Iniciando fade out...");

        this.isTransitioning = true; // Pausa o 'animate' loop



        // 1. Fade In Rápido (0.5s) para Branco

        this.transitionFade.style.transition = 'opacity 0.5s ease-in';

        this.transitionFade.style.opacity = '1';



        // 2. Mostra a mensagem "CONTINUA..."

        // (O delay da transição está no CSS)

        this.gameEndMessage.style.opacity = '1';



        // 3. Trava os controles

        // Se o PointerLock estiver ativo, destrava o mouse

        if (document.pointerLockElement) {

            document.exitPointerLock();

        }

        // Esconde a UI do jogo

        this.uiElements.forEach(el => el.style.display = 'none');

        document.getElementById('dpad-container').style.display = 'none';

        document.getElementById('action-btn').style.display = 'none';

    }



    // -----------------------------------------------------------------

    // UTILITÁRIOS

    // -----------------------------------------------------------------



    /**

     * Chamado quando a janela do navegador muda de tamanho.

     */

    onWindowResize() {

        // Atualiza as proporções da câmera

        this.camera.aspect = window.innerWidth / window.innerHeight;

        this.camera.updateProjectionMatrix();



        // Atualiza o tamanho do renderizador

        this.renderer.setSize(window.innerWidth, window.innerHeight);

        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    }

}



// -----------------------------------------------------------------

// PONTO DE ENTRADA

// -----------------------------------------------------------------



// Quando o DOM (HTML) estiver pronto, cria e inicializa a aplicação.

window.addEventListener('DOMContentLoaded', () => {

    // Lembrete sobre o servidor local (para o 'fetch' funcionar)

    if (window.location.protocol === 'file:') {

        console.error("ERRO: O projeto não pode ser executado localmente via 'file://'. Use um servidor local (veja como_rodar.txt).");

        document.body.innerHTML = '<div style="color: red; font-size: 20px; padding: 20px;">ERRO: O projeto não pode ser executado localmente. Por favor, use um servidor (veja o arquivo como_rodar.txt).</div>';

        return;

    }

    

    const app = new SungApp();

    app.init();

});

Perfeito! Ver a sua estrutura de pastas (image_fbb99b.png) é a informação mais importante que você podia me dar. Agora eu sei exatamente como seu projeto está organizado e por que as texturas não estavam funcionando.

Você está com a lógica certa ("terra 2 perto do asfalto, terra 1 na clareira"), mas o código que você tem ainda não reflete essa nova estrutura de pastas.

Vamos corrigir tudo.

🗺️ Sua Lista de Ações
Aqui está o que você precisa fazer para o projeto funcionar.

Baixar Texturas Faltando: Respondendo à sua pergunta: Sim, você ainda precisa baixar as texturas das árvores (arvore.png), da porta (porta.png), das rochas (rock.png) e do cristal (crystal_glow.png). A sua nova estrutura de pastas não mostra esses arquivos. Coloque-os todos dentro da pasta /assets/ (não precisa criar subpastas para eles, a menos que queira).

Corrigir o index.html: O seu index.html está com a ordem dos scripts errada e nem está carregando o arquivo cenaFloresta.js. Este é o erro principal.

Corrigir o js/geral/main.js: A sua lista de texturas (sceneTextures) está completamente errada. Ela precisa ser atualizada para apontar para as suas novas pastas (assets/asphalt/, assets/floresta/solo_terra_01/, etc.).

Corrigir o js/floresta/cenaFloresta.js: Vamos atualizar este arquivo para ele usar as texturas certas (solo_terra_01, solo_terra_02, etc.) e para ele realmente criar os dois tipos de chão que você pediu.

Abaixo estão os 3 arquivos que você precisa substituir (o código CSS e os outros JS estão corretos).

index.html (CORRIGIDO)
O que mudou:

Adicionei a linha script src="js/floresta/cenaFloresta.js" (estava faltando).

Reordenei os scripts. A ordem correta é: loader, controls, interaction, cenaFloresta, e por último main.

HTML
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sung Studios - A Caçada</title> 
    
    <link rel="stylesheet" href="CSS/styles.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-text">Carregando...</div>
    </div>

    <div id="rotate-message">
        <p>Por favor, gire seu dispositivo para a posição horizontal (paisagem) para iniciar a experiência.</p>
    </div>

    <div id="transition-fade">
        <div id="game-end-message">CONTINUA...</div>
    </div>

    <div id="crosshair">+</div>

    <div id="dpad-container">
        <button id="dpad-forward" class="dpad-btn">▲</button>
        <button id="dpad-backward" class="dpad-btn">▼</button>
        <button id="dpad-left" class="dpad-btn">◄</button>
        <button id="dpad-right" class="dpad-btn">►</button>
    </div>
    <button id="action-btn">E</button>

    <div id="logo">
        <img src="assets/belial.png" alt="Sung Studios Logo">
    </div>
    <div id="copyright">© 2025 D'Artagnan AI Studios - Feito pela Equipe Sung</div>

    <canvas id="game-canvas"></canvas>

    <script src="js/geral/loader.js"></script>
    <script src="js/geral/controls.js"></script>
    <script src="js/geral/interaction.js"></script>
    
    <script src="js/floresta/cenaFloresta.js"></script> <script src="js/geral/main.js"></script>

</body>
</html>
js/geral/main.js (CORRIGIDO)
O que mudou:

A lista sceneTextures foi completamente refeita para apontar para suas novas pastas (assets/asphalt/, assets/floresta/solo_terra_01/, etc.).

Adicionei os assets que ainda faltam (porta, arvore, crystalGlow, rock) apontando para a pasta /assets/ principal.

Mudei new ForestSceneBuilder para new CenaFlorestaBuilder para bater com o nome da sua classe.

IMPORTANTE: Eu assumi que os nomes dos arquivos de textura dentro das suas pastas são ..._Color.jpg (o padrão do AmbientCG). Se o seu arquivo de asfalto for, por exemplo, asphalt_01.jpg, você deve mudar o path: abaixo para bater com o nome do seu arquivo.

JavaScript
/*
    ARQUIVO: js/geral/main.js
    DESCRIÇÃO: Ponto de Entrada Principal da Aplicação (O "Maestro").
    FUNÇÃO: Este script inicializa todos os componentes da floresta (Cena 1),
    gerencia o "Game Loop" (o 'animate'), e lida com a lógica de
    interação para "terminar" a demo quando a porta é encontrada.
    
    COMENTÁRIOS EM: PT-BR
*/

// Classe principal da aplicação
class SungApp {
    
    constructor() {
        // Elementos do DOM
        this.canvas = document.getElementById('game-canvas');
        this.loadingScreen = document.getElementById('loading-screen');
        this.loadingText = document.querySelector('.loading-text');
        this.transitionFade = document.getElementById('transition-fade');
        this.gameEndMessage = document.getElementById('game-end-message'); // Mensagem de Fim
        this.uiElements = [
            document.getElementById('crosshair'),
            document.getElementById('logo'),
            document.getElementById('copyright')
        ];

        // Componentes do Three.js
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true // Suavização de serrilhado
        });
        this.clock = new THREE.Clock(); // Relógio para o 'delta time'

        // Componentes do Jogo
        this.loader = null;
        this.controls = null;
        this.interaction = null;
        
        // Construtor de Cena
        this.forestBuilder = null;   // (Virá de cenaFloresta.js)
        
        // Grupo de Cena (Apenas Mundo 1)
        this.world1_Group = null;

        // Estado do Jogo
        this.isLoaded = false;
        this.isTransitioning = false; // Usado agora para o "fim de jogo"
        
        // Configurações (conforme UX finalizado)
        this.settings = {
            movementSpeed: 1.8,         // 1.8 m/s
            desktopCameraSpeed: 0.0008, // Sensibilidade Desktop
            mobileCameraSpeed: 0.0025,  // Sensibilidade Mobile
            playerHeight: 1.6           // Altura dos olhos do jogador
        };
        
        // Referência 'bind' para o loop de animação
        this.animate = this.animate.bind(this);
    }

    // -----------------------------------------------------------------
    // INICIALIZAÇÃO
    // -----------------------------------------------------------------
    
    /**
     * Método principal de inicialização
     */
    init() {
        console.log("Iniciando SungApp (Modo Floresta)...");

        try {
            // 1. Configurar o Renderizador
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            this.renderer.outputEncoding = THREE.sRGBEncoding;

            // 2. Configurar a Posição Inicial da Câmera
            // (Na borda do mapa, na rodovia, em Z=90)
            this.camera.position.set(0, this.settings.playerHeight, 90);

            // 3. Inicializar o Loader de Assets (Texturas)
            this.loader = new AssetLoader(
                (progress) => {
                    // Função 'onProgress'
                    this.loadingText.textContent = `Carregando... ${progress.toFixed(0)}%`;
                },
                () => {
                    // Função 'onLoad' (Tudo carregado)
                    this.startExperience();
                }
            );

            // 4. Definir quais texturas carregar
            // **** LISTA DE TEXTURAS TOTALMENTE ATUALIZADA ****
            // (Baseada na sua captura de tela 'image_fbb99b.png')
            const sceneTextures = [
                // Texturas das suas novas pastas
                // VERIFIQUE SE O NOME DO ARQUIVO (ex: 'Asphalt_Color.jpg') ESTÁ CORRETO
                { name: 'asphalt', path: 'assets/asphalt/Asphalt_Color.jpg', repeat: [3, 10] },
                { name: 'solo_terra_01', path: 'assets/floresta/solo_terra_01/Ground_Color.jpg', repeat: [50, 50] },
                { name: 'solo_terra_02', path: 'assets/floresta/solo_terra_02/Ground_Color.jpg', repeat: [20, 20] },
                { name: 'terra_trilha', path: 'assets/floresta/terra_trilha/Bricks_Color.jpg', repeat: [2, 12] },
                
                // Texturas FALTANDO (coloque-as soltas na pasta /assets/)
                { name: 'porta', path: 'assets/porta.png' }, 
                { name: 'arvore', path: 'assets/arvore.png' },
                { name: 'crystalGlow', path: 'assets/crystal_glow.png' },
                { name: 'rock', path: 'assets/rock.png' },
            ];
            
            // Carrega as texturas da cena
            const loadedTextures = this.loader.loadTextures(sceneTextures);
            
            // 5. Inicializar a "Fábrica" de Mundos com as texturas
            // (Usa a classe de js/floresta/cenaFloresta.js)
            // *** NOME DA CLASSE ATUALIZADO ***
            this.forestBuilder = new CenaFlorestaBuilder(loadedTextures);

            // 6. Ouvinte de redimensionamento da janela
            window.addEventListener('resize', this.onWindowResize.bind(this));
        
        } catch (error) {
            console.error("Falha fatal na inicialização:", error);
            this.loadingText.textContent = "Erro ao carregar. Verifique o console.";
            this.loadingText.style.color = "red";
        }
    }
    
    /**
     * Chamado quando o Loader termina (onLoad).
     */
    startExperience() {
        console.log("Assets carregados. Iniciando a experiência.");
        this.isLoaded = true;
        
        // 1. Construir o Mundo 1 (Floresta)
        const world1Data = this.forestBuilder.createWorld1(this.scene);
        this.world1_Group = world1Data.group;
        this.scene.add(this.world1_Group);

        // 2. Inicializar Controles
        this.controls = new PlayerControls(this.camera, this.canvas, this.settings);
        // Define os limites de colisão para o mundo 1
        this.controls.setWorld(1, world1Data.collisionLimits);
        
        // 3. Inicializar Interação
        this.interaction = new InteractionHandler(
            this.camera, 
            this.scene, 
            this.handleInteraction.bind(this) // Callback
        );
        
        // 4. Conectar Controles e Interação
        // Diz ao 'controls' qual função chamar quando [E] é pressionado
        this.controls.onInteract = () => {
            this.interaction.triggerInteraction();
        };

        // 5. Esconder a tela de Loading e mostrar a UI do Jogo
        this.loadingScreen.style.opacity = '0';
        setTimeout(() => {
            this.loadingScreen.style.display = 'none';
        }, 500); // 0.5s (duração da transição do CSS)

        // Mostra a UI (Mira, Logo, etc.)
        this.uiElements.forEach(el => el.style.display = 'block');
        
        // 6. Iniciar o Loop de Animação
        this.animate();
    }
    
    // -----------------------------------------------------------------
    // LOOP DE ANIMAÇÃO (GAME LOOP)
    // -----------------------------------------------------------------

    /**
     * O Loop Principal (requestAnimationFrame).
     */
    animate() {
        // Pede ao navegador para chamar 'animate' no próximo frame
        requestAnimationFrame(this.animate);

        // Se não carregou ou está em transição de fim de jogo, para
        if (!this.isLoaded || this.isTransitioning) {
            return;
        }

        // Pega o tempo delta (diferença do último frame)
        const delta = this.clock.getDelta();

        // 1. Atualiza o handler de interação (verifica o que está na mira)
        this.interaction.update();
        
        // 2. Atualiza os controles do jogador (movimento, colisão)
        this.controls.update(delta);

        // 3. Renderiza a cena 3D
        this.renderer.render(this.scene, this.camera);
    }
    
    // -----------------------------------------------------------------
    // LÓGICA DE INTERAÇÃO (FIM DE JOGO)
    // -----------------------------------------------------------------
    
    /**
     * Callback chamado pelo 'InteractionHandler' quando [E] é pressionado
     * em um alvo válido.
     * @param {Object} userData - Os dados do objeto (ex: { type: 'gothic_door' })
     */
    handleInteraction(userData) {
        console.log("Interação disparada:", userData);
        
        // Verifica se é a porta gótica
        if (userData.type === 'gothic_door') {
            this.triggerGameEnd();
        }
    }

    /**
     * Executa o "Fim de Jogo" (Fade para Branco e mensagem)
     */
    triggerGameEnd() {
        if (this.isTransitioning) return; // Previne cliques duplos
        
        console.log("Fim da demo. Iniciando fade out...");
        this.isTransitioning = true; // Pausa o 'animate' loop

        // 1. Fade In Rápido (0.5s) para Branco
        this.transitionFade.style.transition = 'opacity 0.5s ease-in';
        this.transitionFade.style.opacity = '1';

        // 2. Mostra a mensagem "CONTINUA..."
        // (O delay da transição está no CSS)
        this.gameEndMessage.style.opacity = '1';

        // 3. Trava os controles
        // Se o PointerLock estiver ativo, destrava o mouse
        if (document.pointerLockElement) {
            document.exitPointerLock();
        }
        // Esconde a UI do jogo
        this.uiElements.forEach(el => el.style.display = 'none');
        document.getElementById('dpad-container').style.display = 'none';
        document.getElementById('action-btn').style.display = 'none';
    }

    // -----------------------------------------------------------------
    // UTILITÁRIOS
    // -----------------------------------------------------------------

    /**
     * Chamado quando a janela do navegador muda de tamanho.
     */
    onWindowResize() {
        // Atualiza as proporções da câmera
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();

        // Atualiza o tamanho do renderizador
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}

// -----------------------------------------------------------------
// PONTO DE ENTRADA
// -----------------------------------------------------------------

// Quando o DOM (HTML) estiver pronto, cria e inicializa a aplicação.
window.addEventListener('DOMContentLoaded', () => {
    // Lembrete sobre o servidor local (para o 'fetch' funcionar)
    if (window.location.protocol === 'file:') {
        console.error("ERRO: O projeto não pode ser executado localmente via 'file://'. Use um servidor local (veja como_rodar.txt).");
        document.body.innerHTML = '<div style="color: red; font-size: 20px; padding: 20px;">ERRO: O projeto não pode ser executado localmente. Por favor, use um servidor (veja o arquivo como_rodar.txt).</div>';
        return;
    }
    
    // Verifica se todas as classes necessárias foram carregadas
    if (typeof CenaFlorestaBuilder === 'undefined') {
        console.error("ERRO CRÍTICO: O arquivo 'js/floresta/cenaFloresta.js' não foi carregado. Verifique o caminho no index.html.");
        document.body.innerHTML = '<div style="color: red; font-size: 20px; padding: 20px;">ERRO CRÍTICO: O arquivo \'js/floresta/cenaFloresta.js\' não foi carregado.</div>';
        return;
    }
    
    const app = new SungApp();
    app.init();
});
js/floresta/cenaFloresta.js (CORRIGIDO)
O que mudou:

Renomeei a classe para CenaFlorestaBuilder (para bater com o nome do arquivo).

Atualizei os materiais do chão para usar this.textures.solo_terra_01 (clareira) e this.textures.asphalt (rodovia).

Adicionei a lógica do "Terra 2": Criei um novo plano (forestFloor_edge) que usa this.textures.solo_terra_02 e o posicionei perto da rodovia, como você pediu.

Atualizei o material da trilha para usar this.textures.terra_trilha.

Ajustei o tamanho do mapa para 400x400 para ser "bem grande", e aumentei as árvores para 4000 para manter a densidade.

Ajustei a posição da porta e da trilha para o novo tamanho do mapa.

JavaScript
/*
    ARQUIVO: js/floresta/cenaFloresta.js
    DESCRIÇÃO: Construtor de Cenário 3D - MUNDO 1 (FLORESTA).
    FUNÇÃO: Esta classe é uma "fábrica" de geometria. Ela contém
    apenas o método `createWorld1` para construir a cena da floresta.
    
    COMENTÁRIOS EM: PT-BR
*/

// *** NOME DA CLASSE ATUALIZADO ***
class CenaFlorestaBuilder {

    constructor(textures) {
        // Armazena as texturas que o 'loader.js' carregou.
        this.textures = textures;
        // Altura padrão da câmera (nível dos olhos)
        this.playerHeight = 1.6;
    }

    // -----------------------------------------------------------------
    // CENA 1: A DESCOBERTA (MUNDO ABERTO / FLORESTA)
    // -----------------------------------------------------------------
    createWorld1(scene) {
        const world1Group = new THREE.Group();
        world1Group.name = "World1_Group"; // Nome para depuração

        // 1. Configuração do Clima (Névoa e Luz)
        const fogColor = 0x2c3e50; 
        scene.background = new THREE.Color(fogColor);
        scene.fog = new THREE.Fog(fogColor, 1, 60); // Névoa um pouco mais distante para o mapa maior

        // Luz ambiente fraca
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
        world1Group.add(ambientLight);

        // Luz direcional (simulando lua)
        const directionalLight = new THREE.DirectionalLight(0x505a70, 0.4);
        directionalLight.position.set(5, 10, 5);
        world1Group.add(directionalLight);

        
        // 2. Geometria do Chão (Mundo Aberto - 400x400)
        
        // Chão da Clareira (solo_terra_01) - O MAPA INTEIRO
        const forestFloorMaterial = new THREE.MeshBasicMaterial({ 
            map: this.textures.solo_terra_01 // <-- TEXTURA ATUALIZADA
        });
        const forestFloorGeometry = new THREE.PlaneGeometry(400, 400); // <-- BEM GRANDE
        const forestFloor = new THREE.Mesh(forestFloorGeometry, forestFloorMaterial);
        forestFloor.rotation.x = -Math.PI / 2;
        forestFloor.position.set(0, 0, 0); // Centralizado na origem
        world1Group.add(forestFloor);

        // Chão Perto do Asfalto (solo_terra_02)
        const edgeFloorMaterial = new THREE.MeshBasicMaterial({
            map: this.textures.solo_terra_02 // <-- TEXTURA ATUALIZADA
        });
        const edgeFloorGeometry = new THREE.PlaneGeometry(400, 100); // Faixa de 100m
        const edgeFloor = new THREE.Mesh(edgeFloorGeometry, edgeFloorMaterial);
        edgeFloor.rotation.x = -Math.PI / 2;
        edgeFloor.position.set(0, 0.01, 150); // Posicionado perto da borda do asfalto
        world1Group.add(edgeFloor);


        // Rodovia (asphalt) - PONTO DE INÍCIO
        const roadMaterial = new THREE.MeshBasicMaterial({ 
            map: this.textures.asphalt // <-- TEXTURA ATUALIZADA
        });
        const roadGeometry = new THREE.PlaneGeometry(20, 100); // (largura, comprimento)
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; 
        road.position.set(0, 0.02, 150); // Na borda do mapa (Z=100 a Z=200)
        world1Group.add(road);

        // Trilha de Tijolos ESCONDIDA (terra_trilha)
        const pathMaterial = new THREE.MeshBasicMaterial({ 
            map: this.textures.terra_trilha // <-- TEXTURA ATUALIZADA
        });
        const pathGeometry = new THREE.PlaneGeometry(3, 40); // Trilha estreita (3m x 40m)
        const path = new THREE.Mesh(pathGeometry, pathMaterial);
        path.rotation.x = -Math.PI / 2;
        // Posição escondida dentro da floresta
        path.position.set(50, 0.01, -100); // Escondida em X=50, Z=-100
        world1Group.add(path);


        // 3. Floresta Densa (Billboards de Árvores)
        // (Verifique se 'arvore.png' existe em /assets/)
        const treeMaterial = new THREE.SpriteMaterial({ 
            map: this.textures.arvore,
            fog: true,
            color: 0xcccccc 
        });
        
        // (Verifique se 'crystal_glow.png' existe em /assets/)
        const crystalMaterial = new THREE.SpriteMaterial({
            map: this.textures.crystalGlow,
            blending: THREE.AdditiveBlending, 
            fog: false, 
            transparent: true,
            opacity: 0.8
        });

        // (Verifique se 'rock.png' existe em /assets/)
        const rockMaterial = new THREE.SpriteMaterial({
            map: this.textures.rock,
            fog: true,
            color: 0xbbbbbb 
        });

        // Cria 4000 árvores para densidade no mapa grande
        for (let i = 0; i < 4000; i++) {
            const sprite = new THREE.Sprite(treeMaterial);
            
            const x = (Math.random() - 0.5) * 400; // X de -200 a 200
            const z = (Math.random() - 0.5) * 400; // Z de -200 a 200

            // *** LÓGICA PARA NÃO NASCER ÁRVORE NA ESTRADA OU NA TRILHA ***
            // Checa área da estrada (X -10 a 10, Z 100 a 200)
            if (x > -10 && x < 10 && z > 100 && z < 200) {
                continue; // Pula esta árvore
            }
            // Checa área da trilha (X 48.5 a 51.5, Z -120 a -80)
            if (x > 48.5 && x < 51.5 && z > -120 && z < -80) {
                continue; // Pula esta árvore
            }

            // Tamanho aleatório (árvores grandes e médias)
            const scale = Math.random() * 3 + 4; // Escala entre 4m e 7m
            sprite.scale.set(scale, scale, 1);
            sprite.position.set(x, scale / 2, z); // (x, altura, z)
            world1Group.add(sprite);
        }

        // Adiciona Rochas (200)
        for (let i = 0; i < 200; i++) {
            const rockSprite = new THREE.Sprite(rockMaterial);
            const x = (Math.random() - 0.5) * 400; 
            const z = (Math.random() - 0.5) * 400;
            
            if (x > -10 && x < 10 && z > 100 && z < 200) continue; 
            if (x > 48.5 && x < 51.5 && z > -120 && z < -80) continue; 

            const scale = Math.random() * 0.5 + 0.5; // Rochas pequenas
            rockSprite.scale.set(scale, scale, 1);
            rockSprite.position.set(x, scale / 2, z); // No chão
            world1Group.add(rockSprite);
        }

        // 4. A Pista de Cristais (As "Migalhas de Pão")
        // Guiando da estrada (0, 140) até a trilha (50, -80)
        const crystalPath = [
            {x: 5, z: 130},
            {x: 10, z: 120},
            {x: 15, z: 100},
            {x: 20, z: 80},
            {x: 30, z: 50},
            {x: 40, z: 20},
            {x: 50, z: -10},
            {x: 50, z: -30},
            {x: 50, z: -50},
            {x: 50, z: -70}, // Chegou na trilha
            {x: 50, z: -90},
            {x: 50, z: -110} // Perto da porta
        ];

        crystalPath.forEach(pos => {
            // Luz Pontual (azulada)
            const light = new THREE.PointLight(0xadd8e6, 1.5, 10); // (cor, intensidade, distância)
            light.position.set(pos.x, 1.5, pos.z); // Posição
            world1Group.add(light);
            
            // Sprite visual do cristal
            const crystalSprite = new THREE.Sprite(crystalMaterial);
            crystalSprite.position.copy(light.position);
            crystalSprite.scale.set(1.5, 2.5, 1); 
            world1Group.add(crystalSprite);
        });


        // 5. A Porta Gótica (Objetivo)
        // (Verifique se 'porta.png' existe em /assets/)
        const rockFaceMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 }); 
        const rockFaceGeometry = new THREE.PlaneGeometry(8, 8); // Parede de rocha
        const rockFace = new THREE.Mesh(rockFaceGeometry, rockFaceMaterial);
        // Posicionada no final da trilha escondida
        rockFace.position.set(50, 4, -120.5); // (x, altura, z)
        world1Group.add(rockFace);
        
        // A porta em si
        const doorMaterial = new THREE.MeshBasicMaterial({ 
            map: this.textures.porta,
            transparent: true 
        });
        const doorGeometry = new THREE.PlaneGeometry(4, 5); // Tamanho da porta
        const doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
        
        // Posiciona no final da trilha
        doorMesh.position.set(50, 2.5, -120); // (x, altura, z)
        
        // Adiciona o 'userData' para interação
        doorMesh.userData = { 
            interactive: true, 
            type: 'gothic_door' 
        };
        world1Group.add(doorMesh);


        // 6. Limites de Colisão (Mundo Aberto)
        // Bordas do mapa de 400x400
        const worldLimits = {
            minX: -198, // 2m de margem
            maxX: 198,
            minZ: -198,
            maxZ: 198
        };

        // Retorna o grupo de objetos e os limites de colisão
        return { group: world1Group, collisionLimits: worldLimits };
    }
}

